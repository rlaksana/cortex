# Implementation Plan: Cortex Memory MCP v1

**Branch**: `001-create-specs-000` | **Date**: 2025-10-09 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-create-specs-000/spec.md`

**Note**: This plan is generated by the `/speckit.plan` command and defines the complete implementation roadmap for Cortex Memory MCP v1.

## Summary

Cortex Memory MCP v1 is a minimal, Claude-friendly cross-session memory system exposing exactly two MCP tools (`memory.find` and `memory.store`) over STDIO transport. The system uses PostgreSQL 18+ as the single source of truth with full-text search (FTS) and pg_trgm for fuzzy matching, default branch isolation for parallel development, comprehensive audit trails for all mutations, and server-side orchestration of chunking, deduplication, indexing, and TTL management. The implementation supports 9 knowledge types (section, runbook, change, issue, decision, todo, release_note, ddl, pr_context) with strict idempotency guarantees, immutability enforcement for accepted ADRs and approved specs, and intelligent search routing with performance SLOs (P95 < 300ms on ≤3M sections, Top-3 relevance ≥80%).

**Technical Approach**: TypeScript MCP server with Zod validation, node-postgres for database access, structured logging via pino, comprehensive test coverage (Vitest for unit/integration, k6 for performance), and strict TDD workflow per constitutional requirements.

## Technical Context

**Language/Version**: TypeScript 5.3+ (Node.js 20+)

**Primary Dependencies**:
- **MCP SDK**: `@modelcontextprotocol/sdk` v1.0+ (STDIO transport, JSON-RPC)
- **Validation**: `zod` v3.22+ (runtime schema validation for 9 knowledge types)
- **Database**: `pg` v8.11+ (node-postgres client), `node-pg-pool` (connection pooling)
- **Logging**: `pino` v8.16+ (structured JSON logging)
- **Migrations**: `drizzle-kit` v0.20+ OR `node-pg-migrate` v6.2+
- **Testing**: `vitest` v1.0+ (unit/integration), `@testcontainers/postgresql` v10+ (E2E with real Postgres)
- **Performance**: `k6` v0.48+ (load testing, P95 latency measurement)
- **Development**: `ts-node-dev` v2.0+ (hot reload), `tsx` v4.0+ (fast TypeScript execution)

**Storage**: PostgreSQL 18+ (single source of truth)
- **Required Extensions**: `pgcrypto` (SHA-256 hashing), `pg_trgm` (fuzzy/similarity search for `mode="deep"`)
- **Indexes**: GIN for FTS vectors (`tsvector`), GIN for JSONB tags, GIN for pg_trgm similarity
- **Features**: `uuidv7()` for time-ordered UUIDs, skip-scan optimization, generated columns (virtual/stored)

**Testing**: Vitest (unit + integration), Testcontainers (E2E), k6 (performance)
- **Unit Tests**: Zod schema validation, chunking logic, deduplication, scope inference, ranking formula
- **Integration Tests**: Database round-trips, FTS indexing, TTL enforcement, audit logging, idempotency
- **E2E Tests**: Full MCP protocol over STDIO, golden path scenarios (feature find, bugfix find, store dedupe, branch isolation)
- **Performance Tests**: P95 latency @ 100K-1M sections, concurrent queries, relevance sampling

**Target Platform**: Linux/macOS/WSL2 (Node.js 20+ server process)

**Project Type**: Single MCP server (STDIO) - no frontend, API-only

**Performance Goals**:
- **Latency**: P95 < 300ms for `memory.find` on ≤3M sections (P95 < 100ms for `mode="fast"`)
- **Relevance**: Top-3 results ≥80% relevant (sampled human/LLM evaluation)
- **Throughput**: Handle 100+ concurrent `memory.find` requests without degradation
- **Audit**: 100% mutation coverage with zero audit gaps

**Constraints**:
- **Single-instance deployment** (no horizontal scaling in v1)
- **Branch-isolated reads** by default (scope widening explicit)
- **Immutability**: ADR content (status=`accepted`), event_audit table (append-only), approved specs (write-locked)
- **Idempotency**: All `memory.store` operations must be idempotent (via `idempotency_key` or synthesized composite)
- **Two-tool API**: No additional MCP tools permitted (constitutional constraint)

**Scale/Scope**:
- **Documents**: ≤1-3M sections (design target for P95 latency)
- **Knowledge Types**: Exactly 9 types (section, runbook, change, issue, decision, todo, release_note, ddl, pr_context)
- **Scope Hierarchy**: 6 levels (org, project, service, branch, sprint, tenant)
- **Concurrent Users**: 100+ AI agents querying simultaneously

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### I. Minimal API Surface ✅

**Requirement**: Expose exactly two MCP tools: `memory.find` and `memory.store`

**Compliance**: PASS
- Plan defines exactly 2 tools with JSON schemas matching SOT specification
- All server-side complexity (chunking, dedupe, indexing, TTL, ranking) hidden behind these tools
- No additional tools in scope

### II. Single Source of Truth (PostgreSQL 18+) ✅

**Requirement**: PostgreSQL 18+ as exclusive source of truth; Qdrant/Neo4j (if added) are read-optimized indexes only

**Compliance**: PASS
- PostgreSQL 18+ specified with required extensions (`pgcrypto`, `pg_trgm`)
- All 11 tables use `uuidv7()`, GIN indexes, generated columns per SOT DDL
- Qdrant/Neo4j explicitly marked as Out of Scope (OS-001, OS-002) in spec.md

### III. Branch Isolation by Default ✅

**Requirement**: Isolate reads to caller's branch scope by default; explicit widening allowed

**Compliance**: PASS
- FR-018: Default branch-isolated reads using `{org, project, branch}` scope
- FR-019: Explicit scope widening supported
- FR-020: Scope inference from git context
- Ranking applies scope proximity scoring (FR-021)

### IV. Immutable Content Integrity ✅

**Requirement**: ADR content (status=`accepted`), event_audit, approved specs immutable; idempotent writes

**Compliance**: PASS
- FR-036: ADR immutability enforced (trigger `t_adr_immutable` in DDL)
- FR-037: Approved spec write-lock (trigger `t_doc_approved_lock`)
- FR-038: `event_audit` table append-only (no updates/deletes)
- FR-033: Idempotent writes via `idempotency_key` or synthesized composite

### V. Extensibility Without API Breakage ✅

**Requirement**: Future extensions (Qdrant, Neo4j, ML reranking) integrate server-side without API changes

**Compliance**: PASS
- FR-022: `mode` parameter (`auto|fast|deep`) for routing strategy
- FR-029: `route_used` in response allows future semantic/graph routes
- Server-side routing (FR-023) can evolve internally without client changes
- Qdrant/Neo4j marked as future extensions (OS-001, OS-002)

### VI. Performance Discipline (Non-Negotiable SLOs) ✅

**Requirement**: P95 < 300ms (≤3M sections), Top-3 ≥80%, 100% audit coverage; CI/CD gates enforce

**Compliance**: PASS
- FR-049: P95 < 300ms target documented
- FR-050: P95 < 100ms for `mode="fast"`
- FR-051: Top-3 ≥80% relevance (sampled evaluation)
- FR-039: 100% mutation audit coverage
- Phase 8 includes k6 performance validation with evidence capture

### VII. Type Safety & Schema Validation ✅

**Requirement**: Zod/Pydantic validation; discriminated unions for 9 knowledge types; runtime + compile-time enforcement

**Compliance**: PASS
- Technical Context specifies Zod v3.22+ for TypeScript
- FR-007 to FR-016: 9 knowledge types with required fields
- Phase 4 generates Zod discriminated union schemas
- Contracts phase (Phase 1) outputs TypeScript types mirroring SOT JSON schemas

**GATE STATUS**: ✅ **ALL PRINCIPLES SATISFIED** - Proceed to Phase 0 Research

## Project Structure

### Documentation (this feature)

```
specs/001-create-specs-000/
├── plan.md              # This file (/speckit.plan output)
├── research.md          # Phase 0 output (technical decisions)
├── data-model.md        # Phase 1 output (11 tables, ERD, relationships)
├── quickstart.md        # Phase 1 output (setup, examples, troubleshooting)
├── contracts/           # Phase 1 output (MCP tool schemas, Zod types)
│   ├── mcp-tools.json   # memory.find + memory.store JSON schemas (SOT)
│   └── knowledge-types.ts # Zod discriminated union for 9 types
└── tasks.md             # Phase 2 output (/speckit.tasks - NOT created by this command)
```

### Source Code (repository root)

```
src/
├── index.ts             # MCP server entry point (STDIO transport)
├── tools/               # MCP tool handlers
│   ├── memory-find.ts   # memory.find implementation
│   └── memory-store.ts  # memory.store implementation
├── db/
│   ├── client.ts        # Postgres connection pool
│   ├── schema.ts        # Drizzle schema definitions (11 tables)
│   └── migrations/      # SQL migration files
├── services/
│   ├── chunker.ts       # Section chunking logic (1-3KB)
│   ├── deduplicator.ts  # Content hash deduplication
│   ├── ranker.ts        # Scoring formula implementation
│   ├── router.ts        # Query routing (auto/fast/deep)
│   └── suggester.ts     # Low-recall suggestion generation
├── validators/
│   └── knowledge-types.ts # Zod schemas for 9 types
└── utils/
    ├── logger.ts        # Pino structured logging
    └── scope.ts         # Scope inference + proximity scoring

tests/
├── unit/
│   ├── chunker.test.ts
│   ├── deduplicator.test.ts
│   ├── ranker.test.ts
│   └── validators.test.ts
├── integration/
│   ├── memory-store.test.ts
│   ├── memory-find.test.ts
│   ├── audit.test.ts
│   └── immutability.test.ts
└── e2e/
    ├── golden-scenarios.test.ts
    └── performance.test.ts

migrations/
├── 001_initial_schema.sql
├── 002_indexes.sql
└── 003_triggers.sql

.k6/
└── load-test.js         # k6 performance script
```

**Structure Decision**: Single project layout chosen because:
- MCP server is standalone STDIO process (no frontend/backend split)
- All functionality server-side (no client library needed)
- Testcontainers for E2E eliminates need for separate test infra

## Complexity Tracking

*No violations - all constitutional principles satisfied.*

---

## Phase 0: Foundation & Research

**Duration**: 2-3 hours

**Prerequisites**: Constitution Check ✅ PASS

**Deliverables**:
- Repository scaffolding (package.json, tsconfig.json, .gitignore)
- CI pipeline (GitHub Actions smoke test: lint + type-check)
- Test harness setup (Vitest config, Testcontainers setup)
- `research.md` documenting all technical decisions

**Tasks**:
1. Initialize TypeScript project with Node.js 20+ target
2. Install dependencies (MCP SDK, Zod, pg, pino, vitest, drizzle-kit)
3. Configure Vitest with Testcontainers for Postgres 18
4. Setup CI workflow (lint, type-check, unit tests)
5. Research and document:
   - Drizzle vs node-pg-migrate for migrations
   - Chunking strategy (heading-based vs size-based)
   - SHA-256 hashing for content_hash (crypto vs pgcrypto)
   - Scope inference from git context (env vars vs libgit2)
   - Ranking formula implementation (hardcoded vs configurable)
   - TTL cleanup strategy (cron vs pg_cron extension)

**Success Criteria**:
- `npm test` runs and passes (even with no tests yet)
- CI pipeline runs on push
- All research questions resolved in `research.md`

---

## Phase 1: Database Schema & Migrations

**Duration**: 3-4 hours

**Prerequisites**: Phase 0 complete, research.md finalized

**Deliverables**:
- `data-model.md` (11 tables, ERD diagram, relationships)
- SQL DDL migration files (001_initial_schema.sql, 002_indexes.sql, 003_triggers.sql)
- Drizzle schema definitions (if using Drizzle) OR migration scripts (if using node-pg-migrate)
- Seed data script (minimal examples for each knowledge type)
- Contracts (mcp-tools.json, knowledge-types.ts)
- `quickstart.md` (setup instructions, Docker Compose, example queries)

**Database Tables** (11 total):
1. **document**: Spec/doc/guide container with approval tracking
2. **section**: Documentation chunks with FTS vectors, content_hash for dedupe
3. **runbook**: Operational procedures with verification timestamps
4. **pr_context**: PR analysis cache with 30-day TTL
5. **ddl_history**: Schema evolution log
6. **release_note**: Deployment artifacts
7. **change_log**: Code/schema/config modifications with branch scope
8. **issue_log**: Bug/feature tracker sync
9. **adr_decision**: Architecture Decision Records (immutable once accepted)
10. **todo_log**: Cross-session task tracking
11. **event_audit**: Append-only mutation log

**Indexes**:
- GIN indexes: FTS vectors (`section.ts`), JSONB tags (all tables), pg_trgm (`section.body_text`)
- Scope indexes: Multi-column on `(project, service, branch, created_at DESC)`
- Unique constraints: `change_log(pr_id, commit_sha)`, `issue_log(tracker, external_id)`

**Triggers**:
- `touch_updated_at`: Auto-update timestamps on document/section/runbook
- `adr_immutable`: Prevent content changes to accepted ADRs
- `approved_lock`: Enforce write-lock on approved specs
- `audit_row`: Log all mutations to `event_audit`

**Success Criteria**:
- Migrations apply cleanly to Postgres 18
- All indexes created successfully
- Triggers fire correctly (unit tests verify)
- Seed data populates all 11 tables

---

## Phase 2: memory.store (Section Only)

**Duration**: 4-5 hours

**Prerequisites**: Phase 1 complete, database schema deployed

**Deliverables**:
- `memory.store` tool handler (section kind only)
- Idempotency logic (content_hash synthesis)
- Audit trail verification
- Integration tests (store → verify audit → check dedupe)

**Implementation**:
- Validate `kind="section"` with Zod schema
- Compute `content_hash` = SHA-256(normalized body_text)
- Check for existing section with same content_hash (dedupe)
- If duplicate: return `{status: "skipped_dedupe"}` (no audit entry)
- If new: INSERT section, generate FTS vector, create audit entry
- Return `{stored: [{id, status: "inserted"}]}`

**Success Criteria**:
- Store section with valid data → audit entry created
- Store duplicate section → `skipped_dedupe` returned, no audit entry
- Store with explicit `idempotency_key` → respect key for dedupe
- Invalid section data → structured error with `human_hint`

---

## Phase 3: memory.find (Section FTS)

**Duration**: 4-5 hours

**Prerequisites**: Phase 2 complete, sections storable

**Deliverables**:
- `memory.find` tool handler (FTS search only, no pg_trgm yet)
- Scope filtering + branch isolation default
- Snippet generation (context around match)
- Suggestion generation (low-recall heuristics)

**Implementation**:
- Apply branch isolation: default to `{org, project, branch}` from git context
- Build FTS query: `to_tsquery('english', query)`
- Filter by `types[]` if provided
- Filter by `time_range` if provided
- Rank by `ts_rank(ts, query)` (FTS score only, no recency/scope yet)
- Generate snippets: `ts_headline('english', body_text, query)`
- If <3 results: add suggestions ("Widen scope?", "Add service filter?")
- Return `{hits: [{kind, id, snippet, score}], suggestions, route_used: "fts"}`

**Success Criteria**:
- Search returns relevant sections within 300ms (small dataset)
- Branch isolation enforced: only current branch results returned
- Explicit scope widening works: cross-branch results when requested
- Suggestions appear when <3 results found

---

## Phase 4: All Knowledge Types

**Duration**: 6-8 hours

**Prerequisites**: Phase 3 complete, section store/find working

**Deliverables**:
- Zod schemas for all 9 knowledge types (discriminated union)
- `memory.store` handlers for: runbook, change, issue, decision, todo, release_note, ddl, pr_context
- Chunking logic for section/runbook (1-3KB chunks)
- Deduplication for change_log (content_hash)
- Integration tests for each type

**Knowledge Type Requirements**:
- **section**: Chunk by headings, fallback to size (1-3KB)
- **runbook**: Store steps as JSONB, set `last_verified_at`
- **change**: Synthesize content_hash from `subject_ref + summary`
- **issue**: Upsert by `(tracker, external_id)` unique constraint
- **decision**: Append-only, check immutability on update
- **todo**: Support 4 scope levels (user/project/service/branch)
- **release_note**: Tag + notes + risk metadata
- **ddl**: Store DDL SQL + breaking change checks
- **pr_context**: Set `expires_at` based on TTL policy (PR30d)

**Success Criteria**:
- All 9 types validate correctly with Zod
- Each type stores and retrieves successfully
- Deduplication works for section and change_log
- Chunking splits large sections at heading boundaries

---

## Phase 5: Governance (Immutability & Audit)

**Duration**: 3-4 hours

**Prerequisites**: Phase 4 complete, all types storable

**Deliverables**:
- ADR immutability enforcement (status=`accepted` content read-only)
- Approved spec write-lock enforcement
- Audit query endpoint (internal, not MCP tool)
- Integration tests for immutability violations

**Implementation**:
- Validate ADR updates: if `old.status='accepted'`, block content changes (title/rationale/alternatives)
- Validate document updates: if `old.approved_at IS NOT NULL`, block updates
- Verify audit completeness: query `event_audit` for coverage gaps
- Create amendment flow: accepted ADR → new ADR with `supersedes` link

**Success Criteria**:
- Attempt to modify accepted ADR → error with clear message
- Attempt to modify approved spec → error with write-lock message
- 100% of mutations logged to `event_audit` (verified by test)
- Audit log query returns complete history for entity

---

## Phase 6: Ranking & Deep Mode

**Duration**: 5-6 hours

**Prerequisites**: Phase 5 complete, governance enforced

**Deliverables**:
- Ranking formula implementation: `(0.4 × fts_score) + (0.3 × recency_boost) + (0.2 × scope_proximity) + (0.1 × citation_count)`
- Recency boost calculation (1.0 @ 7d → 0.1 @ 180d, logarithmic decay)
- Scope proximity scoring (1.0 exact branch, 0.5 same project, 0.2 cross-project)
- Citation count tracking (references between knowledge items)
- pg_trgm similarity search for `mode="deep"`
- Confidence score calculation
- `route_used` field population

**Implementation**:
- Compute recency: `1.0 - (log10(1 + days_since_update) / log10(180))`
- Compute scope proximity: match caller's `{org, project, branch}` against hit scope
- Compute citation count: query links in `change_log`, `issue_log`, `adr_decision`
- For `mode="deep"`: add pg_trgm similarity query: `SELECT *, similarity(body_text, query) AS sim_score FROM section WHERE body_text % query`
- Merge FTS + pg_trgm results, rerank by combined formula
- Set `confidence`: 0.9-1.0 (exact match), 0.7-0.9 (FTS high rank), 0.5-0.7 (pg_trgm fuzzy), <0.5 (low quality)

**Success Criteria**:
- Ranking formula produces correct scores (unit tests with mocked data)
- Recency boost decays correctly over time
- Scope proximity matches specification (1.0/0.5/0.2)
- `mode="deep"` queries use pg_trgm and return fuzzy matches
- `confidence` scores correlate with match quality

---

## Phase 7: E2E MCP Integration

**Duration**: 4-5 hours

**Prerequisites**: Phase 6 complete, ranking implemented

**Deliverables**:
- MCP server manifest (`package.json` MCP fields or separate manifest.json)
- STDIO transport wiring (stdin/stdout JSON-RPC)
- Schema conformance tests (validate against SOT JSON schemas)
- Golden path E2E tests:
  - **Feature find**: Query for spec/ADR, verify specs/examples ranked first
  - **Bugfix find**: Query with issue ID, verify issue + linked runbook returned
  - **Store dedupe**: Store duplicate section, verify `skipped_dedupe`
  - **Branch isolation**: Store in branch A, query from branch B, verify no results

**Implementation**:
- Implement STDIO transport: read JSON-RPC from stdin, write to stdout
- Handle `tools/list` request: return `[{name: "memory.find", ...}, {name: "memory.store", ...}]`
- Handle `tools/call` request: route to appropriate handler
- Validate request/response schemas against SOT JSON schemas (from gist)
- Run Testcontainers Postgres for E2E tests (real database, real MCP server)

**Success Criteria**:
- MCP server starts and responds to `tools/list` correctly
- `memory.store` request/response conforms to SOT schema
- `memory.find` request/response conforms to SOT schema
- All 4 golden path scenarios pass

---

## Phase 8: Performance & Polish

**Duration**: 6-8 hours

**Prerequisites**: Phase 7 complete, E2E tests passing

**Deliverables**:
- k6 load test script (P95 latency measurement)
- Performance evidence (100K-1M sections dataset)
- README.md (installation, usage, architecture)
- CHANGELOG.md (v1.0.0 release notes)
- CI performance gate (fail build if P95 > 300ms)

**Performance Testing**:
- Generate synthetic dataset: 100K sections, 10K changes, 5K issues, 1K ADRs
- Run k6 load test: 100 concurrent users, 1000 queries/sec
- Measure P95 latency for `mode="fast"` (target <100ms) and `mode="auto"` (target <300ms)
- Measure relevance: sample 200 queries, human/LLM evaluation for Top-3 relevance (target ≥80%)
- Verify audit completeness: 100% coverage, zero gaps

**Success Criteria**:
- P95 latency < 300ms on 1M sections (documented with k6 report)
- P95 latency < 100ms for `mode="fast"` on 1M sections
- Top-3 relevance ≥80% (sampled evaluation results attached)
- 100% audit coverage verified (query result attached)
- CI gate enforces P95 threshold (build fails if exceeded)

---

## Final Delivery Checklist

**Acceptance Criteria Verification** (all from spec.md):

- [ ] **AC1 (Latency)**: P95 < 300ms on ≤3M sections (k6 evidence)
- [ ] **AC2 (Branch Isolation)**: Reads default to caller's branch, widening explicit
- [ ] **AC3 (Audit + Immutability)**: 100% mutations audited, ADR/spec immutability enforced
- [ ] **AC4 (Schema Conformance)**: I/O matches SOT, errors include `human_hint`, dedupe returns `skipped_dedupe`
- [ ] **AC5 (Suggestions)**: Low-recall queries show suggestions, response includes `route_used` + `confidence`

**CI/CD Status**:

- [ ] All unit tests passing
- [ ] All integration tests passing
- [ ] All E2E tests passing
- [ ] Performance tests passing (P95 gates)
- [ ] Lint clean (no warnings)
- [ ] Type-check clean (strict mode)

**Documentation**:

- [ ] README.md complete (installation, usage, architecture)
- [ ] quickstart.md with working examples
- [ ] CHANGELOG.md for v1.0.0
- [ ] All 7 constitutional principles verified

**Deliverables**:

- [ ] Source code (`src/`, `tests/`)
- [ ] Database migrations (`migrations/`)
- [ ] Performance scripts (`.k6/`)
- [ ] Design artifacts (`specs/001-create-specs-000/`)

**GATE**: All items checked before v1.0.0 release.
