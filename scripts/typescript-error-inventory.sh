#!/bin/bash

# TypeScript Error Inventory Script (Bash Version)
#
# Comprehensive TypeScript error categorization and analysis for daily tracking.
# Generates detailed reports on error patterns, file hotspots, and trends.
#
# Usage: ./scripts/typescript-error-inventory.sh [options]
# Options:
#   --baseline    Set baseline error count
#   --trend       Show 7-day trend analysis
#   --export      Export results to JSON file
#   --help        Show this help message

set -euo pipefail

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
ARTIFACTS_DIR="$PROJECT_ROOT/artifacts"
BASELINE_FILE="$ARTIFACTS_DIR/ts-errors-baseline.txt"
HISTORY_FILE="$ARTIFACTS_DIR/ts-error-history.json"
REPORT_FILE="$ARTIFACTS_DIR/ts-error-inventory-$(date +%Y%m%d).txt"
JSON_REPORT_FILE="$ARTIFACTS_DIR/ts-error-inventory-$(date +%Y%m%d).json"

# Ensure artifacts directory exists
mkdir -p "$ARTIFACTS_DIR"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_header() {
    echo -e "${BLUE}$1${NC}"
}

print_success() {
    echo -e "${GREEN}$1${NC}"
}

print_warning() {
    echo -e "${YELLOW}$1${NC}"
}

print_error() {
    echo -e "${RED}$1${NC}"
}

# Function to show usage
show_help() {
    cat << EOF
TypeScript Error Inventory Script

USAGE:
    $0 [OPTIONS]

OPTIONS:
    --baseline    Set baseline error count
    --trend       Show 7-day trend analysis
    --export      Export results to JSON file
    --help        Show this help message

EXAMPLES:
    $0                           # Run standard inventory
    $0 --baseline                # Set new baseline
    $0 --trend                   # Show trend analysis
    $0 --export                  # Export to JSON

EOF
}

# Function to run TypeScript compilation and capture errors
run_typescript_check() {
    local tsc_output
    local error_count=0

    print_header "üîç Running TypeScript Compilation Check..."

    # Run TypeScript compilation
    if tsc_output=$(npx tsc --noEmit --pretty false 2>&1); then
        print_success "‚úÖ TypeScript compilation passed - no errors found"
        return 0
    else
        # Extract error count
        if [[ $tsc_output =~ Found\ ([0-9]+)\ errors? ]]; then
            error_count="${BASH_REMATCH[1]}"
        else
            # Fallback: count error lines
            error_count=$(echo "$tsc_output" | grep -c "error TS" || echo 0)
        fi

        print_warning "‚ö†Ô∏è  Found $error_count TypeScript errors"
        echo "$tsc_output"
        return 0
    fi
}

# Function to categorize errors by code
categorize_errors() {
    local tsc_output="$1"
    local temp_file=$(mktemp)

    print_header "üìä Categorizing Errors by Code..."

    # Extract error codes and count them
    echo "$tsc_output" | grep -o "error TS[0-9]*" | sort | uniq -c | sort -nr > "$temp_file"

    local total_errors=0
    while read -r count error_code; do
        total_errors=$((total_errors + count))
    done < "$temp_file"

    echo "Error Code Distribution (Total: $total_errors):"
    echo "======================================="
    cat "$temp_file"
    echo ""

    # Clean up
    rm -f "$temp_file"
}

# Function to analyze errors by file
analyze_by_file() {
    local tsc_output="$1"
    local temp_file=$(mktemp)

    print_header "üìÅ Analyzing Errors by File..."

    # Extract file paths and count errors
    echo "$tsc_output" | grep -o "^[^(:]*" | sort | uniq -c | sort -nr | head -20 > "$temp_file"

    echo "Top 20 Files with Most Errors:"
    echo "==============================="
    cat "$temp_file"
    echo ""

    # Clean up
    rm -f "$temp_file"
}

# Function to generate detailed error report
generate_detailed_report() {
    local tsc_output="$1"
    local temp_file=$(mktemp)

    print_header "üìã Generating Detailed Error Report..."

    # Create detailed breakdown
    cat > "$temp_file" << EOF
TypeScript Error Inventory Report
==================================
Date: $(date)
Project: $(basename "$PROJECT_ROOT")

Error Summary:
---------------
$(categorize_errors "$tsc_output")

File Analysis:
---------------
$(analyze_by_file "$tsc_output")

Error Details:
--------------
$(echo "$tsc_output" | head -100)

Generated by: $(basename "$0")
EOF

    # Save report
    cp "$temp_file" "$REPORT_FILE"
    cat "$temp_file"

    print_success "üìÑ Detailed report saved to: $REPORT_FILE"

    # Clean up
    rm -f "$temp_file"
}

# Function to export to JSON
export_to_json() {
    local tsc_output="$1"
    local temp_file=$(mktemp)

    print_header "üíæ Exporting to JSON..."

    # Extract error count
    local error_count=0
    if [[ $tsc_output =~ Found\ ([0-9]+)\ errors? ]]; then
        error_count="${BASH_REMATCH[1]}"
    else
        error_count=$(echo "$tsc_output" | grep -c "error TS" || echo 0)
    fi

    # Generate JSON report
    cat > "$JSON_REPORT_FILE" << EOF
{
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%S.000Z)",
  "errorCount": $error_count,
  "errorCodes": [
EOF

    # Add error codes
    local first=true
    echo "$tsc_output" | grep -o "error TS[0-9]*" | sort | uniq -c | sort -nr | while read -r count error_code; do
        if [ "$first" = true ]; then
            first=false
        else
            echo ","
        fi
        echo "    { \"code\": \"$error_code\", \"count\": $count }"
    done >> "$JSON_REPORT_FILE"

    cat >> "$JSON_REPORT_FILE" << EOF
  ],
  "files": [
EOF

    # Add file analysis
    first=true
    echo "$tsc_output" | grep -o "^[^(:]*" | sort | uniq -c | sort -nr | head -20 | while read -r count file; do
        if [ "$first" = true ]; then
            first=false
        else
            echo ","
        fi
        echo "    { \"file\": \"$file\", \"errors\": $count }"
    done >> "$JSON_REPORT_FILE"

    cat >> "$JSON_REPORT_FILE" << EOF
  ],
  "baseline": $(if [ -f "$BASELINE_FILE" ]; then grep -o "Total: [0-9]*" "$BASELINE_FILE" | cut -d: -f2 | tr -d ' ' || echo "null"; else echo "null"; fi)
}
EOF

    print_success "üìÑ JSON report saved to: $JSON_REPORT_FILE"

    # Clean up
    rm -f "$temp_file"
}

# Function to set baseline
set_baseline() {
    print_header "üìù Setting TypeScript Error Baseline..."

    local tsc_output
    local error_count=0

    # Run TypeScript check
    if tsc_output=$(npx tsc --noEmit --pretty false 2>&1); then
        error_count=0
    else
        if [[ $tsc_output =~ Found\ ([0-9]+)\ errors? ]]; then
            error_count="${BASH_REMATCH[1]}"
        else
            error_count=$(echo "$tsc_output" | grep -c "error TS" || echo 0)
        fi
    fi

    # Save baseline
    cat > "$BASELINE_FILE" << EOF
TypeScript Error Baseline
Generated: $(date)
Total: $error_count
EOF

    print_success "‚úÖ Baseline set to $error_count errors"
    print_success "üìÑ Baseline saved to: $BASELINE_FILE"
}

# Function to show trend analysis
show_trend() {
    print_header "üìà 7-Day Error Trend Analysis..."

    if [ ! -f "$HISTORY_FILE" ]; then
        print_warning "‚ö†Ô∏è  No history file found. Run script without --trend to start tracking."
        return 1
    fi

    echo "Recent Error History:"
    echo "===================="

    # Get last 7 days of data
    local seven_days_ago=$(date -d '7 days ago' +%Y-%m-%d)

    if command -v jq >/dev/null 2>&1; then
        jq --arg date "$seven_days_ago" '
            .history[] |
            select(.timestamp >= $date) |
            "\(.timestamp): \(.errorCount) errors"
        ' "$HISTORY_FILE"
    else
        print_warning "‚ö†Ô∏è  jq not found. Install jq for better trend analysis."
        grep -E "202[0-9]-[0-9]{2}-[0-9]{2}" "$HISTORY_FILE" | tail -7
    fi
}

# Function to update history
update_history() {
    local error_count="$1"
    local today=$(date +%Y-%m-%d)

    # Create history file if it doesn't exist
    if [ ! -f "$HISTORY_FILE" ]; then
        cat > "$HISTORY_FILE" << EOF
{
  "history": []
}
EOF
    fi

    # Update history (requires jq)
    if command -v jq >/dev/null 2>&1; then
        temp_file=$(mktemp)
        jq --arg date "$today" --arg count "$error_count" '
            .history += [{timestamp: $date, errorCount: ($count | tonumber)}]
        ' "$HISTORY_FILE" > "$temp_file"
        mv "$temp_file" "$HISTORY_FILE"
    fi
}

# Main execution
main() {
    cd "$PROJECT_ROOT"

    case "${1:-}" in
        --help|-h)
            show_help
            exit 0
            ;;
        --baseline)
            set_baseline
            exit 0
            ;;
        --trend)
            show_trend
            exit 0
            ;;
        *)
            # Run standard inventory
            local tsc_output
            local error_count=0

            # Capture TypeScript output
            if ! tsc_output=$(npx tsc --noEmit --pretty false 2>&1); then
                # Extract error count
                if [[ $tsc_output =~ Found\ ([0-9]+)\ errors? ]]; then
                    error_count="${BASH_REMATCH[1]}"
                else
                    error_count=$(echo "$tsc_output" | grep -c "error TS" || echo 0)
                fi
            fi

            # Generate reports
            generate_detailed_report "$tsc_output"

            # Export to JSON if requested
            if [ "${1:-}" = "--export" ]; then
                export_to_json "$tsc_output"
            fi

            # Update history
            update_history "$error_count"

            # Show comparison with baseline
            if [ -f "$BASELINE_FILE" ]; then
                local baseline=$(grep -o "Total: [0-9]*" "$BASELINE_FILE" | cut -d: -f2 | tr -d ' ' || echo "0")
                local delta=$((error_count - baseline))

                echo ""
                print_header "üìä Baseline Comparison:"
                echo "Current:   $error_count errors"
                echo "Baseline:  $baseline errors"
                echo "Delta:     $((delta > 0 ? "+" : ""))$delta"

                if [ $delta -gt 0 ]; then
                    print_error "‚ùå Error count increased by $delta"
                elif [ $delta -lt 0 ]; then
                    print_success "‚úÖ Error count decreased by $((-delta))"
                else
                    print_success "‚úÖ Error count unchanged"
                fi
            fi

            exit 0
            ;;
    esac
}

# Execute main function
main "$@"