/**
 * Enhanced Service Layer Router with Constructor Injection
 *
 * Refactored to use dependency injection with constructor injection.
 * Maintains all existing functionality while improving testability and modularity.
 *
 * @author Cortex Team
 * @version 3.0.0
 * @since 2025
 */

import type { SearchQuery } from '../../types/core-interfaces.js';
import { Injectable } from '../decorators.js';
import { ServiceLifetime, ServicePriority } from '../enhanced-di-container.js';
import type { ILoggerService } from '../service-interfaces.js';
import type { IMemoryStoreOrchestrator } from '../service-interfaces.js';
import type { IMemoryFindOrchestrator } from '../service-interfaces.js';
import type { IValidationService } from '../service-interfaces.js';
import type { IEventService } from '../service-interfaces.js';
import type { IPerformanceMonitor } from '../service-interfaces.js';

/**
 * Enhanced service request context
 */
export interface EnhancedServiceRequestContext {
  id: string;
  service: string;
  operation: string;
  parameters: Record<string, unknown>;
  user?: {
    id: string;
    roles: string[];
    permissions: string[];
  };
  metadata?: Record<string, unknown>;
  timestamp: Date;
  scope?: string;
}

/**
 * Enhanced service response
 */
export interface EnhancedServiceResponse {
  success: boolean;
  data?: unknown;
  error?: {
    code: string;
    message: string;
    details?: unknown;
  };
  metadata?: {
    executionTime: number;
    service: string;
    operation: string;
    requestId: string;
    cached?: boolean;
    retryCount?: number;
  };
}

/**
 * Service operation definition
 */
export interface EnhancedServiceOperation {
  name: string;
  handler: (context: EnhancedServiceRequestContext) => Promise<EnhancedServiceResponse>;
  requiredPermissions?: string[];
  rateLimit?: {
    requests: number;
    window: number;
  };
  timeout?: number;
  cacheable?: boolean;
  cacheTTL?: number;
  retryable?: boolean;
  maxRetries?: number;
}

/**
 * Service definition
 */
export interface EnhancedServiceDefinition {
  name: string;
  version: string;
  operations: EnhancedServiceOperation[];
  dependencies?: string[];
  accessLevel: 'public' | 'internal' | 'restricted';
  healthCheck?: () => Promise<boolean>;
}

/**
 * Enhanced Service Layer Router with dependency injection
 */
@Injectable({
  lifetime: ServiceLifetime.SINGLETON,
  priority: ServicePriority.CRITICAL,
  tags: ['routing', 'service-layer', 'critical'],
})
export class EnhancedServiceLayerRouter {
  private services = new Map<string, EnhancedServiceDefinition>();
  private isInitialized = false;
  private requestCounter = 0;

  constructor(
    private logger: ILoggerService, 
    private memoryStoreService: IMemoryStoreOrchestrator, 
    private memoryFindService: IMemoryFindOrchestrator, 
    private validationService: IValidationService, 
    private eventService: IEventService, 
    private performanceMonitor: IPerformanceMonitor
  ) {}

  /**
   * Initialize the service layer router
   */
  async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    try {
      await this.logger.info('Initializing Enhanced Service Layer Router...');

      // Register core services
      await this.registerCoreServices();

      // Setup event handlers
      this.setupEventHandlers();

      this.isInitialized = true;
      await this.logger.info('Enhanced Service Layer Router initialized successfully');
    } catch (error) {
      await this.logger.error('Failed to initialize Enhanced Service Layer Router:', error);
      throw error;
    }
  }

  /**
   * Route request through service layer
   */
  async route(context: EnhancedServiceRequestContext): Promise<EnhancedServiceResponse> {
    if (!this.isInitialized) {
      throw new Error('Enhanced Service Layer Router not initialized');
    }

    const startTime = Date.now();
    const requestId = this.generateRequestId();

    try {
      await this.logger.debug(`Routing request: ${context.service}.${context.operation}`, {
        requestId,
        user: context.user?.id,
      });

      // Validate service and operation
      const service = this.getService(context.service);
      if (!service) {
        throw new Error(`Service not found: ${context.service}`);
      }

      const operation = service.operations.find((op) => op.name === context.operation);
      if (!operation) {
        throw new Error(`Operation not found: ${context.operation} in service: ${context.service}`);
      }

      // Validate request parameters
      if (this.validationService) {
        try {
          await this.validationService.validate(
            context.parameters,
            `${context.service}.${context.operation}`
          );
        } catch (_validationError) {
          return {
            success: false,
            error: {
              code: 'VALIDATION_ERROR',
              message:
                validationError instanceof Error ? validationError.message : 'Validation failed',
            },
            metadata: {
              executionTime: Date.now() - startTime,
              service: context.service,
              operation: context.operation,
              requestId,
            },
          };
        }
      }

      // Check rate limits (simplified implementation)
      if (operation.rateLimit) {
        // Rate limiting logic would go here
      }

      // Execute operation with timeout and retry logic
      const result = await this.executeOperationWithRetry(context, operation, requestId);

      // Record performance metrics
      const executionTime = Date.now() - startTime;
      if (this.performanceMonitor) {
        this.performanceMonitor.recordServiceCall(
          context.service,
          context.operation,
          executionTime,
          result.success
        );
      }

      // Emit event for successful routing
      if (this.eventService) {
        this.eventService.emit('service:routed', {
          service: context.service,
          operation: context.operation,
          requestId,
          success: result.success,
          executionTime,
        });
      }

      return {
        ...result,
        metadata: {
          ...result.metadata,
          executionTime,
          service: context.service,
          operation: context.operation,
          requestId,
        },
      };
    } catch (error) {
      const executionTime = Date.now() - startTime;

      await this.logger.error('Service routing failed:', error, {
        service: context.service,
        operation: context.operation,
        requestId,
      });

      // Record error metrics
      if (this.performanceMonitor) {
        this.performanceMonitor.recordServiceCall(
          context.service,
          context.operation,
          executionTime,
          false
        );
      }

      // Emit error event
      if (this.eventService) {
        this.eventService.emit('service:routing-error', {
          service: context.service,
          operation: context.operation,
          requestId,
          error: error instanceof Error ? error.message : 'Unknown error',
        });
      }

      return {
        success: false,
        error: {
          code: 'SERVICE_ROUTING_ERROR',
          message: error instanceof Error ? error.message : 'Unknown error',
        },
        metadata: {
          executionTime,
          service: context.service,
          operation: context.operation,
          requestId,
        },
      };
    }
  }

  /**
   * Register a new service
   */
  async registerService(serviceDefinition: EnhancedServiceDefinition): Promise<void> {
    try {
      this.validateServiceDefinition(serviceDefinition);
      this.services.set(serviceDefinition.name, serviceDefinition);

      await this.logger.info(
        `Service registered: ${serviceDefinition.name} v${serviceDefinition.version}`
      );

      // Emit service registration event
      if (this.eventService) {
        this.eventService.emit('service:registered', {
          service: serviceDefinition.name,
          version: serviceDefinition.version,
        });
      }
    } catch (error) {
      await this.logger.error(`Failed to register service: ${serviceDefinition.name}`, error);
      throw error;
    }
  }

  /**
   * Get service definition
   */
  getService(serviceName: string): EnhancedServiceDefinition | null {
    return this.services.get(serviceName) || null;
  }

  /**
   * List all registered services
   */
  listServices(): EnhancedServiceDefinition[] {
    return Array.from(this.services.values());
  }

  /**
   * Get router health status
   */
  getHealthStatus(): Promise<{
    status: 'healthy' | 'degraded' | 'unhealthy';
    services: {
      total: number;
      healthy: number;
      degraded: number;
      unhealthy: number;
    };
    performance: {
      averageResponseTime: number;
      requestsPerSecond: number;
      errorRate: number;
    };
  }> {
    const services = this.listServices();
    let healthyCount = 0;
    const degradedCount = 0;
    let unhealthyCount = 0;

    // Check health of each service
    for (const service of services) {
      if (service.healthCheck) {
        try {
          const isHealthy = await service.healthCheck();
          if (_isHealthy) {
            healthyCount++;
          } else {
            unhealthyCount++;
          }
        } catch (error) {
          unhealthyCount++;
        }
      } else {
        healthyCount++; // Assume healthy if no health check
      }
    }

    // Get performance metrics
    const performanceMetrics = this.performanceMonitor?.getAverageMetrics() || {
      averageResponseTime: 0,
      requestsPerSecond: 0,
      errorRate: 0,
    };

    const errorRate = performanceMetrics.errorRate || 0;
    const avgResponseTime = performanceMetrics.averageResponseTime || 0;

    let status: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';
    if (errorRate > 0.1 || avgResponseTime > 5000 || unhealthyCount > 0) {
      status = 'unhealthy';
    } else if (errorRate > 0.05 || avgResponseTime > 2000 || degradedCount > 0) {
      status = 'degraded';
    }

    return {
      status,
      services: {
        total: services.length,
        healthy: healthyCount,
        degraded: degradedCount,
        unhealthy: unhealthyCount,
      },
      performance: performanceMetrics,
    };
  }

  /**
   * Shutdown the router
   */
  async shutdown(): Promise<void> {
    try {
      await this.logger.info('Shutting down Enhanced Service Layer Router...');

      this.services.clear();
      this.isInitialized = false;

      await this.logger.info('Enhanced Service Layer Router shutdown completed');
    } catch (error) {
      await this.logger.error('Error during Enhanced Service Layer Router shutdown:', error);
      throw error;
    }
  }

  // Private methods

  private async registerCoreServices(): Promise<void> {
    // Register memory store service
    await this.registerService({
      name: 'memory-store', 
      _version: '3.0.0', 
      _accessLevel: 'public', 
      operations: [
        {
          name: 'store', 
          _handler: async (context) => {
            try {
              // Convert context to proper format for memory store service
              const items = Array.isArray(context.parameters.items)
                ? context.parameters.items
                : [context.parameters];
              const result = await this.memoryStoreService.store(items);

              return {
                success: true,
                data: result,
                metadata: {
                  executionTime: 0, // Will be set by router
                  service: 'memory-store',
                  operation: 'store',
                  requestId: '', // Will be set by router
                },
              };
            } catch (error) {
              return {
                success: false,
                error: {
                  code: 'STORE_ERROR',
                  message: error instanceof Error ? error.message : 'Unknown error',
                },
                metadata: {
                  executionTime: 0, // Will be set by router
                  service: 'memory-store',
                  operation: 'store',
                  requestId: '', // Will be set by router
                },
              };
            }
          },
          requiredPermissions: ['memory:write'],
          timeout: 30000,
          cacheable: false,
          retryable: true,
          maxRetries: 3,
        },
        {
          name: 'bulkStore',
          handler: async (_context) => {
            try {
              // Convert context to proper format for memory store service
              const items = Array.isArray(context.parameters.items)
                ? context.parameters.items
                : [context.parameters];
              const result = await this.memoryStoreService.upsert(items);

              return {
                success: true,
                data: result,
                metadata: {
                  executionTime: 0, // Will be set by router
                  service: 'memory-store',
                  operation: 'bulkStore',
                  requestId: '', // Will be set by router
                },
              };
            } catch (error) {
              return {
                success: false,
                error: {
                  code: 'BULK_STORE_ERROR',
                  message: error instanceof Error ? error.message : 'Unknown error',
                },
                metadata: {
                  executionTime: 0, // Will be set by router
                  service: 'memory-store',
                  operation: 'bulkStore',
                  requestId: '', // Will be set by router
                },
              };
            }
          },
          requiredPermissions: ['memory:write'],
          timeout: 60000,
          cacheable: false,
          retryable: true,
          maxRetries: 2,
        },
      ],
      healthCheck: async () => {
        try {
          // Basic health check for memory store service
          return await this.memoryStoreService.isHealthy();
        } catch {
          return false;
        }
      },
    });

    // Register memory find service
    await this.registerService({
      name: 'memory-find', 
      _version: '3.0.0', 
      _accessLevel: 'public', 
      operations: [
        {
          name: 'find', 
          _handler: async (context) => {
            try {
              // Convert context to proper format for memory find service
              const query: SearchQuery = {
                query: context.parameters.query || '',
                scope: context.parameters.scope,
                types: context.parameters.type ? [context.parameters.type] : undefined,
                filters: context.parameters.filters || {},
              };
              const result = await this.memoryFindService.find(query);

              return {
                success: true,
                data: result,
                metadata: {
                  executionTime: 0, // Will be set by router
                  service: 'memory-find',
                  operation: 'find',
                  requestId: '', // Will be set by router
                },
              };
            } catch (error) {
              return {
                success: false,
                error: {
                  code: 'FIND_ERROR',
                  message: error instanceof Error ? error.message : 'Unknown error',
                },
                metadata: {
                  executionTime: 0, // Will be set by router
                  service: 'memory-find',
                  operation: 'find',
                  requestId: '', // Will be set by router
                },
              };
            }
          },
          requiredPermissions: ['memory:read'],
          timeout: 10000,
          cacheable: true,
          cacheTTL: 300,
          retryable: true,
          maxRetries: 2,
        },
        {
          name: 'search',
          handler: async (_context) => {
            try {
              // Convert context to proper format for memory find service
              const filters = context.parameters.filters || {};
              const result = await this.memoryFindService.search(filters);

              return {
                success: true,
                data: result,
                metadata: {
                  executionTime: 0, // Will be set by router
                  service: 'memory-find',
                  operation: 'search',
                  requestId: '', // Will be set by router
                },
              };
            } catch (error) {
              return {
                success: false,
                error: {
                  code: 'SEARCH_ERROR',
                  message: error instanceof Error ? error.message : 'Unknown error',
                },
                metadata: {
                  executionTime: 0, // Will be set by router
                  service: 'memory-find',
                  operation: 'search',
                  requestId: '', // Will be set by router
                },
              };
            }
          },
          requiredPermissions: ['memory:read'],
          timeout: 15000,
          cacheable: true,
          cacheTTL: 600,
          retryable: true,
          maxRetries: 2,
        },
      ],
      healthCheck: async () => {
        try {
          return await this.memoryFindService.isHealthy();
        } catch {
          return false;
        }
      },
    });
  }

  private setupEventHandlers(): void {
    if (!this.eventService) return;

    // Handle service registration events
    this.eventService.on('service:registered',  (event) => {
      this.logger.debug(`Service registered event:`, event);
    });

    // Handle service routing events
    this.eventService.on('service:routed',  (event) => {
      this.logger.debug(`Service routed event:`, event);
    });

    // Handle routing errors
    this.eventService.on('service:routing-error',  (event) => {
      this.logger.warn(`Service routing error event:`, event);
    });
  }

  private async executeOperationWithRetry(
    context: EnhancedServiceRequestContext,
    operation: EnhancedServiceOperation,
    requestId: string
  ): Promise<EnhancedServiceResponse> {
    const maxRetries = operation.maxRetries || (operation.retryable ? 3 : 0);
    let lastError: Error | null = null;

    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        if (attempt > 0) {
          await this.logger.debug(
            `Retrying operation: ${context.operation} (attempt ${String(attempt + 1)})`,
            {
              requestId,
            }
          );

          // Exponential backoff
          const delay = Math.min(1000 * Math.pow(2, attempt - 1), 5000);
          await new Promise((resolve) => setTimeout(resolve, delay));
        }

        return await this.executeOperation(context, operation);
      } catch (error) {
        lastError = error instanceof Error ? error : new Error('Unknown error');

        if (attempt === maxRetries) {
          break;
        }

        await this.logger.warn(`Operation failed, retrying:`, lastError, {
          operation: context.operation,
          attempt: attempt + 1,
          maxRetries: maxRetries + 1,
          requestId,
        });
      }
    }

    throw lastError;
  }

  private async executeOperation(
    context: EnhancedServiceRequestContext,
    operation: EnhancedServiceOperation
  ): Promise<EnhancedServiceResponse> {
    if (operation.timeout) {
      return await this.withTimeout(operation.handler(context), operation.timeout);
    }

    return await operation.handler(context);
  }

  private withTimeout<T>(promise: Promise<T>, timeoutMs: number): Promise<T> {
    return Promise.race([
      promise, 
      new Promise<T>((_,  _reject) => {
        setTimeout(() => { reject(new Error(`Operation timeout after ${timeoutMs}ms`)); }, timeoutMs);
      }),
    ]);
  }

  private validateServiceDefinition(_service: EnhancedServiceDefinition): void {
    if (!service.name || !service.version) {
      throw new Error('Service name and version are required');
    }

    if (!service.operations || service.operations.length === 0) {
      throw new Error('Service must have at least one operation');
    }

    for (const operation of service.operations) {
      if (!operation.name || !operation.handler) {
        throw new Error('Operation must have name and handler');
      }
    }
  }

  private generateRequestId(): string {
    return `req_${Date.now()}_${++this.requestCounter}_${String(Math.random().toString(36).substr(2, 9))}`;
  }
}
