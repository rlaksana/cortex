/**
 * DI Container Initializer
 *
 * Integrates the enhanced DI system with existing environment management
 * and application bootstrap. Provides smooth migration path.
 *
 * @author Cortex Team
 * @version 3.0.0
 * @since 2025
 */

import { autoEnvironment } from '../../config/auto-environment.js';
import { logger } from '../../utils/logger.js';
import { EnhancedDIContainer } from '../enhanced-di-container.js';
import type { ContainerConfig } from '../enhanced-di-container.js';
import { createModuleLoader } from '../module-loader.js';

type Environment = 'development' | 'production' | 'test';

function isEnvironment(_env: unknown): env is Environment {
  return typeof env === 'string' && ['development', 'production', 'test'].includes(env);
}

/**
 * DI initialization configuration
 */
export interface DIInitializationConfig {
  containerConfig?: ContainerConfig;
  enableAutoRegistration?: boolean;
  environment?: 'development' | 'production' | 'test';
  modules?: string[];
  excludeModules?: string[];
  fallbackToExisting?: boolean;
  warnings?: string[];
}

/**
 * Initialization result
 */
export interface DIInitializationResult {
  success: boolean;
  container: EnhancedDIContainer;
  moduleResults: unknown;
  warnings: string[];
  errors: string[];
  bootstrapTime: number;
}

/**
 * DI Container Initializer
 */
export class DIInitializer {
  private config: DIInitializationConfig;
  private container?: EnhancedDIContainer;

  constructor(config: DIInitializationConfig = {}) {
    this.config = {
      enableAutoRegistration: true,
      environment: isEnvironment(process.env.NODE_ENV) ? process.env.NODE_ENV : 'development',
      modules: [],
      excludeModules: [],
      fallbackToExisting: true,
      ...config,
    };
  }

  /**
   * Initialize the DI system
   */
  async initialize(): Promise<DIInitializationResult> {
    const startTime = Date.now();

    const result: DIInitializationResult = {
      success: false,
      container: null as EnhancedDIContainer | null,
      moduleResults: null,
      warnings: [],
      errors: [],
      bootstrapTime: 0,
    };

    try {
      await logger.info('Initializing Enhanced DI System...');

      // Validate environment first
      await this.validateEnvironment();

      // Create container
      this.container = this.createContainer();

      // Load modules
      const moduleResults = await this.loadModules(result);
      result.moduleResults = moduleResults;

      // Validate dependencies
      await this.validateDependencies(result);

      // Setup integration with existing services
      await this.setupExistingIntegration(result);

      result.success = true;
      result.container = this.container;
      result.bootstrapTime = Date.now() - startTime;

      await logger.info(`Enhanced DI System initialized successfully in ${result.bootstrapTime}ms`);

      if (result.warnings.length > 0) {
        await logger.warn('DI initialization warnings:', result.warnings);
      }

      return result;
    } catch (error) {
      result.success = false;
      result.errors.push(error instanceof Error ? error.message : 'Unknown error');
      result.bootstrapTime = Date.now() - startTime;

      await logger.error('DI initialization failed:', error);

      // Fallback to existing system if configured
      if (this.config.fallbackToExisting) {
        await this.fallbackToExisting(result);
      }

      return result;
    }
  }

  /**
   * Get the initialized container
   */
  getContainer(): EnhancedDIContainer {
    if (!this.container) {
      throw new Error('DI system not initialized. Call initialize() first.');
    }
    return this.container;
  }

  /**
   * Check if DI system is initialized
   */
  isInitialized(): boolean {
    return this.container !== undefined;
  }

  /**
   * Shutdown the DI system
   */
  async shutdown(): Promise<void> {
    if (this.container) {
      try {
        await logger.info('Shutting down Enhanced DI System...');
        await this.container.dispose();
        this.container = undefined;
        await logger.info('Enhanced DI System shutdown completed');
      } catch (error) {
        await logger.error('Error during DI system shutdown:', error);
        throw error;
      }
    }
  }

  // Private methods

  private async validateEnvironment(): Promise<void> {
    const envStatus = autoEnvironment.getConfigurationStatus();

    if (!envStatus.isConfigured) {
      const warnings = ['Environment configuration incomplete', ...envStatus.errors];
      this.config.warnings = this.config.warnings || [];
      this.config.warnings.push(...warnings);
    }

    // Validate DI-specific environment variables
    const diConfig = {
      DI_ENABLE_AUTO_REGISTRATION: process.env.DI_ENABLE_AUTO_REGISTRATION,
      DI_STRICT_MODE: process.env.DI_STRICT_MODE,
      DI_ENABLE_PERFORMANCE_MONITORING: process.env.DI_ENABLE_PERFORMANCE_MONITORING,
      DI_MODULE_PATHS: process.env.DI_MODULE_PATHS,
    };

    for (const [key, value] of Object.entries(diConfig)) {
      if (value !== undefined) {
        await logger.debug(`DI Environment: ${key} = ${value}`);
      }
    }
  }

  private createContainer(): EnhancedDIContainer {
    const containerConfig: ContainerConfig = {
      enableAutoRegistration: this.parseBool(process.env.DI_ENABLE_AUTO_REGISTRATION, true),
      enablePerformanceMonitoring: this.parseBool(
        process.env.DI_ENABLE_PERFORMANCE_MONITORING,
        true
      ),
      enableHealthChecks: true,
      strictMode: this.parseBool(process.env.DI_STRICT_MODE, false),
      circularDependencyResolution: 'error',
      ...this.config.containerConfig,
    };

    return new EnhancedDIContainer(containerConfig);
  }

  private async loadModules(result: DIInitializationResult): Promise<unknown> {
    const moduleLoaderConfig = {
      enableAutoDiscovery: this.config.enableAutoRegistration,
      environment: this.config.environment,
      excludeModules: this.config.excludeModules,
      includeModules: this.config.modules,
      modulePaths: process.env.DI_MODULE_PATHS?.split(',') || ['./src/di/modules'],
    };

    const moduleLoader = createModuleLoader(this.container!, moduleLoaderConfig);
    const moduleResults = await moduleLoader.loadModules();

    // Collect warnings and errors
    if (moduleResults.failed.length > 0) {
      result.errors.push(...moduleResults.failed.map((f) => `${f.module}: ${f.error}`));
    }

    if (moduleResults.skipped.length > 0) {
      result.warnings.push(...moduleResults.skipped.map((s) => `Module skipped: ${s}`));
    }

    return moduleResults;
  }

  private async validateDependencies(result: DIInitializationResult): Promise<void> {
    if (!this.container) return;

    const validation = this.validateContainerDependencies(this.container);

    if (!validation.valid) {
      result.errors.push(...validation.issues);
    }

    // Check for critical services
    const criticalServices = ['CONFIG_SERVICE', 'LOGGER_SERVICE', 'SERVICE_LAYER_ROUTER'];

    for (const service of criticalServices) {
      if (!this.container.isRegistered(service)) {
        result.warnings.push(`Critical service not registered: ${service}`);
      }
    }
  }

  private validateContainerDependencies(_container: EnhancedDIContainer): {
    valid: boolean;
    issues: string[];
  } {
    const issues: string[] = [];
    const registeredServices = Array.from(container.getAllServices().keys());

    // Check for circular dependencies (simplified check)
    // In a real implementation, this would build a dependency graph

    return {
      valid: issues.length === 0,
      issues,
    };
  }

  private async setupExistingIntegration(result: DIInitializationResult): Promise<void> {
    if (!this.container) return;

    try {
      // Register existing singletons with the new container
      await this.registerExistingSingletons();

      // Setup event listeners for integration
      this.setupIntegrationEventListeners();

      // Register fallback resolvers for existing code
      this.setupFallbackResolvers();
    } catch (error) {
      result.warnings.push(
        `Integration setup issue: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
  }

  private async registerExistingSingletons(): Promise<void> {
    // This would register existing singleton instances with the new container
    // For now, it's a placeholder for the integration logic

    // Example: Register existing logger if available
    try {
      // Check if existing services are available and register them
      await logger.debug('Registering existing singletons with DI container');
    } catch (error) {
      await logger.warn('Failed to register existing singletons:', error);
    }
  }

  private setupIntegrationEventListeners(): void {
    if (!this.container) return;

    // Listen to container events for integration
    this.container.on('service:resolved',  (event) => {
      logger.debug(`Service resolved via DI: ${String(event.token)}`);
    });

    this.container.on('service:resolution-error',  (event) => {
      logger.warn(`Service resolution error: ${String(event.token)} - ${event.error}`);
    });
  }

  private setupFallbackResolvers(): void {
    // Setup fallback resolvers for existing code that doesn't use DI yet
    // This allows gradual migration
  }

  private async fallbackToExisting(result: DIInitializationResult): Promise<void> {
    result.warnings.push('Falling back to existing service initialization');

    try {
      // Initialize existing services as fallback
      await logger.info('Initializing fallback services...');
      // This would call existing initialization methods
    } catch (_fallbackError) {
      result.errors.push(
        `Fallback initialization failed: ${fallbackError instanceof Error ? fallbackError.message : 'Unknown error'}`
      );
    }
  }

  private parseBool(_value: string | undefined,  _defaultValue: boolean): boolean {
    if (value === undefined) return defaultValue;
    return value.toLowerCase() === 'true' || value === '1';
  }
}

/**
 * Global DI initializer instance
 */
let globalDIInitializer: DIInitializer | null = null;

/**
 * Initialize the global DI system
 */
export async function initializeDI(
  config?: DIInitializationConfig
): Promise<DIInitializationResult> {
  if (_globalDIInitializer) {
    throw new Error('DI system already initialized');
  }

  globalDIInitializer = new DIInitializer(config);
  return await globalDIInitializer.initialize();
}

/**
 * Get the global DI container
 */
export function getDIContainer(): EnhancedDIContainer {
  if (!globalDIInitializer) {
    throw new Error('DI system not initialized. Call initializeDI() first.');
  }
  return globalDIInitializer.getContainer();
}

/**
 * Check if DI system is initialized
 */
export function isDIInitialized(): boolean {
  return globalDIInitializer?.isInitialized() || false;
}

/**
 * Shutdown the global DI system
 */
export async function shutdownDI(): Promise<void> {
  if (_globalDIInitializer) {
    await globalDIInitializer.shutdown();
    globalDIInitializer = null;
  }
}

/**
 * Get or create DI container (for backward compatibility)
 */
export function getOrCreateDIContainer(
  config?: DIInitializationConfig
): Promise<EnhancedDIContainer> {
  if (isDIInitialized()) {
    return Promise.resolve(getDIContainer());
  }

  return initializeDI(config).then((result) => result.container);
}
