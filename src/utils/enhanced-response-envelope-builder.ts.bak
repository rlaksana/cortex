/**
 * Enhanced MCP Response Envelope Builder with Zod Integration
 *
 * Type-safe response builders with runtime validation using Zod schemas.
 * Provides comprehensive type safety, validation, and error handling.
 *
 * @author Cortex Team
 * @version 1.0.0
 * @since 2025
 */

import { v4 as uuidv4 } from 'uuid';
import { z } from 'zod';

import {
  type SuccessEnvelopeSchema,
  type UnifiedResponseMetaSchema,
  validateResponseEnvelopeOrThrow,
} from './response-envelope-schemas';
import {
  type MemoryFindResult,
  type MemoryStoreResult,
  type SystemStatusResult,
} from '../types/mcp-response-data.types';
import {
  type ErrorEnvelope,
  type PaginatedEnvelope,
  type ResponseEnvelope,
  type StreamingEnvelope,
  type SuccessEnvelope,
} from '../types/response-envelope.types';
import {
  type UnifiedResponseMeta,
} from '../types/unified-response.interface';

// Re-export types for external use
export {
  type DatabaseErrorDetails,
  type MemoryFindResult,
  type MemoryStoreResult,
  type RateLimitErrorDetails,
  type SystemStatusResult,
  type ValidationErrorDetails,
} from '../types/mcp-response-data.types';
export type {
  ErrorEnvelope,
  PaginatedEnvelope,
  ResponseEnvelope,
  StreamingEnvelope,
  SuccessEnvelope,
} from '../types/response-envelope.types';
export { ErrorCode } from './response-envelope-builder';

/**
 * Enhanced envelope builder context with validation options
 */
interface EnhancedEnvelopeBuilderContext {
  operationType: string;
  startTime: number;
  requestId: string;
  operationId?: string;
  apiVersion: string;
  validationEnabled: boolean;
  strictMode: boolean;
}

/**
 * Builder configuration options
 */
export interface BuilderConfig {
  apiVersion?: string;
  validationEnabled?: boolean;
  strictMode?: boolean;
  defaultMeta?: Partial<UnifiedResponseMeta>;
}

/**
 * Enhanced response envelope builder with Zod validation
 */
export class EnhancedResponseEnvelopeBuilder {
  private context: EnhancedEnvelopeBuilderContext;
  private config: BuilderConfig;

  constructor(
    operationType: string,
    config: BuilderConfig = {},
    startTime?: number,
    apiVersion?: string
  ) {
    this.config = {
      apiVersion: apiVersion || config.apiVersion || '1.0.0',
      validationEnabled: config.validationEnabled ?? true,
      strictMode: config.strictMode ?? false,
      defaultMeta: config.defaultMeta || {},
    };

    this.context = {
      operationType,
      startTime: startTime || Date.now(),
      requestId: uuidv4(),
      apiVersion: this.config.apiVersion,
      validationEnabled: this.config.validationEnabled,
      strictMode: this.config.strictMode,
    };
  }

  /**
   * Set operation ID for tracking
   */
  setOperationId(operationId: string): EnhancedResponseEnvelopeBuilder {
    this.context.operationId = operationId;
    return this;
  }

  /**
   * Enable/disable validation
   */
  setValidationEnabled(enabled: boolean): EnhancedResponseEnvelopeBuilder {
    this.context.validationEnabled = enabled;
    return this;
  }

  /**
   * Enable/disable strict mode
   */
  setStrictMode(strict: boolean): EnhancedResponseEnvelopeBuilder {
    this.context.strictMode = strict;
    return this;
  }

  /**
   * Create a base envelope with common fields
   */
  private createBaseEnvelope() {
    return {
      timestamp: new Date().toISOString(),
      request_id: this.context.requestId,
      operation_id: this.context.operationId,
      api_version: this.context.apiVersion,
    };
  }

  /**
   * Validate and create meta object
   */
  private createValidatedMeta(meta?: Partial<UnifiedResponseMeta>): UnifiedResponseMeta {
    const defaultMeta: UnifiedResponseMeta = {
      strategy: 'auto',
      vector_used: false,
      degraded: false,
      source: this.context.operationType,
    };

    const finalMeta = { ...defaultMeta, ...this.config.defaultMeta, ...meta };

    if (this.context.validationEnabled) {
      try {
        UnifiedResponseMetaSchema.parse(finalMeta);
      } catch (error) {
        if (error instanceof z.ZodError) {
          throw new Error(`Invalid meta: ${error.errors.map(e => e.message).join(', ')}`);
        }
        throw error;
      }
    }

    return finalMeta;
  }

  /**
   * Create a success envelope with validation
   */
  createSuccessEnvelope<TData>(
    data: TData,
    meta?: Partial<UnifiedResponseMeta>,
    message?: string,
    rateLimit?: SuccessEnvelope['rate_limit'],
    dataSchema?: z.ZodSchema<TData>
  ): SuccessEnvelope<TData> {
    const base = this.createBaseEnvelope();
    const validatedMeta = this.createValidatedMeta(meta);

    const envelope: SuccessEnvelope<TData> = {
      type: 'success',
      success: true,
      data,
      meta: validatedMeta,
      message,
      rate_limit: rateLimit,
      ...base,
    };

    if (this.context.validationEnabled) {
      const schema = SuccessEnvelopeSchema<TData>();
      if (dataSchema) {
        // For strict mode, validate data with provided schema
        if (this.context.strictMode) {
          dataSchema.parse(data);
        }
      }
      validateResponseEnvelopeOrThrow(envelope, dataSchema);
    }

    return envelope;
  }

  /**
   * Create an error envelope with validation
   */
  createErrorEnvelope<TErrorData = unknown>(
    code: string,
    message: string,
    type?: string,
    details?: TErrorData,
    retryable: boolean = false,
    retryAfterMs?: number,
    detailsSchema?: z.ZodSchema<TErrorData>
  ): ErrorEnvelope<TErrorData> {
    const base = this.createBaseEnvelope();
    const errorId = uuidv4();

    const error = {
      code,
      message,
      type: type || 'InternalServerError',
      retryable,
      retry_after_ms: retryAfterMs,
    };

    if (details !== undefined) {
      (error as unknown).details = details;

      if (this.context.validationEnabled && detailsSchema && this.context.strictMode) {
        detailsSchema.parse(details);
      }
    }

    const envelope: ErrorEnvelope<TErrorData> = {
      type: 'error',
      success: false,
      data: null,
      error,
      error_id: errorId,
      ...base,
    };

    if (this.context.validationEnabled) {
      validateResponseEnvelopeOrThrow(envelope, undefined, detailsSchema);
    }

    return envelope;
  }

  /**
   * Create a paginated envelope with validation
   */
  createPaginatedEnvelope<TData>(
    data: TData[],
    pagination: {
      page: number;
      per_page: number;
      total: number;
      has_next?: boolean;
      has_prev?: boolean;
      next_cursor?: string;
      prev_cursor?: string;
    },
    meta?: Partial<UnifiedResponseMeta>,
    summary?: Record<string, unknown>,
    rateLimit?: PaginatedEnvelope['rate_limit'],
    dataSchema?: z.ZodSchema<TData>
  ): PaginatedEnvelope<TData> {
    const base = this.createBaseEnvelope();
    const validatedMeta = this.createValidatedMeta(meta);

    const paginationData = {
      page: pagination.page,
      per_page: pagination.per_page,
      total: pagination.total,
      total_pages: Math.ceil(pagination.total / pagination.per_page),
      has_next: pagination.has_next ?? pagination.page * pagination.per_page < pagination.total,
      has_prev: pagination.has_prev ?? pagination.page > 1,
      next_cursor: pagination.next_cursor,
      prev_cursor: pagination.prev_cursor,
    };

    // Validate data array if schema provided and strict mode enabled
    if (this.context.validationEnabled && dataSchema && this.context.strictMode) {
      data.forEach(item => dataSchema.parse(item));
    }

    const envelope: PaginatedEnvelope<TData> = {
      type: 'paginated',
      success: true,
      data,
      pagination: paginationData,
      summary,
      meta: validatedMeta,
      rate_limit: rateLimit,
      ...base,
    };

    if (this.context.validationEnabled) {
      validateResponseEnvelopeOrThrow(envelope, dataSchema ? z.array(dataSchema) : undefined);
    }

    return envelope;
  }

  /**
   * Create a streaming envelope with validation
   */
  createStreamingEnvelope<TData>(
    data: TData,
    streamId: string,
    chunkNumber: number,
    status: 'active' | 'completed' | 'error' | 'timeout',
    meta?: Partial<UnifiedResponseMeta>,
    totalChunks?: number,
    isFinal: boolean = false,
    streamMetadata?: {
      content_type?: string;
      estimated_size_bytes?: number;
      progress?: number;
    },
    rateLimit?: StreamingEnvelope['rate_limit'],
    dataSchema?: z.ZodSchema<TData>
  ): StreamingEnvelope<TData> {
    const base = this.createBaseEnvelope();
    const validatedMeta = this.createValidatedMeta(meta);

    // Validate data if schema provided and strict mode enabled
    if (this.context.validationEnabled && dataSchema && this.context.strictMode) {
      dataSchema.parse(data);
    }

    const envelope: StreamingEnvelope<TData> = {
      type: 'streaming',
      success: true,
      data,
      stream: {
        stream_id: streamId,
        chunk_number: chunkNumber,
        total_chunks: totalChunks,
        is_final: isFinal,
        status,
      },
      stream_metadata: streamMetadata,
      meta: validatedMeta,
      rate_limit: rateLimit,
      ...base,
    };

    if (this.context.validationEnabled) {
      validateResponseEnvelopeOrThrow(envelope, dataSchema);
    }

    return envelope;
  }

  /**
   * Create a memory store success envelope
   */
  createMemoryStoreSuccess(
    data: MemoryStoreResult,
    meta?: Partial<UnifiedResponseMeta>
  ): SuccessEnvelope<MemoryStoreResult> {
    return this.createSuccessEnvelope(data, meta, 'Memory store operation completed successfully');
  }

  /**
   * Create a memory find success envelope
   */
  createMemoryFindSuccess(
    data: MemoryFindResult,
    meta?: Partial<UnifiedResponseMeta>
  ): SuccessEnvelope<MemoryFindResult> {
    return this.createSuccessEnvelope(data, meta, 'Memory find operation completed successfully');
  }

  /**
   * Create a system status success envelope
   */
  createSystemStatusSuccess(
    data: SystemStatusResult,
    meta?: Partial<UnifiedResponseMeta>
  ): SuccessEnvelope<SystemStatusResult> {
    return this.createSuccessEnvelope(data, meta, 'System status retrieved successfully');
  }
}

/**
 * Factory function to create enhanced response envelope builders
 */
export function createEnhancedResponseEnvelopeBuilder(
  operationType: string,
  config?: BuilderConfig
): EnhancedResponseEnvelopeBuilder {
  return new EnhancedResponseEnvelopeBuilder(operationType, config);
}

/**
 * Utility function to validate any envelope
 */
export function validateEnvelope<TData = unknown, TErrorData = unknown>(
  envelope: unknown,
  dataSchema?: z.ZodSchema<TData>,
  errorDataSchema?: z.ZodSchema<TErrorData>
): ResponseEnvelope<TData, TErrorData> {
  return validateResponseEnvelopeOrThrow(envelope, dataSchema, errorDataSchema);
}

/**
 * Enhanced validator for operation-specific responses
 */
export function validateOperationResponse<TData = unknown, TErrorData = unknown>(
  envelope: unknown,
  operationType: string,
  dataSchema?: z.ZodSchema<TData>,
  errorDataSchema?: z.ZodSchema<TErrorData>
): ResponseEnvelope<TData, TErrorData> {
  const validated = validateResponseEnvelopeOrThrow(envelope, dataSchema, errorDataSchema);

  // Additional operation-specific validation can be added here
  if (operationType === 'memory_store' && validated.type === 'success') {
    // Add memory store specific validation
    if (!validated.data || typeof validated.data !== 'object') {
      throw new Error('Memory store responses must contain data object');
    }
  }

  return validated;
}