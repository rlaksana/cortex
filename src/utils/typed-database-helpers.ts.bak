/**
 * Typed Database Helper Utilities
 *
 * Provides type-safe helper functions for working with database results
 * that come back as unknown[] from the database layer.
 */

import { logger } from '@/utils/logger.js';

import {
  decisionDataToJSONValue,
  incidentDataToJSONValue,
  issueDataToJSONValue,
  metadataToJSONValue,
  recordToJSONObject,
  riskDataToJSONValue,
  runbookDataToJSONValue,
  scopeToJSONValue,
  sectionDataToJSONValue,
  todoDataToJSONValue} from './type-fixes.js';
import type { DatabaseManager } from '../db/database-manager.js';
import type { KnowledgeItem } from '../types/core-interfaces.js';
import {
  isDecisionEntityRow,
  isIncidentEntityRow,
  isIssueEntityRow,
  isKnowledgeEntityRow,
  isRiskEntityRow,
  isRunbookEntityRow,
  isSectionEntityRow,
  isTodoEntityRow,
  knowledgeEntityRowToKnowledgeItem
} from '../types/database-results.js';


// ============================================================================
// Generic Database Result Type Guards
// ============================================================================

export function isKnowledgeItem(obj: unknown): obj is KnowledgeItem {
  if (!obj || typeof obj !== 'object') return false;
  const item = obj as Record<string, unknown>;

  return (
    (item.id === undefined || typeof item.id === 'string') &&
    typeof item.kind === 'string' &&
    (item.content === undefined || typeof item.content === 'string') &&
    typeof item.scope === 'object' && item.scope !== null &&
    typeof item.data === 'object' && item.data !== null &&
    (item.created_at === undefined || typeof item.created_at === 'string') &&
    (item.updated_at === undefined || typeof item.updated_at === 'string') &&
    (item.expiry_at === undefined || typeof item.expiry_at === 'string')
  );
}

export function isDatabaseRecordWithId(obj: unknown): obj is { id: string; [key: string]: unknown } {
  if (!obj || typeof obj !== 'object') return false;
  const record = obj as Record<string, unknown>;
  return typeof record.id === 'string';
}

export function isDatabaseRecordWithTimestamps(obj: unknown): obj is {
  created_at: string;
  updated_at: string;
  [key: string]: unknown
} {
  if (!obj || typeof obj !== 'object') return false;
  const record = obj as Record<string, unknown>;
  return typeof record.created_at === 'string' && typeof record.updated_at === 'string';
}

// ============================================================================
// Typed Database Result Extractors
// ============================================================================

/**
 * Safely extract typed results from unknown database results
 */
export class TypedDatabaseResultExtractor {
  /**
   * Extract KnowledgeItem results from unknown database results
   */
  static extractKnowledgeItems(results: unknown[]): KnowledgeItem[] {
    return results.filter(isKnowledgeItem) as KnowledgeItem[];
  }

  /**
   * Extract KnowledgeEntityRow results and convert to KnowledgeItem
   */
  static extractKnowledgeEntities(results: unknown[]): KnowledgeItem[] {
    return results
      .filter(isKnowledgeEntityRow)
      .map(knowledgeEntityRowToKnowledgeItem);
  }

  /**
   * Extract specific entity type results with proper type conversion
   */
  static extractSectionEntities(results: unknown[]): KnowledgeItem[] {
    return results
      .filter(isSectionEntityRow)
      .map((row) => ({
        ...row,
        data: sectionDataToJSONValue(row.data as unknown as Record<string, unknown>)
      }))
      .map(knowledgeEntityRowToKnowledgeItem);
  }

  static extractRunbookEntities(results: unknown[]): KnowledgeItem[] {
    return results
      .filter(isRunbookEntityRow)
      .map((row) => ({
        ...row,
        data: runbookDataToJSONValue(row.data as unknown as Record<string, unknown>)
      }))
      .map(knowledgeEntityRowToKnowledgeItem);
  }

  static extractIssueEntities(results: unknown[]): KnowledgeItem[] {
    return results
      .filter(isIssueEntityRow)
      .map((row) => ({
        ...row,
        data: issueDataToJSONValue(row.data as unknown as Record<string, unknown>)
      }))
      .map(knowledgeEntityRowToKnowledgeItem);
  }

  static extractDecisionEntities(results: unknown[]): KnowledgeItem[] {
    return results
      .filter(isDecisionEntityRow)
      .map((row) => ({
        ...row,
        data: decisionDataToJSONValue(row.data as unknown as Record<string, unknown>)
      }))
      .map(knowledgeEntityRowToKnowledgeItem);
  }

  static extractTodoEntities(results: unknown[]): KnowledgeItem[] {
    return results
      .filter(isTodoEntityRow)
      .map((row) => ({
        ...row,
        data: todoDataToJSONValue(row.data as unknown as Record<string, unknown>)
      }))
      .map(knowledgeEntityRowToKnowledgeItem);
  }

  static extractIncidentEntities(results: unknown[]): KnowledgeItem[] {
    return results
      .filter(isIncidentEntityRow)
      .map((row) => ({
        ...row,
        data: incidentDataToJSONValue(row.data as unknown as Record<string, unknown>)
      }))
      .map(knowledgeEntityRowToKnowledgeItem);
  }

  static extractRiskEntities(results: unknown[]): KnowledgeItem[] {
    return results
      .filter(isRiskEntityRow)
      .map((row) => ({
        ...row,
        data: riskDataToJSONValue(row.data as unknown as Record<string, unknown>)
      }))
      .map(knowledgeEntityRowToKnowledgeItem);
  }

  /**
   * Extract database records with ID
   */
  static extractRecordsWithId(results: unknown[]): { id: string; [key: string]: unknown }[] {
    return results.filter(isDatabaseRecordWithId) as { id: string; [key: string]: unknown }[];
  }

  /**
   * Get first record ID from unknown results
   */
  static getFirstId(results: unknown[]): string | null {
    const firstRecord = results.find(isDatabaseRecordWithId);
    return firstRecord ? firstRecord.id : null;
  }

  /**
   * Extract records by kind
   */
  static extractByKind(results: unknown[], kind: string): KnowledgeItem[] {
    return this.extractKnowledgeItems(results).filter(item => item.kind === kind);
  }
}

// ============================================================================
// Database Query Builder with Type Safety
// ============================================================================

export class TypedQueryBuilder {
  /**
   * Create a typed find query result
   */
  static async typedFind<T>(
    findFunction: () => Promise<unknown[]>,
    typeGuard: (obj: unknown) => obj is T,
    errorMessage?: string
  ): Promise<T[]> {
    try {
      const results = await findFunction();
      const typedResults = results.filter(typeGuard) as T[];

      if (typedResults.length === 0 && results.length > 0 && errorMessage) {
        console.warn(`Typed query warning: ${errorMessage}. Found ${results.length} results but none matched expected type.`);
      }

      return typedResults;
    } catch (error) {
      console.error('Typed query failed:', error);
      throw error;
    }
  }

  /**
   * Find and return first matching result
   */
  static async typedFindFirst<T>(
    findFunction: () => Promise<unknown[]>,
    typeGuard: (obj: unknown) => obj is T
  ): Promise<T | null> {
    const results = await this.typedFind(findFunction, typeGuard);
    return results.length > 0 ? results[0] : null;
  }

  /**
   * Find with fallback for type mismatches
   */
  static async typedFindWithFallback<T>(
    findFunction: () => Promise<unknown[]>,
    typeGuard: (obj: unknown) => obj is T,
    fallbackTransform?: (obj: unknown) => T | null
  ): Promise<T[]> {
    try {
      const results = await findFunction();
      const typedResults: T[] = [];

      for (const result of results) {
        if (typeGuard(result)) {
          typedResults.push(result);
        } else if (fallbackTransform) {
          const transformed = fallbackTransform(result);
          if (transformed) {
            typedResults.push(transformed);
          }
        }
      }

      return typedResults;
    } catch (error) {
      console.error('Typed query with fallback failed:', error);
      throw error;
    }
  }
}

// ============================================================================
// Common Database Transform Functions
// ============================================================================

/**
 * Transform legacy database record to KnowledgeItem with proper type conversion
 */
export function legacyRecordToKnowledgeItem(record: unknown): KnowledgeItem | null {
  if (!record || typeof record !== 'object') return null;

  const rec = record as Record<string, unknown>;

  if (!isDatabaseRecordWithId(rec)) return null;

  // Extract metadata from various possible field names and convert to JSONValue
  const metadata = rec.metadata && typeof rec.metadata === 'object'
    ? metadataToJSONValue(rec.metadata as Record<string, unknown>)
    : undefined;

  // Convert data to proper JSONValue
  const data = rec.data && typeof rec.data === 'object'
    ? recordToJSONObject(rec.data as Record<string, unknown>)
    : recordToJSONObject(rec);

  // Handle different field naming conventions
  return {
    id: rec.id,
    kind: rec.kind as string || 'entity',
    content: rec.content as string || JSON.stringify(rec),
    scope: scopeToJSONValue({
      project: (rec.scope_project as string) || (rec.project as string) || 'default',
      branch: (rec.scope_branch as string) || (rec.branch as string) || 'main',
      org: (rec.scope_org as string) || (rec.org as string) || 'default',
    }),
    data,
    metadata,
    created_at: rec.created_at as string || new Date().toISOString(),
    updated_at: rec.updated_at as string || new Date().toISOString(),
    expiry_at: rec.expiry_at as string || undefined,
  };
}

/**
 * Transform audit record to knowledge item with proper type conversion
 */
export function auditRecordToKnowledgeItem(record: unknown): KnowledgeItem | null {
  if (!record || typeof record !== 'object') return null;

  const rec = record as Record<string, unknown>;

  if (!isDatabaseRecordWithId(rec)) return null;

  return {
    id: rec.id,
    kind: 'observation',
    content: `Audit: ${rec.table_name || 'unknown'} - ${rec.operation || 'unknown'}`,
    scope: scopeToJSONValue({
      project: 'cortex-audit',
      branch: 'main',
    }),
    data: recordToJSONObject({
      table_name: rec.table_name,
      operation: rec.operation,
      old_data: rec.old_data,
      new_data: rec.new_data,
      changed_by: rec.changed_by,
      record_id: rec.record_id,
    }),
    metadata: metadataToJSONValue({
      event_type: rec.event_type,
      timestamp: rec.changed_at || rec.created_at,
    }),
    created_at: rec.created_at as string || new Date().toISOString(),
    updated_at: rec.updated_at as string || new Date().toISOString(),
  };
}

// ============================================================================
// Validation Utilities
// ============================================================================

export class DatabaseResultValidator {
  /**
   * Validate that all results are of expected type
   */
  static validateAll<T>(results: unknown[], typeGuard: (obj: unknown) => obj is T): {
    isValid: boolean;
    validResults: T[];
    invalidResults: unknown[];
    errors: string[];
  } {
    const validResults: T[] = [];
    const invalidResults: unknown[] = [];
    const errors: string[] = [];

    results.forEach((result, index) => {
      if (typeGuard(result)) {
        validResults.push(result);
      } else {
        invalidResults.push(result);
        errors.push(`Result at index ${index} does not match expected type`);
      }
    });

    return {
      isValid: invalidResults.length === 0,
      validResults,
      invalidResults,
      errors,
    };
  }

  /**
   * Validate at least one result matches expected type
   */
  static validateAny<T>(results: unknown[], typeGuard: (obj: unknown) => obj is T): {
    isValid: boolean;
    validResults: T[];
    firstValid: T | null;
  } {
    const validResults = results.filter(typeGuard) as T[];

    return {
      isValid: validResults.length > 0,
      validResults,
      firstValid: validResults.length > 0 ? validResults[0] : null,
    };
  }
}

// ============================================================================
// Database Adapter Interface Helpers
// ============================================================================

/**
 * Type-safe database query wrapper for finding single entities
 */
export async function findTypedEntity<T>(
  db: DatabaseManager,
  collection: string,
  filter: Record<string, unknown>,
  typeGuard: (obj: unknown) => obj is T
): Promise<T | null> {
  try {
    const result = await db.findOne(filter);

    if (result && typeGuard(result)) {
      return result;
    }

    if (result) {
      logger.warn(
        { collection, filter, result },
        'Database query returned object that failed type validation'
      );
    }

    return null;
  } catch (error) {
    logger.error({ error, collection, filter }, 'Failed to execute typed database query');
    throw error;
  }
}

/**
 * Type-safe database count operation using search with limit
 */
export async function countTypedEntities(
  db: DatabaseManager,
  collection: string,
  filter: Record<string, unknown>
): Promise<number> {
  try {
    // Use search with high limit as workaround for missing count method
    const results = await db.search(filter, { limit: 10000 });

    if (results && typeof results === 'object' && 'items' in results && Array.isArray((results as any).items)) {
      return (results.items as any[]).length;
    }

    return 0;
  } catch (error) {
    logger.error({ error, collection, filter }, 'Failed to count typed entities');
    throw error;
  }
}