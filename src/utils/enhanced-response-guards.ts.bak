/**
 * Enhanced Response Envelope Type Guards
 *
 * Comprehensive type guards for safe access to response envelope data
 * with runtime validation and error handling for unknown data types.
 *
 * @author Cortex Team
 * @version 1.0.0
 * @since 2025
 */

import { z } from 'zod';

import {
  isResponseEnvelope,
} from './response-envelope-schemas';
import type { MemoryFindResult, MemoryStoreResult, SystemStatusResult } from '../types/mcp-response-data.types';
import type { ErrorEnvelope, PaginatedEnvelope, StreamingEnvelope, SuccessEnvelope } from '../types/response-envelope.types';
import { isErrorEnvelope, isPaginatedEnvelope, isStreamingEnvelope, isSuccessEnvelope } from '../types/response-envelope.types';

/**
 * Enhanced type guard with data validation for success envelopes
 */
export function isSuccessEnvelopeWithData<TData>(
  envelope: unknown,
  dataSchema?: z.ZodSchema<TData>
): envelope is SuccessEnvelope<TData> {
  if (!isSuccessEnvelope(envelope)) {
    return false;
  }

  if (!dataSchema) {
    return true;
  }

  try {
    dataSchema.parse(envelope.data);
    return true;
  } catch {
    return false;
  }
}

/**
 * Enhanced type guard with error data validation
 */
export function isErrorEnvelopeWithData<TErrorData>(
  envelope: unknown,
  errorDataSchema?: z.ZodSchema<TErrorData>
): envelope is ErrorEnvelope<TErrorData> {
  if (!isErrorEnvelope(envelope)) {
    return false;
  }

  if (!errorDataSchema || envelope.error.details === undefined) {
    return true;
  }

  try {
    errorDataSchema.parse(envelope.error.details);
    return true;
  } catch {
    return false;
  }
}

/**
 * Enhanced type guard with data validation for paginated envelopes
 */
export function isPaginatedEnvelopeWithData<TData>(
  envelope: unknown,
  dataSchema?: z.ZodSchema<TData>
): envelope is PaginatedEnvelope<TData> {
  if (!isPaginatedEnvelope(envelope)) {
    return false;
  }

  if (!dataSchema) {
    return true;
  }

  try {
    const arraySchema = z.array(dataSchema);
    arraySchema.parse(envelope.data);
    return true;
  } catch {
    return false;
  }
}

/**
 * Enhanced type guard with data validation for streaming envelopes
 */
export function isStreamingEnvelopeWithData<TData>(
  envelope: unknown,
  dataSchema?: z.ZodSchema<TData>
): envelope is StreamingEnvelope<TData> {
  if (!isStreamingEnvelope(envelope)) {
    return false;
  }

  if (!dataSchema) {
    return true;
  }

  try {
    dataSchema.parse(envelope.data);
    return true;
  } catch {
    return false;
  }
}

/**
 * Safe extractor for success data with validation
 */
export function extractSuccessData<TData>(
  envelope: unknown,
  dataSchema?: z.ZodSchema<TData>
): { success: true; data: TData } | { success: false; error: string; data?: null } {
  try {
    if (!isSuccessEnvelope(envelope)) {
      return { success: false, error: 'Not a success envelope', data: null };
    }

    if (dataSchema) {
      const validatedData = dataSchema.parse(envelope.data);
      return { success: true, data: validatedData };
    }

    return { success: true, data: envelope.data as TData };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown validation error';
    return { success: false, error: `Data validation failed: ${errorMessage}` };
  }
}

/**
 * Safe extractor for error data with validation
 */
export function extractErrorData<TErrorData>(
  envelope: unknown,
  errorDataSchema?: z.ZodSchema<TErrorData>
): { success: true; error: { code: string; message: string; type: string; details?: TErrorData } } | { success: false; error: string } {
  try {
    if (!isErrorEnvelope(envelope)) {
      return { success: false, error: 'Not an error envelope' };
    }

    const errorInfo = {
      code: envelope.error.code,
      message: envelope.error.message,
      type: envelope.error.type,
    };

    if (errorDataSchema && envelope.error.details !== undefined) {
      const validatedDetails = errorDataSchema.parse(envelope.error.details);
      return { success: true, error: { ...errorInfo, details: validatedDetails } };
    }

    return { success: true, error: { ...errorInfo, details: envelope.error.details as TErrorData } };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown validation error';
    return { success: false, error: `Error data validation failed: ${errorMessage}` };
  }
}

/**
 * Safe extractor for paginated data with validation
 */
export function extractPaginatedData<TData>(
  envelope: unknown,
  dataSchema?: z.ZodSchema<TData>
): { success: true; data: TData[]; pagination: unknown } | { success: false; error: string } {
  try {
    if (!isPaginatedEnvelope(envelope)) {
      return { success: false, error: 'Not a paginated envelope' };
    }

    if (dataSchema) {
      const arraySchema = z.array(dataSchema);
      const validatedData = arraySchema.parse(envelope.data);
      return { success: true, data: validatedData, pagination: envelope.pagination };
    }

    return { success: true, data: envelope.data as TData[], pagination: envelope.pagination };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown validation error';
    return { success: false, error: `Paginated data validation failed: ${errorMessage}` };
  }
}

/**
 * Safe extractor for streaming data with validation
 */
export function extractStreamingData<TData>(
  envelope: unknown,
  dataSchema?: z.ZodSchema<TData>
): { success: true; data: TData; stream: unknown } | { success: false; error: string } {
  try {
    if (!isStreamingEnvelope(envelope)) {
      return { success: false, error: 'Not a streaming envelope' };
    }

    if (dataSchema) {
      const validatedData = dataSchema.parse(envelope.data);
      return { success: true, data: validatedData, stream: envelope.stream };
    }

    return { success: true, data: envelope.data as TData, stream: envelope.stream };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown validation error';
    return { success: false, error: `Streaming data validation failed: ${errorMessage}` };
  }
}

/**
 * Memory store specific type guard
 */
export function isMemoryStoreResponse(envelope: unknown): boolean {
  return isSuccessEnvelopeWithData(envelope, MemoryStoreResultSchema);
}

/**
 * Memory find specific type guard
 */
export function isMemoryFindResponse(envelope: unknown): boolean {
  return isSuccessEnvelopeWithData(envelope, MemoryFindResultSchema);
}

/**
 * System status specific type guard
 */
export function isSystemStatusResponse(envelope: unknown): boolean {
  return isSuccessEnvelopeWithData(envelope, SystemStatusResultSchema);
}

/**
 * Safe extractor for memory store responses
 */
export function extractMemoryStoreData(envelope: unknown): MemoryStoreResult | null {
  const result = extractSuccessData(envelope, MemoryStoreResultSchema);
  return result.success ? result.data : null;
}

/**
 * Safe extractor for memory find responses
 */
export function extractMemoryFindData(envelope: unknown): MemoryFindResult | null {
  const result = extractSuccessData(envelope, MemoryFindResultSchema);
  return result.success ? result.data : null;
}

/**
 * Safe extractor for system status responses
 */
export function extractSystemStatusData(envelope: unknown): SystemStatusResult | null {
  const result = extractSuccessData(envelope, SystemStatusResultSchema);
  return result.success ? result.data : null;
}

/**
 * Generic safe property accessor for unknown objects
 */
export function safeGet<T>(
  obj: unknown,
  path: string,
  defaultValue: T,
  validator?: z.ZodSchema<T>
): T {
  try {
    if (obj === null || obj === undefined) {
      return defaultValue;
    }

    const keys = path.split('.');
    let current = obj;

    for (const key of keys) {
      if (current && typeof current === 'object' && key in current) {
        current = (current as unknown)[key];
      } else {
        return defaultValue;
      }
    }

    if (validator) {
      return validator.parse(current) as T;
    }

    return current as T;
  } catch {
    return defaultValue;
  }
}

/**
 * Safe array extractor with type validation
 */
export function safeExtractArray<T>(
  data: unknown,
  itemSchema: z.ZodSchema<T>,
  defaultValue: T[] = []
): T[] {
  try {
    if (!Array.isArray(data)) {
      return defaultValue;
    }

    const arraySchema = z.array(itemSchema);
    return arraySchema.parse(data);
  } catch {
    return defaultValue;
  }
}

/**
 * Safe object extractor with type validation
 */
export function safeExtractObject<T extends Record<string, unknown>>(
  data: unknown,
  shape: z.ZodObject<unknown>,
  defaultValue: T
): T {
  try {
    if (!data || typeof data !== 'object') {
      return defaultValue;
    }

    return shape.parse(data) as T;
  } catch {
    return defaultValue;
  }
}

// Zod schemas for common response types
const MemoryStoreResultSchema = z.object({
  stored_items: z.array(z.any()),
  failed_items: z.array(z.any()),
  summary: z.object({
    total_attempted: z.number(),
    total_stored: z.number(),
    total_failed: z.number(),
    success_rate: z.number(),
  }),
  batch_id: z.string(),
});

const MemoryFindResultSchema = z.object({
  query: z.string(),
  strategy: z.string(),
  confidence: z.number(),
  total: z.number(),
  items: z.array(z.any()),
  search_id: z.string(),
  strategy_details: z.any(),
});

const SystemStatusResultSchema = z.object({
  status: z.string(),
  timestamp: z.string(),
  components: z.record(z.any()),
  metrics: z.record(z.number()),
});

/**
 * Response envelope processor with enhanced error handling
 */
export class SafeResponseProcessor {
  /**
   * Process response with comprehensive error handling and validation
   */
  static process<T>(
    envelope: unknown,
    handlers: {
      onSuccess?: (data: T) => unknown;
      onError?: (error: { code: string; message: string; type: string }) => unknown;
      onPaginated?: (data: T[], pagination: unknown) => unknown;
      onStreaming?: (data: T, stream: unknown) => unknown;
      onUnknown?: (envelope: unknown) => unknown;
      onValidationError?: (error: string) => unknown;
    },
    dataSchema?: z.ZodSchema<T>
  ): unknown {
    try {
      // First validate the envelope structure
      if (!isResponseEnvelope(envelope)) {
        return handlers.onValidationError?.('Invalid envelope structure') ??
               handlers.onUnknown?.(envelope);
      }

      if (isSuccessEnvelope(envelope)) {
        const dataResult = extractSuccessData(envelope, dataSchema);
        if (dataResult.success) {
          return handlers.onSuccess?.(dataResult.data);
        } else {
          return handlers.onValidationError?.(dataResult.error) ??
                 handlers.onUnknown?.(envelope);
        }
      } else if (isErrorEnvelope(envelope)) {
        const errorResult = extractErrorData(envelope);
        if (errorResult.success) {
          return handlers.onError?.(errorResult.error);
        } else {
          return handlers.onValidationError?.(errorResult.error) ??
                 handlers.onUnknown?.(envelope);
        }
      } else if (isPaginatedEnvelope(envelope)) {
        const dataResult = extractPaginatedData(envelope, dataSchema);
        if (dataResult.success) {
          return handlers.onPaginated?.(dataResult.data, dataResult.pagination);
        } else {
          return handlers.onValidationError?.(dataResult.error) ??
                 handlers.onUnknown?.(envelope);
        }
      } else if (isStreamingEnvelope(envelope)) {
        const dataResult = extractStreamingData(envelope, dataSchema);
        if (dataResult.success) {
          return handlers.onStreaming?.(dataResult.data, dataResult.stream);
        } else {
          return handlers.onValidationError?.(dataResult.error) ??
                 handlers.onUnknown?.(envelope);
        }
      }

      return handlers.onUnknown?.(envelope);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown processing error';
      return handlers.onValidationError?.(errorMessage) ?? null;
    }
  }
}