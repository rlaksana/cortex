/**
 * Production Security Middleware
 *
 * Comprehensive security middleware for production deployments.
 * Implements security headers, rate limiting, API key validation,
 * and production-specific security measures.
 *
 * @author Cortex Team
 * @version 2.0.1
 */

import { randomBytes } from 'crypto';
import type { Request, Response, NextFunction } from 'express';
import rateLimit from 'express-rate-limit';
import helmet from 'helmet';
import type { ExtendedRequest } from '../types/express-extensions.js';
import { addRequestMetadata, asTypedMiddleware } from '../types/express-extensions.js';
import { logger } from '../utils/logger.js';

export interface ProductionSecurityConfig {
  corsOrigin: string[];
  rateLimitEnabled: boolean;
  rateLimitWindowMs: number;
  rateLimitMaxRequests: number;
  helmetEnabled: boolean;
  requireApiKey: boolean;
  maxRequestSizeMb: number;
  enableCompression: boolean;
}

export class ProductionSecurityMiddleware {
  private config: ProductionSecurityConfig;
  private static readonly MAX_REQUEST_SIZE = 10 * 1024 * 1024; // 10MB

  constructor(config: ProductionSecurityConfig) {
    this.config = config;
  }

  /**
   * Initialize all production security middleware
   */
  initializeMiddleware(): Array<(req: Request, res: Response, next: NextFunction) => void> {
    const middleware: Array<(req: Request, res: Response, next: NextFunction) => void> = [];

    // Request size validation
    middleware.push(this.validateRequestSize());

    // API key validation
    if (this.config.requireApiKey) {
      middleware.push(this.validateApiKey());
    }

    // Rate limiting
    if (this.config.rateLimitEnabled) {
      middleware.push(this.createRateLimiter());
    }

    // Security headers
    if (this.config.helmetEnabled) {
      middleware.push(this.createHelmetMiddleware());
    }

    // Request logging
    middleware.push(this.logRequests());

    // Request sanitization
    middleware.push(this.sanitizeInput());

    return middleware;
  }

  /**
   * Validate request size to prevent payload attacks
   */
  private validateRequestSize() {
    const config = this.config;
    return (_req: Request,  _res: Response,  _next: NextFunction): void => {
      const contentLength = parseInt(req.headers['content-length'] || '0');
      const maxSize = Math.min(
        config.maxRequestSizeMb * 1024 * 1024,
        ProductionSecurityMiddleware.MAX_REQUEST_SIZE
      );

      if (contentLength > maxSize) {
        logger.warn('Request size exceeded limit', {
          contentLength,
          maxSize,
          ip: req.ip,
          userAgent: req.headers['user-agent'],
        });

        res.status(413).json({
          error: 'Payload Too Large',
          message: `Request size ${contentLength} exceeds maximum allowed size of ${maxSize} bytes`,
          code: 'PAYLOAD_TOO_LARGE',
        });
        return;
      }

      next();
    };
  }

  /**
   * Validate API key for MCP operations
   */
  private validateApiKey() {
    const validApiKey = process.env.MCP_API_KEY;

    if (!validApiKey) {
      throw new Error(
        'MCP_API_KEY environment variable is required when API key validation is enabled'
      );
    }

    return (_req: Request,  _res: Response,  _next: NextFunction): void => {
      const providedApiKey = req.headers['x-api-key'] as string;

      if (!providedApiKey) {
        logger.warn('Missing API key', {
          ip: req.ip,
          path: req.path,
          userAgent: req.headers['user-agent'],
        });

        res.status(401).json({
          error: 'Unauthorized',
          message: 'API key is required',
          code: 'MISSING_API_KEY',
        });
        return;
      }

      // Use constant-time comparison to prevent timing attacks
      if (!ProductionSecurityMiddleware.constantTimeCompare(providedApiKey, validApiKey)) {
        logger.warn('Invalid API key', {
          ip: req.ip,
          path: req.path,
          userAgent: req.headers['user-agent'],
        });

        res.status(401).json({
          error: 'Unauthorized',
          message: 'Invalid API key',
          code: 'INVALID_API_KEY',
        });
        return;
      }

      next();
    };
  }

  /**
   * Constant-time comparison to prevent timing attacks
   */
  private static constantTimeCompare(_a: string,  _b: string): boolean {
    if (a.length !== b.length) {
      return false;
    }

    let result = 0;
    for (let i = 0; i < a.length; i++) {
      result |= a.charCodeAt(i) ^ b.charCodeAt(i);
    }

    return result === 0;
  }

  /**
   * Create rate limiter middleware
   */
  private createRateLimiter() {
    const config = this.config;
    const limiter = rateLimit({
      windowMs: config.rateLimitWindowMs,
      max: config.rateLimitMaxRequests,
      message: {
        error: 'Too Many Requests',
        message: `Rate limit exceeded. Maximum ${config.rateLimitMaxRequests} requests per ${String(config.rateLimitWindowMs / 1000)} seconds.`,
        code: 'RATE_LIMIT_EXCEEDED',
        retryAfter: Math.ceil(config.rateLimitWindowMs / 1000),
      },
      standardHeaders: true,
      legacyHeaders: false,
      skipSuccessfulRequests: false,
      skipFailedRequests: false,
      keyGenerator: (req: Request) => {
        // Use IP address for rate limiting
        return req.ip || 'unknown';
      },
      handler: (req: Request, res: Response) => {
        logger.warn('Rate limit exceeded', {
          ip: req.ip,
          path: req.path,
          userAgent: req.headers['user-agent'],
          rateLimit: {
            limit: config.rateLimitMaxRequests,
            windowMs: config.rateLimitWindowMs,
          },
        });

        res.status(429).json({
          error: 'Too Many Requests',
          message: `Rate limit exceeded. Maximum ${config.rateLimitMaxRequests} requests per ${String(config.rateLimitWindowMs / 1000)} seconds.`,
          code: 'RATE_LIMIT_EXCEEDED',
          retryAfter: Math.ceil(config.rateLimitWindowMs / 1000),
        });
      },
    });

    return limiter;
  }

  /**
   * Create enhanced helmet middleware for security headers
   */
  private createHelmetMiddleware() {
    return helmet({
      // Content Security Policy with strict rules
      contentSecurityPolicy: {
        directives: {
          defaultSrc: ["'self'"],
          baseUri: ["'self'"],
          childSrc: ["'none'"],
          connectSrc: ["'self'", 'https://api.openai.com'],
          fontSrc: ["'self'", 'data:', 'https:'],
          formAction: ["'self'"],
          frameAncestors: ["'none'"],
          frameSrc: ["'none'"],
          imgSrc: ["'self'", 'data:', 'https:'],
          manifestSrc: ["'self'"],
          mediaSrc: ["'self'"],
          objectSrc: ["'none'"],
          scriptSrc: ["'self'", "'strict-dynamic'"],
          scriptSrcAttr: ["'none'"],
          styleSrc: ["'self'", "'unsafe-inline'"],
          upgradeInsecureRequests: [],
          workerSrc: ["'self'", 'blob:'],
        },
        reportOnly: process.env.NODE_ENV === 'development',
      },
      // Cross-Origin policies
      crossOriginEmbedderPolicy: { policy: 'require-corp' },
      crossOriginOpenerPolicy: { policy: 'same-origin' },
      crossOriginResourcePolicy: { policy: 'same-origin' },
      // DNS prefetch control
      dnsPrefetchControl: { allow: false },
      // Frame protection
      frameguard: {
        action: 'deny',
        domain: 'self',
      },
      // Hide Express/X-Powered-By header
      hidePoweredBy: true,
      // HTTP Strict Transport Security
      hsts: {
        maxAge: 31536000, // 1 year
        includeSubDomains: true,
        preload: true,
      },
      // IE security
      ieNoOpen: true,
      // MIME type sniffing protection
      noSniff: true,
      // Origin-Agent-Cluster header
      originAgentCluster: true,
      // Permit cross-domain policies
      permittedCrossDomainPolicies: false,
      // Referrer policy
      referrerPolicy: {
        policy: 'strict-origin-when-cross-origin',
      },
      // XSS protection
      xssFilter: true,
      // Custom security headers
      customHeaders: this.getCustomSecurityHeaders(),
    });
  }

  /**
   * Get custom security headers
   */
  private getCustomSecurityHeaders(): Record<string, string> {
    return {
      'X-Content-Type-Options': 'nosniff',
      'X-Frame-Options': 'DENY',
      'X-XSS-Protection': '1; mode=block',
      'Strict-Transport-Security': 'max-age=31536000; includeSubDomains; preload',
      'Content-Security-Policy': this.getEnhancedCSP(),
      'Permissions-Policy': this.getPermissionsPolicy(),
      'Cross-Origin-Embedder-Policy': 'require-corp',
      'Cross-Origin-Opener-Policy': 'same-origin',
      'Cross-Origin-Resource-Policy': 'same-origin',
      'X-DNS-Prefetch-Control': 'off',
      'X-Download-Options': 'noopen',
      'X-Permitted-Cross-Domain-Policies': 'none',
      'X-Content-Security-Policy-Report-Only':
        process.env.NODE_ENV === 'development' ? this.getEnhancedCSP() : undefined,
      'Expect-CT': 'max-age=86400, enforce',
      NEL: '{"report_to":"default","max_age":31536000,"include_subdomains":true}',
      'Report-To':
        '{"group":"default","max_age":31536000,"endpoints":[{"url":"https://cortex.yourdomain.com/reports"}]}',
    };
  }

  /**
   * Get enhanced Content Security Policy
   */
  private getEnhancedCSP(): string {
    const directives = [
      "default-src 'self'",
      "base-uri 'self'",
      "child-src 'none'",
      "connect-src 'self' https://api.openai.com",
      "font-src 'self' data: https:",
      "form-action 'self'",
      "frame-ancestors 'none'",
      "frame-src 'none'",
      "img-src 'self' data: https:",
      "manifest-src 'self'",
      "media-src 'self'",
      "object-src 'none'",
      "script-src 'self' 'unsafe-inline' 'strict-dynamic' https:",
      "script-src-attr 'none'",
      "style-src 'self' 'unsafe-inline' https:",
      'upgrade-insecure-requests',
      "worker-src 'self' blob:",
    ];

    return directives.join('; ');
  }

  /**
   * Get Permissions Policy
   */
  private getPermissionsPolicy(): string {
    const permissions = [
      'accelerometer=()',
      'ambient-light-sensor=()',
      'autoplay=()',
      'battery=()',
      'camera=()',
      'cross-origin-isolated=()',
      'display-capture=()',
      'document-domain=()',
      'encrypted-media=()',
      'execution-while-not-rendered=()',
      'execution-while-out-of-viewport=()',
      'fullscreen=()',
      'geolocation=()',
      'gyroscope=()',
      'hid=()',
      'idle-detection=()',
      'magnetometer=()',
      'microphone=()',
      'midi=()',
      'navigation-override=()',
      'payment=()',
      'picture-in-picture=()',
      'publickey-credentials-get=()',
      'screen-wake-lock=()',
      'serial=()',
      'sync-xhr=()',
      'usb=()',
      'web-share=()',
      'xr-spatial-tracking=()',
    ];

    return permissions.join(', ');
  }

  /**
   * Log all requests for audit purposes
   */
  private logRequests() {
    return (_req: ExtendedRequest,  _res: Response,  _next: NextFunction) => {
      const startTime = Date.now();
      const requestId = this.generateRequestId();

      // Add request ID to headers
      res.setHeader('X-Request-ID', requestId);
      req.requestId = requestId;

      // Log request
      logger.info('Incoming request', {
        requestId,
        method: req.method,
        path: req.path,
        ip: req.ip,
        userAgent: req.headers['user-agent'],
        contentLength: req.headers['content-length'],
        referer: req.headers['referer'],
      });

      // Log response when finished
      res.on('finish',  () => {
        const duration = Date.now() - startTime;

        logger.info('Request completed', {
          requestId,
          method: req.method,
          path: req.path,
          statusCode: res.statusCode,
          duration,
          contentLength: res.getHeader('content-length'),
          ip: req.ip,
        });
      });

      next();
    };
  }

  /**
   * Sanitize input data to prevent injection attacks
   */
  private sanitizeInput() {
    return (_req: Request,  _res: Response,  _next: NextFunction): void => {
      try {
        // Sanitize query parameters
        if (req.query) {
          req.query = this.sanitizeObject(req.query);
        }

        // Sanitize request body if it's JSON
        if (req.body && typeof req.body === 'object') {
          req.body = this.sanitizeObject(req.body);
        }

        // Sanitize URL parameters
        if (req.params) {
          req.params = this.sanitizeObject(req.params);
        }

        next();
      } catch (error) {
        logger.error('Input sanitization failed', {
          error: error instanceof Error ? error.message : 'Unknown error',
          path: req.path,
          method: req.method,
          ip: req.ip,
        });

        res.status(400).json({
          error: 'Bad Request',
          message: 'Invalid input data',
          code: 'INVALID_INPUT',
        });
        return;
      }
    };
  }

  /**
   * Recursively sanitize object properties
   */
  private sanitizeObject(_obj: unknown): unknown {
    if (obj === null || obj === undefined) {
      return obj;
    }

    if (typeof obj === 'string') {
      return this.sanitizeString(obj);
    }

    if (Array.isArray(obj)) {
      return obj.map((item) => this.sanitizeObject(item));
    }

    if (typeof obj === 'object') {
      const sanitized: unknown = {};
      for (const [key, value] of Object.entries(obj)) {
        // Sanitize key names
        const sanitizedKey = this.sanitizeString(key);
        sanitized[sanitizedKey] = this.sanitizeObject(value);
      }
      return sanitized;
    }

    return obj;
  }

  /**
   * Sanitize string to prevent injection attacks
   */
  private sanitizeString(_str: string): string {
    if (typeof str !== 'string') {
      return str;
    }

    // Remove potentially dangerous characters
    return str
      .replace(/[<>]/g, '') // Remove HTML brackets
      .replace(/javascript:/gi, '') // Remove JavaScript protocol
      .replace(/on\w+=/gi, '') // Remove event handlers
      .replace(/[\x00-\x1F\x7F]/g, '') // Remove control characters
      .trim();
  }

  /**
   * Generate unique request ID for tracking
   */
  private generateRequestId(): string {
    const timestamp = Date.now().toString(36);
    const randomBytesValue = randomBytes(8).toString('hex');
    return `req_${timestamp}_${randomBytesValue}`;
  }

  /**
   * Create enhanced CORS middleware for production
   */
  createCorsMiddleware() {
    const config = this.config;
    return (_req: Request,  _res: Response,  _next: NextFunction): void => {
      const origin = req.headers.origin;
      const referer = req.headers.referer;
      const userAgent = req.headers['user-agent'];

      // Log CORS requests for security monitoring
      if (_origin) {
        logger.debug('CORS request', {
          origin,
          method: req.method,
          path: req.path,
          userAgent,
          ip: req.ip,
        });
      }

      // Block suspicious user agents
      if (this.isSuspiciousUserAgent(userAgent)) {
        logger.warn('Blocked suspicious user agent', {
          userAgent,
          ip: req.ip,
          origin,
          path: req.path,
        });
        res.status(403).json({
          error: 'Forbidden',
          message: 'Access denied',
          code: 'SUSPICIOUS_USER_AGENT',
        });
        return;
      }

      if (!origin) {
        // No origin header, check if this is a same-origin request
        const host = req.headers.host;
        if (host && !this.isSameOrigin(host, req)) {
          logger.warn('Cross-origin request without origin header', {
            host,
            method: req.method,
            path: req.path,
            ip: req.ip,
          });
        }
        next();
        return;
      }

      // Enhanced origin validation
      const validationResult = this.validateOrigin(origin, config.corsOrigin);

      if (!validationResult.allowed) {
        logger.warn('CORS origin not allowed', {
          origin,
          reason: validationResult.reason,
          method: req.method,
          path: req.path,
          ip: req.ip,
          userAgent,
        });

        // Don't reveal which origins are allowed
        res.status(403).json({
          error: 'Forbidden',
          message: 'Origin not allowed',
          code: 'CORS_ORIGIN_NOT_ALLOWED',
        });
        return;
      }

      // Set enhanced CORS headers
      res.setHeader('Access-Control-Allow-Origin', origin);
      res.setHeader('Access-Control-Allow-Methods', this.getAllowedMethods(req.path));
      res.setHeader(
        'Access-Control-Allow-Headers',
        'Content-Type, Authorization, X-API-Key, X-Request-ID, X-Tenant-ID, X-Client-Version'
      );
      res.setHeader('Access-Control-Allow-Credentials', 'true');
      res.setHeader('Access-Control-Max-Age', '86400'); // 24 hours

      // Additional security headers
      res.setHeader('Vary', 'Origin');
      res.setHeader(
        'Access-Control-Expose-Headers',
        'X-Request-ID, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset'
      );

      // Handle preflight requests with enhanced validation
      if (req.method === 'OPTIONS') {
        this.handlePreflightRequest(req, res);
        return;
      }

      // Add origin context for downstream middleware
      (req as unknown).origin = origin;

      next();
    };
  }

  /**
   * Enhanced origin validation
   */
  private validateOrigin(
    _origin: string, 
    _allowedOrigins: string[]
  ): { allowed: boolean; reason?: string } {
    // Check against exact matches
    if (allowedOrigins.includes(origin)) {
      return { allowed: true };
    }

    // Check wildcard patterns
    for (const allowedOrigin of allowedOrigins) {
      if (allowedOrigin === '*') {
        return { allowed: true };
      }

      if (allowedOrigin.includes('*')) {
        const pattern = allowedOrigin
          .replace(/\./g, '\\.') // Escape dots
          .replace(/\*/g, '.*'); // Convert wildcard to regex pattern
        const regex = new RegExp(`^${pattern}$`, 'i');

        if (regex.test(origin)) {
          return { allowed: true };
        }
      }
    }

    // Check for subdomain patterns
    const originParts = origin.split('.');
    if (originParts.length >= 2) {
      const subdomainPattern = `*.${String(originParts.slice(-2).join('.'))}`;
      for (const allowedOrigin of allowedOrigins) {
        if (allowedOrigin === subdomainPattern) {
          return { allowed: true };
        }
      }
    }

    return {
      allowed: false,
      reason: 'Origin not in allowed list',
    };
  }

  /**
   * Get allowed methods based on request path
   */
  private getAllowedMethods(_path: string): string {
    // Define method restrictions for sensitive endpoints
    const sensitivePaths = ['/api/admin', '/api/system', '/api/users', '/api/tenant'];

    const isSensitivePath = sensitivePaths.some((sensitivePath) => path.startsWith(sensitivePath));

    if (_isSensitivePath) {
      return 'GET, POST, PUT, DELETE, OPTIONS';
    }

    // Standard API endpoints
    if (path.startsWith('/api/')) {
      return 'GET, POST, PUT, DELETE, OPTIONS';
    }

    // Health and status endpoints
    if (path.startsWith('/health') || path.startsWith('/status')) {
      return 'GET, OPTIONS';
    }

    // Default
    return 'GET, POST, OPTIONS';
  }

  /**
   * Handle preflight requests with enhanced validation
   */
  private handlePreflightRequest(_req: Request,  _res: Response): void {
    const requestedMethod = req.headers['access-control-request-method'];
    const requestedHeaders = req.headers['access-control-request-headers'];

    // Validate requested method
    const allowedMethods = this.getAllowedMethods(req.path);
    if (requestedMethod && !allowedMethods.includes(requestedMethod)) {
      logger.warn('Invalid method in preflight request', {
        requestedMethod,
        allowedMethods,
        path: req.path,
        origin: req.headers.origin,
        ip: req.ip,
      });
      res.status(405).json({
        error: 'Method Not Allowed',
        message: `Method ${requestedMethod} not allowed for this endpoint`,
        code: 'METHOD_NOT_ALLOWED',
      });
      return;
    }

    // Validate requested headers
    if (_requestedHeaders) {
      const allowedHeaders = [
        'content-type',
        'authorization',
        'x-api-key',
        'x-request-id',
        'x-tenant-id',
        'x-client-version',
      ];

      const requestedHeaderList = requestedHeaders.split(',').map((h) => h.trim().toLowerCase());

      const invalidHeaders = requestedHeaderList.filter(
        (header) => !allowedHeaders.includes(header)
      );

      if (invalidHeaders.length > 0) {
        logger.warn('Invalid headers in preflight request', {
          invalidHeaders,
          requestedHeaders,
          path: req.path,
          origin: req.headers.origin,
          ip: req.ip,
        });
        res.status(400).json({
          error: 'Bad Request',
          message: `Headers not allowed: ${invalidHeaders.join(', ')}`,
          code: 'HEADERS_NOT_ALLOWED',
        });
        return;
      }
    }

    // Set additional preflight headers
    res.setHeader('Access-Control-Allow-Methods', allowedMethods);
    res.setHeader(
      'Access-Control-Allow-Headers',
      'Content-Type, Authorization, X-API-Key, X-Request-ID, X-Tenant-ID, X-Client-Version'
    );
    res.setHeader('Access-Control-Max-Age', '86400');

    res.status(200).end();
  }

  /**
   * Check if user agent is suspicious
   */
  private isSuspiciousUserAgent(userAgent?: string): boolean {
    if (!userAgent) return true; // No user agent is suspicious

    const suspiciousPatterns = [
      /bot/i,
      /crawler/i,
      /spider/i,
      /scraper/i,
      /curl/i,
      /wget/i,
      /python/i,
      /java/i,
      /go-http/i,
      /node/i,
      /http\.client/i,
      /okhttp/i,
      /requests/i,
      /postman/i,
      /insomnia/i,
      /swagger/i,
      /openapi/i,
    ];

    return suspiciousPatterns.some((pattern) => pattern.test(userAgent));
  }

  /**
   * Check if request is same origin
   */
  private isSameOrigin(_host: string,  _req: Request): boolean {
    // In production, you'd want to check against your actual domain
    const allowedHosts = ['localhost:3000', 'localhost:9090', '127.0.0.1:3000', '127.0.0.1:9090'];

    return allowedHosts.includes(host);
  }

  /**
   * Validate security configuration
   */
  validateConfiguration(): { valid: boolean; errors: string[] } {
    const errors: string[] = [];

    if (this.config.requireApiKey && !process.env.MCP_API_KEY) {
      errors.push(
        'MCP_API_KEY environment variable is required when API key validation is enabled'
      );
    }

    if (this.config.maxRequestSizeMb > 50) {
      errors.push('Maximum request size should not exceed 50MB for security reasons');
    }

    if (this.config.rateLimitMaxRequests > 10000 && this.config.rateLimitWindowMs < 60000) {
      errors.push('Rate limiting is too permissive for production');
    }

    if (this.config.corsOrigin.includes('*') && process.env.NODE_ENV === 'production') {
      errors.push('Wildcard CORS origin is not recommended for production');
    }

    return {
      valid: errors.length === 0,
      errors,
    };
  }
  /**
   * Request metadata middleware
   * Adds request ID and timing information using typed extensions
   */
  public addRequestMetadata(): (req: Request, res: Response, next: NextFunction) => void {
    return asTypedMiddleware(addRequestMetadata);
  }

  /**
   * Get request ID from extended request
   */
  public static getRequestId(_req: Request): string | undefined {
    return (req as ExtendedRequest).requestId;
  }

  /**
   * Set request ID on extended request
   */
  public static setRequestId(_req: Request,  _requestId: string): void {
    (req as ExtendedRequest).requestId = requestId;
  }
}

export default ProductionSecurityMiddleware;
