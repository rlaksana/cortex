/**
 * Role-Based Access Control (RBAC) Middleware
 *
 * Comprehensive RBAC implementation with scope isolation, role hierarchy,
 * permission checking, and audit logging for production security.
 *
 * @author Cortex Team
 * @version 2.0.1
 */

import type { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import type { ExtendedRequest } from '../types/express-extensions.js';
import { logger } from '../utils/logger.js';

export interface Role {
  id: string;
  name: string;
  description: string;
  permissions: Permission[];
  inherits?: string[]; // Parent role IDs for inheritance
  priority: number; // Higher number = higher priority
  isSystem: boolean; // System roles cannot be modified
}

export interface Permission {
  id: string;
  resource: string;
  action: string;
  scope?: string;
  conditions?: Record<string, unknown>;
}

export interface User {
  id: string;
  tenantId: string;
  username: string;
  email: string;
  roles: string[];
  permissions?: Permission[];
  metadata: {
    createdAt: Date;
    lastLogin?: Date;
    isActive: boolean;
    metadata: Record<string, unknown>;
  };
}

export interface Policy {
  id: string;
  name: string;
  description: string;
  effect: 'allow' | 'deny';
  resources: string[];
  actions: string[];
  conditions: Record<string, unknown>;
  priority: number;
  enabled: boolean;
}

export interface RBACConfig {
  enabled: boolean;
  jwtSecret: string;
  tokenExpiry: string;
  issuer: string;
  audience: string;
  defaultRole: string;
  strictMode: boolean;
  auditEnabled: boolean;
  cacheEnabled: boolean;
  cacheTTL: number;
  roleHierarchy: boolean;
  crossTenantAccess: boolean;
  adminBypass: boolean;
}

export interface AuthorizationResult {
  allowed: boolean;
  reason: string;
  requiredPermissions: string[];
  userPermissions: string[];
  policies?: Policy[];
  cacheHit?: boolean;
}

export class RBACMiddleware {
  private config: RBACConfig;
  private roles: Map<string, Role> = new Map();
  private permissions: Map<string, Permission> = new Map();
  private policies: Map<string, Policy> = new Map();
  private users: Map<string, User> = new Map();
  private cache: Map<string, AuthorizationResult> = new Map();

  constructor(config: RBACConfig) {
    this.config = config;
    this.initializeSystemRoles();
    this.initializeSystemPermissions();
    this.initializeSystemPolicies();
  }

  /**
   * Initialize system roles
   */
  private initializeSystemRoles(): void {
    const systemRoles: Role[] = [
      {
        id: 'super_admin',
        name: 'Super Administrator',
        description: 'Full system access with all permissions',
        permissions: ['*'],
        priority: 1000,
        isSystem: true,
      },
      {
        id: 'tenant_admin',
        name: 'Tenant Administrator',
        description: 'Full tenant access with tenant-scoped permissions',
        permissions: ['tenant:*', 'users:*', 'memory:*', 'analytics:*', 'backup:*'],
        priority: 800,
        isSystem: true,
      },
      {
        id: 'developer',
        name: 'Developer',
        description: 'Development and testing permissions',
        permissions: [
          'memory:read',
          'memory:write',
          'memory:delete',
          'analytics:read',
          'tools:execute',
        ],
        priority: 600,
        isSystem: true,
      },
      {
        id: 'analyst',
        name: 'Analyst',
        description: 'Read-only access for data analysis',
        permissions: ['memory:read', 'analytics:read', 'reports:read'],
        priority: 400,
        isSystem: true,
      },
      {
        id: 'viewer',
        name: 'Viewer',
        description: 'Basic read-only access',
        permissions: ['memory:read', 'analytics:read'],
        priority: 200,
        isSystem: true,
      },
      {
        id: 'guest',
        name: 'Guest',
        description: 'Limited access for unauthenticated users',
        permissions: ['memory:public_read', 'status:read'],
        priority: 100,
        isSystem: true,
      },
    ];

    systemRoles.forEach((role) => this.roles.set(role.id, role));
  }

  /**
   * Initialize system permissions
   */
  private initializeSystemPermissions(): void {
    const systemPermissions: Permission[] = [
      // Memory operations
      { id: 'memory:read', resource: 'memory', action: 'read' },
      { id: 'memory:write', resource: 'memory', action: 'write' },
      { id: 'memory:delete', resource: 'memory', action: 'delete' },
      { id: 'memory:public_read', resource: 'memory', action: 'public_read' },

      // User management
      { id: 'users:read', resource: 'users', action: 'read' },
      { id: 'users:write', resource: 'users', action: 'write' },
      { id: 'users:delete', resource: 'users', action: 'delete' },

      // Tenant management
      { id: 'tenant:read', resource: 'tenant', action: 'read' },
      { id: 'tenant:write', resource: 'tenant', action: 'write' },
      { id: 'tenant:*', resource: 'tenant', action: '*' },

      // Analytics and reporting
      { id: 'analytics:read', resource: 'analytics', action: 'read' },
      { id: 'analytics:write', resource: 'analytics', action: 'write' },
      { id: 'reports:read', resource: 'reports', action: 'read' },

      // Tools and utilities
      { id: 'tools:execute', resource: 'tools', action: 'execute' },
      { id: 'tools:configure', resource: 'tools', action: 'configure' },

      // System administration
      { id: 'system:read', resource: 'system', action: 'read' },
      { id: 'system:write', resource: 'system', action: 'write' },
      { id: 'system:admin', resource: 'system', action: 'admin' },

      // Backup and restore
      { id: 'backup:read', resource: 'backup', action: 'read' },
      { id: 'backup:write', resource: 'backup', action: 'write' },
      { id: 'backup:execute', resource: 'backup', action: 'execute' },

      // Status and health
      { id: 'status:read', resource: 'status', action: 'read' },

      // Wildcard permissions
      { id: '*', resource: '*', action: '*' },
    ];

    systemPermissions.forEach((permission) => {
      this.permissions.set(permission.id, permission);
    });
  }

  /**
   * Initialize system policies
   */
  private initializeSystemPolicies(): void {
    const systemPolicies: Policy[] = [
      {
        id: 'deny_cross_tenant_access',
        name: 'Deny Cross-Tenant Access',
        description: "Deny access to resources outside user's tenant",
        effect: 'deny',
        resources: ['*'],
        actions: ['*'],
        conditions: {
          tenantMatch: false,
        },
        priority: 1000,
        enabled: true,
      },
      {
        id: 'require_https',
        name: 'Require HTTPS',
        description: 'Require HTTPS for all requests',
        effect: 'deny',
        resources: ['*'],
        actions: ['*'],
        conditions: {
          protocol: 'http',
        },
        priority: 900,
        enabled: true,
      },
      {
        id: 'rate_limit_exempt',
        name: 'Rate Limit Exemption',
        description: 'Exempt administrators from rate limiting',
        effect: 'allow',
        resources: ['*'],
        actions: ['*'],
        conditions: {
          hasRole: ['super_admin', 'tenant_admin'],
        },
        priority: 800,
        enabled: true,
      },
      {
        id: 'audit_sensitive_operations',
        name: 'Audit Sensitive Operations',
        description: 'Require audit logging for sensitive operations',
        effect: 'allow',
        resources: ['users', 'tenant', 'system'],
        actions: ['write', 'delete', 'admin'],
        conditions: {
          auditRequired: true,
        },
        priority: 700,
        enabled: true,
      },
    ];

    systemPolicies.forEach((policy) => {
      this.policies.set(policy.id, policy);
    });
  }

  /**
   * Create authentication middleware
   */
  createAuthMiddleware(): (req: Request, res: Response, next: NextFunction) => void {
    return (_req: ExtendedRequest,  _res: Response,  _next: NextFunction): void => {
      if (!this.config.enabled) {
        next();
        return;
      }

      try {
        const token = this.extractToken(req);
        if (!token) {
          this.sendAuthError(res, 'Missing authentication token', 401);
          return;
        }

        const user = this.verifyToken(token);
        if (!user) {
          this.sendAuthError(res, 'Invalid or expired token', 401);
          return;
        }

        if (!user.metadata.isActive) {
          this.sendAuthError(res, 'User account is inactive', 403);
          return;
        }

        // Attach user to request
        req.user = user;
        req.userPermissions = this.getUserPermissions(user);

        this.logAuditEvent('authentication', user, {
          success: true,
          ip: req.ip,
          userAgent: req.headers['user-agent'],
          path: req.path,
        });

        next();
      } catch (error) {
        logger.error('Authentication error', {
          error: error instanceof Error ? error.message : 'Unknown error',
          path: req.path,
          ip: req.ip,
        });

        this.sendAuthError(res, 'Authentication failed', 401);
      }
    };
  }

  /**
   * Create authorization middleware
   */
  createAuthzMiddleware(
    _requiredPermissions: string[]
  ): (req: Request, res: Response, next: NextFunction) => void {
    return (_req: ExtendedRequest,  _res: Response,  _next: NextFunction): void => {
      if (!this.config.enabled) {
        next();
        return;
      }

      const user = req.user;
      if (!user) {
        this.sendAuthError(res, 'User not authenticated', 401);
        return;
      }

      try {
        const resource = this.extractResource(req);
        const action = this.extractAction(req);
        const scope = this.extractScope(req);

        const authResult = this.authorize(user, resource, action, {
          scope,
          path: req.path,
          method: req.method,
          tenantId: user.tenantId,
          query: req.query,
          body: req.body,
        });

        if (!authResult.allowed) {
          this.logAuditEvent('authorization', user, {
            success: false,
            resource,
            action,
            scope,
            reason: authResult.reason,
            requiredPermissions,
            userPermissions: authResult.userPermissions,
            ip: req.ip,
            path: req.path,
          });

          res.status(403).json({
            error: 'Forbidden',
            message: authResult.reason,
            code: 'INSUFFICIENT_PERMISSIONS',
            requiredPermissions,
            userPermissions: authResult.userPermissions,
          });
          return;
        }

        this.logAuditEvent('authorization', user, {
          success: true,
          resource,
          action,
          scope,
          policies: authResult.policies,
          ip: req.ip,
          path: req.path,
        });

        req.authzResult = authResult;
        next();
      } catch (error) {
        logger.error('Authorization error', {
          error: error instanceof Error ? error.message : 'Unknown error',
          userId: user.id,
          path: req.path,
        });

        res.status(500).json({
          error: 'Internal Server Error',
          message: 'Authorization check failed',
          code: 'AUTHORIZATION_ERROR',
        });
      }
    };
  }

  /**
   * Verify JWT token and extract user
   */
  private verifyToken(_token: string): User | null {
    try {
      const decoded = jwt.verify(token, this.config.jwtSecret, {
        issuer: this.config.issuer,
        audience: this.config.audience,
      }) as unknown;

      // Get user from cache or database
      let user = this.users.get(decoded.sub);
      if (!user) {
        // In production, this would query the database
        user = this.createMockUser(decoded.sub, decoded.tenantId);
        this.users.set(user.id, user);
      }

      return user;
    } catch (error) {
      logger.debug('Token verification failed', {
        error: error instanceof Error ? error.message : 'Unknown error',
      });
      return null;
    }
  }

  /**
   * Authorize user action
   */
  authorize(
    _user: User, 
    _resource: string, 
    _action: string, 
    context: unknown = {}
  ): AuthorizationResult {
    const cacheKey = `${user.id}:${resource}:${action}:${JSON.stringify(context)}`;

    // Check cache first
    if (this.config.cacheEnabled) {
      const cached = this.cache.get(cacheKey);
      if (_cached) {
        return { ...cached, cacheHit: true };
      }
    }

    const userPermissions = this.getUserPermissions(user);
    const requiredPermissions = [`${resource}:${action}`, `${resource}:*`, '*'];

    // Check direct permissions
    const hasDirectPermission = requiredPermissions.some((perm) =>
      userPermissions.some((userPerm) => this.matchesPermission(userPerm, perm))
    );

    // Check policies
    const applicablePolicies = this.getApplicablePolicies(user, resource, action, context);
    const policyResult = this.evaluatePolicies(applicablePolicies, context);

    // Check cross-tenant access
    if (!this.config.crossTenantAccess && context.tenantId && context.tenantId !== user.tenantId) {
      const result: AuthorizationResult = {
        allowed: false,
        reason: 'Cross-tenant access is not allowed',
        requiredPermissions,
        userPermissions,
        policies: applicablePolicies,
      };

      if (this.config.cacheEnabled) {
        this.cache.set(cacheKey, result, { ttl: this.config.cacheTTL });
      }

      return result;
    }

    // Admin bypass
    if (this.config.adminBypass && user.roles.includes('super_admin')) {
      const result: AuthorizationResult = {
        allowed: true,
        reason: 'Super admin bypass',
        requiredPermissions,
        userPermissions,
        policies: applicablePolicies,
      };

      if (this.config.cacheEnabled) {
        this.cache.set(cacheKey, result, { ttl: this.config.cacheTTL });
      }

      return result;
    }

    const allowed = hasDirectPermission && policyResult.allowed;

    const result: AuthorizationResult = {
      allowed,
      reason: allowed ? 'Access granted' : policyResult.reason || 'Insufficient permissions',
      requiredPermissions,
      userPermissions,
      policies: applicablePolicies,
    };

    if (this.config.cacheEnabled) {
      this.cache.set(cacheKey, result, { ttl: this.config.cacheTTL });
    }

    return result;
  }

  /**
   * Get user permissions including inherited permissions
   */
  private getUserPermissions(_user: User): string[] {
    const permissions = new Set<string>();

    user.roles.forEach((roleId) => {
      const role = this.roles.get(roleId);
      if (_role) {
        this.addRolePermissions(role, permissions);
      }
    });

    return Array.from(permissions);
  }

  /**
   * Add role permissions including inherited permissions
   */
  private addRolePermissions(_role: Role,  _permissions: Set<string>): void {
    role.permissions.forEach((perm) => permissions.add(perm));

    // Add inherited permissions
    if (role.inherits && this.config.roleHierarchy) {
      role.inherits.forEach((parentRoleId) => {
        const parentRole = this.roles.get(parentRoleId);
        if (_parentRole) {
          this.addRolePermissions(parentRole, permissions);
        }
      });
    }
  }

  /**
   * Check if permission matches pattern
   */
  private matchesPermission(_userPerm: string,  _requiredPerm: string): boolean {
    if (userPerm === '*') return true;
    if (requiredPerm === '*') return true;
    if (userPerm === requiredPerm) return true;

    // Handle wildcard matching
    const userParts = userPerm.split(':');
    const requiredParts = requiredPerm.split(':');

    if (userParts[0] === '*' && userParts[1] === '*') return true;
    if (userParts[0] === '*' && userParts[1] === requiredParts[1]) return true;
    if (userParts[0] === requiredParts[0] && userParts[1] === '*') return true;

    return false;
  }

  /**
   * Get applicable policies for user
   */
  private getApplicablePolicies(
    _user: User, 
    _resource: string, 
    _action: string, 
    context: unknown
  ): Policy[] {
    return Array.from(this.policies.values())
      .filter((policy) => policy.enabled)
      .filter((policy) => this.matchesResourcePolicy(policy, resource, action))
      .sort((a,  _b) => b.priority - a.priority);
  }

  /**
   * Check if policy matches resource and action
   */
  private matchesResourcePolicy(_policy: Policy,  _resource: string,  _action: string): boolean {
    const matchesResource = policy.resources.includes('*') || policy.resources.includes(resource);
    const matchesAction = policy.actions.includes('*') || policy.actions.includes(action);
    return matchesResource && matchesAction;
  }

  /**
   * Evaluate policies
   */
  private evaluatePolicies(
    _policies: Policy[], 
    context: unknown
  ): { allowed: boolean; reason?: string } {
    for (const policy of policies) {
      const conditionsMet = this.evaluateConditions(policy.conditions, context);

      if (_conditionsMet) {
        return {
          allowed: policy.effect === 'allow',
          reason: policy.effect === 'deny' ? policy.description : undefined,
        };
      }
    }

    return { allowed: true };
  }

  /**
   * Evaluate policy conditions
   */
  private evaluateConditions(_conditions: Record<string,  unknown>,  context: unknown): boolean {
    for (const [key, value] of Object.entries(conditions)) {
      switch (_key) {
        case 'tenantMatch':
          if (value === false && context.tenantId && context.tenantId !== context.userTenantId) {
            return true;
          }
          break;
        case 'protocol':
          if (context.protocol && context.protocol === value) {
            return true;
          }
          break;
        case 'hasRole':
          if (
            Array.isArray(value) &&
            context.userRoles &&
            value.some((role) => context.userRoles.includes(role))
          ) {
            return true;
          }
          break;
        case 'auditRequired':
          return true;
        default:
          logger.debug('Unknown policy condition', { key, value });
      }
    }
    return false;
  }

  /**
   * Extract token from request
   */
  private extractToken(_req: Request): string | null {
    const authHeader = req.headers.authorization;
    if (authHeader && authHeader.startsWith('Bearer ')) {
      return authHeader.substring(7);
    }

    // Check cookie
    if (req.cookies && req.cookies.token) {
      return req.cookies.token;
    }

    // Check query parameter (not recommended for production)
    if (req.query.token && typeof req.query.token === 'string') {
      return req.query.token;
    }

    return null;
  }

  /**
   * Extract resource from request
   */
  private extractResource(_req: Request): string {
    const path = req.path;

    // Extract resource from path patterns
    if (path.startsWith('/api/memory/')) return 'memory';
    if (path.startsWith('/api/users/')) return 'users';
    if (path.startsWith('/api/tenant/')) return 'tenant';
    if (path.startsWith('/api/analytics/')) return 'analytics';
    if (path.startsWith('/api/tools/')) return 'tools';
    if (path.startsWith('/api/system/')) return 'system';
    if (path.startsWith('/api/backup/')) return 'backup';
    if (path.startsWith('/api/status/')) return 'status';
    if (path.startsWith('/api/reports/')) return 'reports';

    return 'unknown';
  }

  /**
   * Extract action from request
   */
  private extractAction(_req: Request): string {
    const method = req.method.toLowerCase();

    // Map HTTP methods to actions
    switch (_method) {
      case 'get':
        return 'read';
      case 'post':
        return 'write';
      case 'put':
        return 'write';
      case 'patch':
        return 'write';
      case 'delete':
        return 'delete';
      default:
        return method;
    }
  }

  /**
   * Extract scope from request
   */
  private extractScope(_req: Request): string {
    const tenantId = (req as unknown).tenantId || (req as unknown).user?.tenantId;
    const isPublic = req.path.includes('/public/');

    if (isPublic) return 'public';
    if (tenantId) return `tenant:${tenantId}`;
    return 'system';
  }

  /**
   * Send authentication error
   */
  private sendAuthError(_res: Response,  message: string,  _statusCode: number): void {
    res.status(statusCode).json({
      error: statusCode === 401 ? 'Unauthorized' : 'Forbidden',
      message,
      code: statusCode === 401 ? 'AUTHENTICATION_FAILED' : 'AUTHORIZATION_FAILED',
    });
  }

  /**
   * Log audit event
   */
  private logAuditEvent(
    type: 'authentication' | 'authorization', 
    _user: User, 
    _details: unknown
  ): void {
    if (!this.config.auditEnabled) return;

    logger.info(`RBAC ${type} event`, {
      type,
      userId: user.id,
      tenantId: user.tenantId,
      username: user.username,
      roles: user.roles,
      ...details,
    });
  }

  /**
   * Create mock user for testing
   */
  private createMockUser(_userId: string,  _tenantId: string): User {
    return {
      id: userId,
      tenantId,
      username: `user_${userId}`,
      email: `user_${userId}@example.com`,
      roles: [this.config.defaultRole],
      metadata: {
        createdAt: new Date(),
        isActive: true,
        metadata: {},
      },
    };
  }

  /**
   * Health check
   */
  healthCheck(): Promise<{ healthy: boolean; details: unknown }> {
    return {
      healthy: true,
      details: {
        enabled: this.config.enabled,
        rolesCount: this.roles.size,
        permissionsCount: this.permissions.size,
        policiesCount: this.policies.size,
        cacheSize: this.cache.size,
        strictMode: this.config.strictMode,
        roleHierarchy: this.config.roleHierarchy,
      },
    };
  }

  /**
   * Get statistics
   */
  getStatistics(): unknown {
    return {
      enabled: this.config.enabled,
      roles: this.roles.size,
      permissions: this.permissions.size,
      policies: this.policies.size,
      users: this.users.size,
      cacheSize: this.cache.size,
      config: {
        strictMode: this.config.strictMode,
        auditEnabled: this.config.auditEnabled,
        cacheEnabled: this.config.cacheEnabled,
        roleHierarchy: this.config.roleHierarchy,
      },
    };
  }

  /**
   * Clear cache
   */
  clearCache(): void {
    this.cache.clear();
    logger.info('RBAC cache cleared');
  }
}

export default RBACMiddleware;
