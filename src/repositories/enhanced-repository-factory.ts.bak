/**
 * Enhanced Repository Factory with Constructor Injection
 *
 * This refactored version eliminates tight coupling to specific database
 * implementations and provides a clean, testable abstraction layer.
 *
 * Key Improvements:
 * - Constructor injection with interface-based design
 * - Database abstraction layer for multiple providers
 * - Connection pooling and health monitoring
 * - Enhanced error handling and recovery
 * - Performance monitoring and metrics
 *
 * @author MCP Cortex Team
 * @version 2.1.0
 * @since 2025
 */

// Simple logger adapter to provide expected interface
const logger = {
  info: (message: string, meta?: unknown) => {
    console.log(`[INFO] ${message}`, meta || '');
  },
  error: (message: string, meta?: unknown) => {
    console.error(`[ERROR] ${message}`, meta || '');
  },
  warn: (message: string, meta?: unknown) => {
    console.warn(`[WARN] ${message}`, meta || '');
  },
  debug: (message: string, meta?: unknown) => {
    console.debug(`[DEBUG] ${message}`, meta || '');
  },
};
import { Injectable } from '../di/enhanced-decorators.js';
import { ServiceLifetime } from '../di/enhanced-di-container.js';

// ===== DATABASE PROVIDER INTERFACES =====

export interface IDatabaseProvider {
  name: string;
  type: 'vector' | 'document' | 'graph' | 'relational';
  connect(): Promise<void>;
  disconnect(): Promise<void>;
  isConnected(): boolean;
  getHealthStatus(): Promise<ProviderHealthStatus>;
  createRepository<T>(config: RepositoryConfig<T>): Promise<IRepository<T>>;
  executeQuery<T>(query: DatabaseQuery): Promise<DatabaseResult<T>>;
}

export interface IRepository<T> {
  create(entity: T): Promise<T>;
  read(id: string): Promise<T | null>;
  update(id: string, updates: Partial<T>): Promise<T>;
  delete(id: string): Promise<boolean>;
  find(_criteria: SearchCriteria<T>): Promise<T[]>;
  count(criteria?: SearchCriteria<T>): Promise<number>;
  exists(id: string): Promise<boolean>;
  healthCheck(): Promise<boolean>;
}

export interface IConnectionPool {
  getConnection(): Promise<IDatabaseConnection>;
  releaseConnection(connection: IDatabaseConnection): Promise<void>;
  closeAll(): Promise<void>;
  getPoolStats(): PoolStats;
}

export interface IDatabaseConnection {
  id: string;
  isActive: boolean;
  createdAt: Date;
  lastUsedAt: Date;
  execute<T>(query: DatabaseQuery): Promise<DatabaseResult<T>>;
  close(): Promise<void>;
}

// ===== CONFIGURATION TYPES =====

export interface RepositoryFactoryConfig {
  defaultProvider: string;
  providers: ProviderConfig[];
  connectionPool: {
    maxConnections: number;
    minConnections: number;
    idleTimeout: number;
    acquireTimeout: number;
  };
  healthChecks: {
    enabled: boolean;
    interval: number;
    timeout: number;
    retries: number;
  };
  performance: {
    enableMetrics: boolean;
    slowQueryThreshold: number;
    enableQueryLogging: boolean;
  };
  circuitBreaker: {
    enabled: boolean;
    failureThreshold: number;
    recoveryTimeout: number;
    monitoringPeriod: number;
  };
}

export interface ProviderConfig {
  name: string;
  type: 'vector' | 'document' | 'graph' | 'relational';
  connection: ConnectionConfig;
  capabilities: ProviderCapabilities;
  priority: number;
  failover: boolean;
}

export interface ConnectionConfig {
  host: string;
  port: number;
  database?: string;
  username?: string;
  password?: string;
  ssl?: boolean;
  timeout?: number;
  retryAttempts?: number;
  additionalOptions?: Record<string, unknown>;
}

export interface ProviderCapabilities {
  supportedOperations: string[];
  maxConnections: number;
  supportsTransactions: boolean;
  supportsIndexing: boolean;
  vectorDimensions?: number;
  supportedDataTypes: string[];
}

export interface RepositoryConfig<T> {
  name: string;
  type: string;
  schema?: Record<string, unknown>;
  indexes?: IndexConfig[];
  TTL?: number;
  sharding?: ShardingConfig;
}

export interface IndexConfig {
  name: string;
  fields: string[];
  type: 'vector' | 'scalar' | 'composite';
  options?: Record<string, unknown>;
}

export interface ShardingConfig {
  enabled: boolean;
  shardKey: string;
  shardCount: number;
}

// ===== QUERY AND RESULT TYPES =====

export interface DatabaseQuery {
  type: 'select' | 'insert' | 'update' | 'delete' | 'custom';
  collection?: string;
  filter?: Record<string, unknown>;
  sort?: Record<string, 1 | -1>;
  limit?: number;
  offset?: number;
  data?: unknown;
  vector?: number[];
  vectorField?: string;
  limitScore?: number;
}

export interface DatabaseResult<T> {
  data: T[];
  metadata: {
    totalCount?: number;
    executionTime: number;
    cacheHit?: boolean;
    provider: string;
    query: DatabaseQuery;
  };
  errors?: DatabaseError[];
}

export interface DatabaseError {
  code: string;
  message: string;
  details?: unknown;
  retryable: boolean;
}

export interface SearchCriteria<T> {
  where?: Partial<T>;
  orderBy?: Record<keyof T, 'asc' | 'desc'>;
  limit?: number;
  offset?: number;
  include?: (keyof T)[];
  exclude?: (keyof T)[];
}

// ===== HEALTH AND MONITORING TYPES =====

export interface ProviderHealthStatus {
  provider: string;
  status: 'healthy' | 'degraded' | 'unhealthy' | 'unknown';
  connected: boolean;
  responseTime: number;
  errorRate: number;
  lastCheck: Date;
  issues: string[];
}

export interface PoolStats {
  totalConnections: number;
  activeConnections: number;
  idleConnections: number;
  waitingRequests: number;
  averageWaitTime: number;
  connectionErrors: number;
}

export interface FactoryHealthStatus {
  status: 'healthy' | 'degraded' | 'unhealthy';
  providers: ProviderHealthStatus[];
  connectionPools: Record<string, PoolStats>;
  performance: {
    totalQueries: number;
    averageResponseTime: number;
    errorRate: number;
    slowQueries: number;
  };
  lastHealthCheck: Date;
}

// ===== ENHANCED REPOSITORY FACTORY =====

@Injectable({
  lifetime: ServiceLifetime.SINGLETON,
  tags: ['core', 'database', 'repository'],
})
export class EnhancedRepositoryFactory {
  private providers = new Map<string, IDatabaseProvider>();
  private repositories = new Map<string, IRepository<unknown>>();
  private connectionPools = new Map<string, IConnectionPool>();
  private healthMonitor: HealthMonitor;
  private circuitBreakers = new Map<string, CircuitBreaker>();
  private config: RepositoryFactoryConfig;

  constructor(
    private readonly providerFactories: Map<string,  () => IDatabaseProvider>,

    private readonly connectionPoolFactory: (config: unknown) => IConnectionPool,
    private readonly configService: unknown,

    private readonly performanceMonitor: unknown,

    config?: Partial<RepositoryFactoryConfig>
  ) {
    this.config = this.mergeConfiguration(config);
    this.healthMonitor = new HealthMonitor(this.config.healthChecks);
  }

  /**
   * Initialize the enhanced repository factory
   */
  public async initialize(): Promise<void> {
    try {
      logger.info('Initializing Enhanced Repository Factory...');

      // Initialize all configured providers
      await this.initializeProviders();

      // Setup connection pools
      await this.initializeConnectionPools();

      // Start health monitoring
      this.healthMonitor.start(this.providers);

      // Initialize circuit breakers
      this.initializeCircuitBreakers();

      logger.info('Enhanced Repository Factory initialized successfully');
    } catch (error) {
      logger.error('Failed to initialize Enhanced Repository Factory:', error);
      throw error;
    }
  }

  /**
   * Create a repository with enhanced configuration and monitoring
   */
  public async createRepository<T>(
    name: string,
    config: RepositoryConfig<T>,
    providerName?: string
  ): Promise<IRepository<T>> {
    const cacheKey = `${name}:${providerName || this.config.defaultProvider}`;

    // Check if repository already exists
    if (this.repositories.has(cacheKey)) {
      return this.repositories.get(cacheKey) as IRepository<T>;
    }

    try {
      const provider = this.getProvider(providerName || this.config.defaultProvider);
      const circuitBreaker = this.circuitBreakers.get(provider.name);

      const repository = await this.createRepositoryWithMonitoring<T>(
        provider,
        config,
        circuitBreaker
      );

      this.repositories.set(cacheKey, repository);

      logger.info(`Repository created: ${name} using provider: ${provider.name}`);
      return repository;
    } catch (error) {
      logger.error(`Failed to create repository: ${name}`, error);
      throw new RepositoryCreationError(name, error as Error);
    }
  }

  /**
   * Get an existing repository
   */
  public getRepository<T>(name: string, providerName?: string): IRepository<T> | null {
    const cacheKey = `${name}:${providerName || this.config.defaultProvider}`;
    return this.repositories.get(cacheKey) as IRepository<T> | null;
  }

  /**
   * Execute a query with enhanced error handling and monitoring
   */
  public async executeQuery<T>(
    query: DatabaseQuery,
    providerName?: string
  ): Promise<DatabaseResult<T>> {
    const provider = this.getProvider(providerName || this.config.defaultProvider);
    const circuitBreaker = this.circuitBreakers.get(provider.name);

    const executeWithCircuitBreaker = async () => {
      if (circuitBreaker && circuitBreaker.isOpen()) {
        throw new CircuitBreakerOpenError(provider.name);
      }

      const startTime = Date.now();
      try {
        const result = await provider.executeQuery<T>(query);

        if (_circuitBreaker) {
          circuitBreaker.recordSuccess();
        }

        if (this.config.performance.enableMetrics) {
          this.performanceMonitor.recordQuery(
            provider.name,
            query.type,
            Date.now() - startTime,
            result.metadata.executionTime
          );
        }

        if (this.config.performance.enableQueryLogging) {
          logger.debug(`Query executed on ${provider.name}:`, {
            type: query.type,
            executionTime: result.metadata.executionTime,
            resultCount: result.data.length,
          });
        }

        return result;
      } catch (error) {
        if (_circuitBreaker) {
          circuitBreaker.recordFailure();
        }

        throw error;
      }
    };

    return this.withRetry(executeWithCircuitBreaker, provider.name);
  }

  /**
   * Get comprehensive health status
   */
  public async getHealthStatus(): Promise<FactoryHealthStatus> {
    const providerStatuses = await Promise.all(
      Array.from(this.providers.values()).map((provider) => provider.getHealthStatus())
    );

    const poolStats: Record<string, PoolStats> = {};
    for (const [name,  pool] of this.connectionPools) {
      poolStats[name] = pool.getPoolStats();
    }

    const performance = this.performanceMonitor.getRepositoryMetrics();

    return {
      status: this.calculateFactoryHealth(providerStatuses, performance),
      providers: providerStatuses,
      connectionPools: poolStats,
      performance,
      lastHealthCheck: new Date(),
    };
  }

  /**
   * Failover to alternative provider
   */
  public async failover(fromProvider: string, toProvider?: string): Promise<void> {
    const sourceProvider = this.providers.get(fromProvider);
    if (!sourceProvider) {
      throw new Error(`Provider not found: ${fromProvider}`);
    }

    const targetName = toProvider || this.findAlternativeProvider(fromProvider);
    const targetProvider = this.providers.get(targetName);

    if (!targetProvider) {
      throw new Error(`No alternative provider available for: ${fromProvider}`);
    }

    logger.info(`Initiating failover from ${fromProvider} to ${targetName}`);

    // Migrate active connections
    await this.migrateConnections(fromProvider, targetName);

    // Update circuit breaker status
    const sourceCircuitBreaker = this.circuitBreakers.get(fromProvider);
    if (_sourceCircuitBreaker) {
      sourceCircuitBreaker.forceOpen();
    }

    logger.info(`Failover completed: ${fromProvider} -> ${targetName}`);
  }

  /**
   * Dispose of the factory and cleanup resources
   */
  public async dispose(): Promise<void> {
    logger.info('Disposing Enhanced Repository Factory...');

    // Stop health monitoring
    this.healthMonitor.stop();

    // Close all connection pools
    const closePromises = Array.from(this.connectionPools.values()).map((pool) => pool.closeAll());
    await Promise.all(closePromises);

    // Disconnect all providers
    const disconnectPromises = Array.from(this.providers.values()).map((provider) =>
      provider.disconnect()
    );
    await Promise.all(disconnectPromises);

    // Clear caches
    this.providers.clear();
    this.repositories.clear();
    this.connectionPools.clear();
    this.circuitBreakers.clear();

    logger.info('Enhanced Repository Factory disposed');
  }

  // ===== PRIVATE METHODS =====

  private mergeConfiguration(config?: Partial<RepositoryFactoryConfig>): RepositoryFactoryConfig {
    return {
      defaultProvider: 'qdrant',
      providers: [],
      connectionPool: {
        maxConnections: 20,
        minConnections: 5,
        idleTimeout: 30000,
        acquireTimeout: 5000,
      },
      healthChecks: {
        enabled: true,
        interval: 30000,
        timeout: 5000,
        retries: 3,
      },
      performance: {
        enableMetrics: true,
        slowQueryThreshold: 1000,
        enableQueryLogging: false,
      },
      circuitBreaker: {
        enabled: true,
        failureThreshold: 5,
        recoveryTimeout: 60000,
        monitoringPeriod: 300000,
      },
      ...config,
    };
  }

  private async initializeProviders(): Promise<void> {
    for (const [name,  factory] of this.providerFactories) {
      try {
        const provider = factory();
        await provider.connect();
        this.providers.set(name, provider);

        logger.info(`Provider initialized: ${name}`);
      } catch (error) {
        logger.error(`Failed to initialize provider: ${name}`, error);
        if (name === this.config.defaultProvider) {
          throw error;
        }
      }
    }
  }

  private async initializeConnectionPools(): Promise<void> {
    for (const [name,  provider] of this.providers) {
      const poolConfig = {
        ...this.config.connectionPool,
        provider: name,
      };

      const pool = this.connectionPoolFactory(poolConfig);
      this.connectionPools.set(name, pool);

      logger.info(`Connection pool initialized for provider: ${name}`);
    }
  }

  private initializeCircuitBreakers(): void {
    if (!this.config.circuitBreaker.enabled) {
      return;
    }

    for (const [name,  provider] of this.providers) {
      const circuitBreaker = new CircuitBreaker({
        failureThreshold: this.config.circuitBreaker.failureThreshold,
        recoveryTimeout: this.config.circuitBreaker.recoveryTimeout,
        name,
      });

      this.circuitBreakers.set(name, circuitBreaker);
    }
  }

  private getProvider(_name: string): IDatabaseProvider {
    const provider = this.providers.get(name);
    if (!provider) {
      throw new Error(`Provider not found: ${name}`);
    }
    return provider;
  }

  private async createRepositoryWithMonitoring<T>(
    provider: IDatabaseProvider,
    config: RepositoryConfig<T>,
    circuitBreaker?: CircuitBreaker
  ): Promise<IRepository<T>> {
    const repository = await provider.createRepository<T>(config);

    // Wrap repository methods with monitoring and circuit breaker
    return new MonitoredRepository<T>(
      repository,
      provider.name,
      circuitBreaker,
      this.performanceMonitor
    );
  }

  private async withRetry<T>(
    operation: () => Promise<T>,
    providerName: string,
    maxRetries: number = 3
  ): Promise<T> {
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        if (attempt === maxRetries || !this.isRetryableError(error)) {
          throw error;
        }

        const delay = Math.pow(2, attempt) * 1000; // Exponential backoff
        logger.warn(`Retrying operation on ${providerName} (attempt ${String(attempt + 1)}/${maxRetries})`);
        await this.sleep(delay);
      }
    }

    throw new Error(`Operation failed after ${maxRetries} retries`);
  }

  private isRetryableError(error: unknown): boolean {
    const retryableErrors = [
      'TIMEOUT',
      'CONNECTION_ERROR',
      'SERVICE_UNAVAILABLE',
      'RATE_LIMIT_EXCEEDED',
    ];

    return (
      retryableErrors.includes(error.code) ||
      (error instanceof Error &&
        (error.message.includes('timeout') ||
          error.message.includes('connection') ||
          error.message.includes('unavailable')))
    );
  }

  private async sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  private calculateFactoryHealth(
    _providerStatuses: ProviderHealthStatus[], 
    _performance: unknown
  ): 'healthy' | 'degraded' | 'unhealthy' {
    const unhealthyProviders = providerStatuses.filter((p) => p.status === 'unhealthy').length;
    const degradedProviders = providerStatuses.filter((p) => p.status === 'degraded').length;

    if (unhealthyProviders > 0 || performance.errorRate > 0.1) {
      return 'unhealthy';
    }

    if (degradedProviders > 0 || performance.errorRate > 0.05) {
      return 'degraded';
    }

    return 'healthy';
  }

  private findAlternativeProvider(_excludeProvider: string): string {
    for (const [name,  provider] of this.providers) {
      if (name !== excludeProvider) {
        return name;
      }
    }
    throw new Error('No alternative provider available');
  }

  private async migrateConnections(fromProvider: string, toProvider: string): Promise<void> {
    // Implementation would depend on specific provider capabilities
    // This is a placeholder for connection migration logic
    logger.info(`Migrating connections from ${fromProvider} to ${toProvider}`);
  }
}

// ===== SUPPORTING CLASSES =====

class MonitoredRepository<T> implements IRepository<T> {
  constructor(
    private readonly baseRepository: IRepository<T>, 
    private readonly providerName: string, 
    private readonly circuitBreaker?: CircuitBreaker, 
    private readonly performanceMonitor?: unknown
  ) {}

 create(entity: T): Promise<T> {
    return this.withMonitoring('create',  () => this.baseRepository.create(entity));
  }

 read(id: string): Promise<T | null> {
    return this.withMonitoring('read',  () => this.baseRepository.read(id));
  }

 update(id: string, updates: Partial<T>): Promise<T> {
    return this.withMonitoring('update',  () => this.baseRepository.update(id, updates));
  }

 delete(id: string): Promise<boolean> {
    return this.withMonitoring('delete',  () => this.baseRepository.delete(id));
  }

 find(_criteria: SearchCriteria<T>): Promise<T[]> {
    return this.withMonitoring('find',  () => this.baseRepository.find(criteria));
  }

 count(criteria?: SearchCriteria<T>): Promise<number> {
    return this.withMonitoring('count',  () => this.baseRepository.count(criteria));
  }

 exists(id: string): Promise<boolean> {
    return this.withMonitoring('exists',  () => this.baseRepository.exists(id));
  }

 healthCheck(): Promise<boolean> {
    return this.withMonitoring('healthCheck',  () => this.baseRepository.healthCheck());
  }

  private async withMonitoring<R>(operation: string, fn: () => Promise<R>): Promise<R> {
    if (this.circuitBreaker && this.circuitBreaker.isOpen()) {
      throw new CircuitBreakerOpenError(this.providerName);
    }

    const startTime = Date.now();
    try {
      const result = await fn();

      if (this.circuitBreaker) {
        this.circuitBreaker.recordSuccess();
      }

      if (this.performanceMonitor) {
        this.performanceMonitor.recordOperation(
          this.providerName,
          operation,
          Date.now() - startTime
        );
      }

      return result;
    } catch (error) {
      if (this.circuitBreaker) {
        this.circuitBreaker.recordFailure();
      }

      if (this.performanceMonitor) {
        this.performanceMonitor.recordOperation(
          this.providerName,
          operation,
          Date.now() - startTime,
          false
        );
      }

      throw error;
    }
  }
}

class HealthMonitor {
  private interval?: NodeJS.Timeout;

  constructor(private config: RepositoryFactoryConfig['healthChecks']) {}

  start(_providers: Map<string,  IDatabaseProvider>): void {
    if (!this.config.enabled) {
      return;
    }

    this.interval = setInterval(async () => {
      for (const [name,  provider] of providers) {
        try {
          await provider.getHealthStatus();
        } catch (error) {
          logger.warn(`Health check failed for provider ${name}:`, error);
        }
      }
    }, this.config.interval);
  }

  stop(): void {
    if (this.interval) {
      clearInterval(this.interval);
      this.interval = undefined;
    }
  }
}

class CircuitBreaker {
  private state: 'closed' | 'open' | 'half-open' = 'closed';
  private failures = 0;
  private lastFailureTime = 0;

  constructor(
    private config: { failureThreshold: number; recoveryTimeout: number; name: string }
  ) {}

  async execute<T>(fn: () => Promise<T>): Promise<T> {
    if (this.isOpen()) {
      throw new CircuitBreakerOpenError(this.config.name);
    }

    try {
      const result = await fn();
      this.recordSuccess();
      return result;
    } catch (error) {
      this.recordFailure();
      throw error;
    }
  }

  isOpen(): boolean {
    if (this.state === 'open') {
      const timeSinceLastFailure = Date.now() - this.lastFailureTime;
      if (timeSinceLastFailure > this.config.recoveryTimeout) {
        this.state = 'half-open';
        return false;
      }
      return true;
    }
    return false;
  }

  recordSuccess(): void {
    this.failures = 0;
    this.state = 'closed';
  }

  recordFailure(): void {
    this.failures++;
    this.lastFailureTime = Date.now();

    if (this.failures >= this.config.failureThreshold) {
      this.state = 'open';
    }
  }

  forceOpen(): void {
    this.state = 'open';
    this.lastFailureTime = Date.now();
  }
}

// ===== ERROR TYPES =====

class RepositoryCreationError extends Error {
  constructor(
    public repositoryName: string, 
    public cause: Error
  ) {
    super(`Failed to create repository: ${repositoryName} - ${cause.message}`);
    this.name = 'RepositoryCreationError';
  }
}

class CircuitBreakerOpenError extends Error {
  constructor(public providerName: string) {
    super(`Circuit breaker is open for provider: ${providerName}`);
    this.name = 'CircuitBreakerOpenError';
  }
}

// ===== EXPORTS =====

export default EnhancedRepositoryFactory;
