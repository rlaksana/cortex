/**
 * Typed Qdrant Repository - P0-CRITICAL Implementation
 *
 * Implements strongly-typed repository pattern to replace module augmentation.
 * Provides comprehensive type safety and validation for all Cortex operations.
 *
 * @author Cortex Team
 * @version 2.0.1
 * @since 2025
 */

import type { QdrantClient } from '@qdrant/js-client-rest';

interface QdrantPointsResponse {
  points: Array<{
    id: string | number;
    payload: unknown;
    vector?: number[];
  }>;
}
import type {
  IQdrantTypedRepository,
  KnowledgeEntity,
  KnowledgeRelation,
  KnowledgeObservation,
  AuditRecord,
  ChangeRecord,
  DecisionRecord,
  IssueRecord,
  TodoRecord,
  ReleaseNoteRecord,
  DDLRecord,
  PRContextRecord,
  IncidentRecord,
  ReleaseRecord,
  RiskRecord,
  AssumptionRecord,
  RunbookRecord,
  DocumentationSection,
  SecurityEvent,
  AuthUser,
  ApiKey,
  TokenRevocationEntry,
  IAuthenticationRepository,
  CortexCollectionName,
} from '../types/cortex-repository-interfaces.js';
import { CORTEX_COLLECTIONS } from '../types/cortex-repository-interfaces.js';
import { logger } from '../utils/logger.js';

/**
 * Typed Qdrant Repository Implementation
 * Replaces module augmentation with comprehensive type safety
 */
export class QdrantTypedRepository implements IQdrantTypedRepository, IAuthenticationRepository {
  private client: QdrantClient;
  private readonly defaultVectorSize = 1536;

  constructor(_client: QdrantClient) {
    this.client = client;
  }

  // ============================================================================
  // PRIVATE HELPER METHODS
  // ============================================================================

  private generateId(): string {
    return `cortex_${Date.now()}_${String(Math.random().toString(36).substr(2, 9))}`;
  }

  private now(): Date {
    return new Date();
  }

  private async ensureCollection(collectionName: CortexCollectionName): Promise<void> {
    try {
      await this.client.getCollection(collectionName);
    } catch (error) {
      // Collection doesn't exist, create it
      await this.client.createCollection(collectionName, {
        vectors: {
          size: this.defaultVectorSize,
          distance: 'Cosine',
        },
      });
      logger.info(`Created collection: ${collectionName}`);
    }
  }

  private async upsertDocument<T extends { id: string }>(
    collectionName: CortexCollectionName,
    document: T,
    vector?: number[]
  ): Promise<T> {
    await this.ensureCollection(collectionName);

    const payload = {
      ...document,
      type: collectionName,
      _updated_at: this.now().toISOString(),
    };

    await this.client.upsert(collectionName, {
      points: [
        {
          id: document.id,
          vector: vector || this.generateDefaultVector(),
          payload,
        },
      ],
    });

    logger.debug(`Upserted document in ${collectionName}: ${document.id}`);
    return document;
  }

  private async retrieveDocument<T>(
    collectionName: CortexCollectionName,
    id: string
  ): Promise<T | null> {
    try {
      const result = await this.client.retrieve(collectionName, {
        ids: [id],
        with_payload: true,
        with_vector: false,
      });

      // Handle Qdrant response structure - check for points property
      const points = Array.isArray((result as unknown).points) ? (result as unknown).points : [];
      if (points.length === 0) {
        return null;
      }

      return points[0].payload as T;
    } catch (error) {
      logger.warn(`Failed to retrieve document ${id} from ${collectionName}:`, error);
      return null;
    }
  }

  private async searchDocuments<T>(
    collectionName: CortexCollectionName,
    query: string,
    filters?: Record<string, unknown>,
    limit: number = 10
  ): Promise<T[]> {
    await this.ensureCollection(collectionName);

    const searchFilter = filters
      ? {
          must: Object.entries(filters).map(([key,  value]) => ({
            key,
            match: { value },
          })),
        }
      : undefined;

    const result = await this.client.search(collectionName, {
      vector: this.generateDefaultVector(),
      filter: searchFilter,
      limit,
      with_payload: true,
      with_vector: false,
    });

    // Handle Qdrant response structure - check for points property
    const points = Array.isArray((result as unknown).points) ? (result as unknown).points : [];
    return points.map((point: unknown) => point.payload as T);
  }

  private generateDefaultVector(): number[] {
    // Simple default vector for non-semantic searches
    return new Array(this.defaultVectorSize).fill(0.1);
  }

  private async deleteDocument(collectionName: CortexCollectionName, id: string): Promise<void> {
    await this.client.delete(collectionName, {
      points: [id],
    });
    logger.debug(`Deleted document from ${collectionName}: ${id}`);
  }

  // ============================================================================
  // KNOWLEDGE OPERATIONS
  // ============================================================================

 createEntity(
    entityData: Omit<KnowledgeEntity, 'id' | 'createdAt' | 'updatedAt'>
  ): Promise<KnowledgeEntity> {
    const entity: KnowledgeEntity = {
      ...entityData,
      id: this.generateId(),
      createdAt: this.now(),
      updatedAt: this.now(),
    };

    return this.upsertDocument(CORTEX_COLLECTIONS.ENTITIES, entity);
  }

 findEntity(
    id: string,
    scope?: { project?: string; branch?: string; org?: string }
  ): Promise<KnowledgeEntity | null> {
    return this.retrieveDocument<KnowledgeEntity>(CORTEX_COLLECTIONS.ENTITIES, id);
  }

  async updateEntity(id: string, updates: Partial<KnowledgeEntity>): Promise<KnowledgeEntity> {
    const existing = await this.findEntity(id);
    if (!existing) {
      throw new Error(`Entity not found: ${id}`);
    }

    const updated: KnowledgeEntity = {
      ...existing,
      ...updates,
      updatedAt: this.now(),
    };

    return this.upsertDocument(CORTEX_COLLECTIONS.ENTITIES, updated);
  }

  async deleteEntity(id: string): Promise<void> {
    await this.deleteDocument(CORTEX_COLLECTIONS.ENTITIES, id);
  }

 searchEntities(
    query: string,
    filters?: Partial<KnowledgeEntity>
  ): Promise<KnowledgeEntity[]> {
    return this.searchDocuments<KnowledgeEntity>(CORTEX_COLLECTIONS.ENTITIES, query, filters);
  }

 createRelation(
    relationData: Omit<KnowledgeRelation, 'id' | 'createdAt' | 'updatedAt'>
  ): Promise<KnowledgeRelation> {
    const relation: KnowledgeRelation = {
      ...relationData,
      id: this.generateId(),
      createdAt: this.now(),
      updatedAt: this.now(),
    };

    return this.upsertDocument(CORTEX_COLLECTIONS.RELATIONS, relation);
  }

 findRelations(
    fromEntity?: string,
    toEntity?: string,
    relationType?: string
  ): Promise<KnowledgeRelation[]> {
    const filters: Record<string, unknown> = {};
    if (fromEntity) filters.fromEntity = fromEntity;
    if (toEntity) filters.toEntity = toEntity;
    if (relationType) filters.relationType = relationType;

    return this.searchDocuments<KnowledgeRelation>(CORTEX_COLLECTIONS.RELATIONS, '', filters);
  }

  async deleteRelation(id: string): Promise<void> {
    await this.deleteDocument(CORTEX_COLLECTIONS.RELATIONS, id);
  }

 createObservation(
    observationData: Omit<KnowledgeObservation, 'id' | 'createdAt' | 'updatedAt'>
  ): Promise<KnowledgeObservation> {
    const observation: KnowledgeObservation = {
      ...observationData,
      id: this.generateId(),
      createdAt: this.now(),
      updatedAt: this.now(),
    };

    return this.upsertDocument(CORTEX_COLLECTIONS.OBSERVATIONS, observation);
  }

 findObservations(entityId?: string, entityType?: string): Promise<KnowledgeObservation[]> {
    const filters: Record<string, unknown> = {};
    if (entityId) filters.entityId = entityId;
    if (entityType) filters.entityType = entityType;

    return this.searchDocuments<KnowledgeObservation>(CORTEX_COLLECTIONS.OBSERVATIONS, '', filters);
  }

  // ============================================================================
  // AUDIT OPERATIONS
  // ============================================================================

 createAuditRecord(recordData: Omit<AuditRecord, 'id' | 'timestamp'>): Promise<AuditRecord> {
    const record: AuditRecord = {
      ...recordData,
      id: this.generateId(),
      timestamp: this.now(),
    };

    return this.upsertDocument(CORTEX_COLLECTIONS.AUDIT_TRAIL, record);
  }

 findAuditRecords(
    entityType?: string,
    entityId?: string,
    from?: Date,
    to?: Date
  ): Promise<AuditRecord[]> {
    const filters: Record<string, unknown> = {};
    if (entityType) filters.entityType = entityType;
    if (entityId) filters.entityId = entityId;
    if (from) filters.from = from.toISOString();
    if (to) filters.to = to.toISOString();

    return this.searchDocuments<AuditRecord>(CORTEX_COLLECTIONS.AUDIT_TRAIL, '', filters);
  }

  // ============================================================================
  // CHANGE OPERATIONS
  // ============================================================================

 createChangeRecord(
    recordData: Omit<ChangeRecord, 'id' | 'timestamp'>
  ): Promise<ChangeRecord> {
    const record: ChangeRecord = {
      ...recordData,
      id: this.generateId(),
      timestamp: this.now(),
    };

    return this.upsertDocument(CORTEX_COLLECTIONS.CHANGE_LOG, record);
  }

 findChangeRecords(scope?: {
    project?: string;
    branch?: string;
    org?: string;
  }): Promise<ChangeRecord[]> {
    return this.searchDocuments<ChangeRecord>(CORTEX_COLLECTIONS.CHANGE_LOG, '', scope);
  }

  // ============================================================================
  // DECISION OPERATIONS
  // ============================================================================

 createDecisionRecord(
    recordData: Omit<DecisionRecord, 'id' | 'createdAt'>
  ): Promise<DecisionRecord> {
    const record: DecisionRecord = {
      ...recordData,
      id: this.generateId(),
      createdAt: this.now(),
    };

    return this.upsertDocument(CORTEX_COLLECTIONS.DECISION_LOG, record);
  }

 findDecisionRecords(scope?: {
    project?: string;
    branch?: string;
    org?: string;
  }): Promise<DecisionRecord[]> {
    return this.searchDocuments<DecisionRecord>(CORTEX_COLLECTIONS.DECISION_LOG, '', scope);
  }

  // ============================================================================
  // ISSUE OPERATIONS
  // ============================================================================

 createIssueRecord(
    recordData: Omit<IssueRecord, 'id' | 'createdAt' | 'resolvedAt'>
  ): Promise<IssueRecord> {
    const record: IssueRecord = {
      ...recordData,
      id: this.generateId(),
      createdAt: this.now(),
    };

    return this.upsertDocument(CORTEX_COLLECTIONS.ISSUE_LOG, record);
  }

  async updateIssueRecord(id: string, updates: Partial<IssueRecord>): Promise<IssueRecord> {
    const existing = await this.retrieveDocument<IssueRecord>(CORTEX_COLLECTIONS.ISSUE_LOG, id);
    if (!existing) {
      throw new Error(`Issue not found: ${id}`);
    }

    const updated: IssueRecord = {
      ...existing,
      ...updates,
      ...(updates.status === 'resolved' ? { resolvedAt: this.now() } : {}),
    };

    return this.upsertDocument(CORTEX_COLLECTIONS.ISSUE_LOG, updated);
  }

 findIssueRecords(
    status?: string,
    severity?: string,
    scope?: { project?: string; branch?: string; org?: string }
  ): Promise<IssueRecord[]> {
    const filters: Record<string, unknown> = { ...scope };
    if (status) filters.status = status;
    if (severity) filters.severity = severity;

    return this.searchDocuments<IssueRecord>(CORTEX_COLLECTIONS.ISSUE_LOG, '', filters);
  }

  // ============================================================================
  // TODO OPERATIONS
  // ============================================================================

 createTodoRecord(
    recordData: Omit<TodoRecord, 'id' | 'createdAt' | 'updatedAt' | 'completedAt'>
  ): Promise<TodoRecord> {
    const record: TodoRecord = {
      ...recordData,
      id: this.generateId(),
      createdAt: this.now(),
      updatedAt: this.now(),
    };

    return this.upsertDocument(CORTEX_COLLECTIONS.TODO_LOG, record);
  }

  async updateTodoRecord(id: string, updates: Partial<TodoRecord>): Promise<TodoRecord> {
    const existing = await this.retrieveDocument<TodoRecord>(CORTEX_COLLECTIONS.TODO_LOG, id);
    if (!existing) {
      throw new Error(`Todo not found: ${id}`);
    }

    const updated: TodoRecord = {
      ...existing,
      ...updates,
      updatedAt: this.now(),
      ...(updates.status === 'completed' ? { completedAt: this.now() } : {}),
    };

    return this.upsertDocument(CORTEX_COLLECTIONS.TODO_LOG, updated);
  }

 findTodoRecords(
    status?: string,
    assignee?: string,
    scope?: { project?: string; branch?: string; org?: string }
  ): Promise<TodoRecord[]> {
    const filters: Record<string, unknown> = { ...scope };
    if (status) filters.status = status;
    if (assignee) filters.assignee = assignee;

    return this.searchDocuments<TodoRecord>(CORTEX_COLLECTIONS.TODO_LOG, '', filters);
  }

  // ============================================================================
  // RELEASE NOTE OPERATIONS
  // ============================================================================

 createReleaseNoteRecord(
    recordData: Omit<ReleaseNoteRecord, 'id' | 'publishedAt'>
  ): Promise<ReleaseNoteRecord> {
    const record: ReleaseNoteRecord = {
      ...recordData,
      id: this.generateId(),
      publishedAt: this.now(),
    };

    return this.upsertDocument(CORTEX_COLLECTIONS.RELEASE_NOTES, record);
  }

 findReleaseNoteRecords(
    version?: string,
    scope?: { project?: string; branch?: string; org?: string }
  ): Promise<ReleaseNoteRecord[]> {
    const filters: Record<string, unknown> = { ...scope };
    if (version) filters.version = version;

    return this.searchDocuments<ReleaseNoteRecord>(CORTEX_COLLECTIONS.RELEASE_NOTES, '', filters);
  }

  // ============================================================================
  // DDL OPERATIONS
  // ============================================================================

 createDDLRecord(recordData: Omit<DDLRecord, 'id' | 'executedAt'>): Promise<DDLRecord> {
    const record: DDLRecord = {
      ...recordData,
      id: this.generateId(),
      executedAt: this.now(),
    };

    return this.upsertDocument(CORTEX_COLLECTIONS.DDL_HISTORY, record);
  }

 findDDLRecords(scope?: {
    project?: string;
    branch?: string;
    org?: string;
  }): Promise<DDLRecord[]> {
    return this.searchDocuments<DDLRecord>(CORTEX_COLLECTIONS.DDL_HISTORY, '', scope);
  }

  // ============================================================================
  // PR CONTEXT OPERATIONS
  // ============================================================================

 createPRContextRecord(
    recordData: Omit<PRContextRecord, 'id' | 'createdAt' | 'mergedAt'>
  ): Promise<PRContextRecord> {
    const record: PRContextRecord = {
      ...recordData,
      id: this.generateId(),
      createdAt: this.now(),
    };

    return this.upsertDocument(CORTEX_COLLECTIONS.PR_CONTEXT, record);
  }

 findPRContextRecords(
    prNumber?: number,
    scope?: { project?: string; branch?: string; org?: string }
  ): Promise<PRContextRecord[]> {
    const filters: Record<string, unknown> = { ...scope };
    if (prNumber) filters.prNumber = prNumber;

    return this.searchDocuments<PRContextRecord>(CORTEX_COLLECTIONS.PR_CONTEXT, '', filters);
  }

  // ============================================================================
  // INCIDENT OPERATIONS
  // ============================================================================

 createIncidentRecord(
    recordData: Omit<IncidentRecord, 'id' | 'createdAt' | 'resolvedAt'>
  ): Promise<IncidentRecord> {
    const record: IncidentRecord = {
      ...recordData,
      id: this.generateId(),
      createdAt: this.now(),
    };

    return this.upsertDocument(CORTEX_COLLECTIONS.INCIDENT_LOG, record);
  }

  async updateIncidentRecord(
    id: string,
    updates: Partial<IncidentRecord>
  ): Promise<IncidentRecord> {
    const existing = await this.retrieveDocument<IncidentRecord>(
      CORTEX_COLLECTIONS.INCIDENT_LOG,
      id
    );
    if (!existing) {
      throw new Error(`Incident not found: ${id}`);
    }

    const updated: IncidentRecord = {
      ...existing,
      ...updates,
      ...(updates.status === 'resolved' || updates.status === 'closed'
        ? { resolvedAt: this.now() }
        : {}),
    };

    return this.upsertDocument(CORTEX_COLLECTIONS.INCIDENT_LOG, updated);
  }

 findIncidentRecords(
    status?: string,
    severity?: string,
    scope?: { project?: string; branch?: string; org?: string }
  ): Promise<IncidentRecord[]> {
    const filters: Record<string, unknown> = { ...scope };
    if (status) filters.status = status;
    if (severity) filters.severity = severity;

    return this.searchDocuments<IncidentRecord>(CORTEX_COLLECTIONS.INCIDENT_LOG, '', filters);
  }

  // ============================================================================
  // RELEASE OPERATIONS
  // ============================================================================

 createReleaseRecord(
    recordData: Omit<ReleaseRecord, 'id' | 'createdAt' | 'deployedAt'>
  ): Promise<ReleaseRecord> {
    const record: ReleaseRecord = {
      ...recordData,
      id: this.generateId(),
      createdAt: this.now(),
    };

    return this.upsertDocument(CORTEX_COLLECTIONS.RELEASE_LOG, record);
  }

 findReleaseRecords(scope?: {
    project?: string;
    branch?: string;
    org?: string;
  }): Promise<ReleaseRecord[]> {
    return this.searchDocuments<ReleaseRecord>(CORTEX_COLLECTIONS.RELEASE_LOG, '', scope);
  }

  // ============================================================================
  // RISK OPERATIONS
  // ============================================================================

 createRiskRecord(
    recordData: Omit<RiskRecord, 'id' | 'createdAt' | 'reviewedAt'>
  ): Promise<RiskRecord> {
    const record: RiskRecord = {
      ...recordData,
      id: this.generateId(),
      createdAt: this.now(),
    };

    return this.upsertDocument(CORTEX_COLLECTIONS.RISK_LOG, record);
  }

  async updateRiskRecord(id: string, updates: Partial<RiskRecord>): Promise<RiskRecord> {
    const existing = await this.retrieveDocument<RiskRecord>(CORTEX_COLLECTIONS.RISK_LOG, id);
    if (!existing) {
      throw new Error(`Risk not found: ${id}`);
    }

    const updated: RiskRecord = {
      ...existing,
      ...updates,
      ...(updates.status ? { reviewedAt: this.now() } : {}),
    };

    return this.upsertDocument(CORTEX_COLLECTIONS.RISK_LOG, updated);
  }

 findRiskRecords(
    status?: string,
    severity?: string,
    scope?: { project?: string; branch?: string; org?: string }
  ): Promise<RiskRecord[]> {
    const filters: Record<string, unknown> = { ...scope };
    if (status) filters.status = status;
    if (severity) filters.severity = severity;

    return this.searchDocuments<RiskRecord>(CORTEX_COLLECTIONS.RISK_LOG, '', filters);
  }

  // ============================================================================
  // ASSUMPTION OPERATIONS
  // ============================================================================

 createAssumptionRecord(
    recordData: Omit<AssumptionRecord, 'id' | 'createdAt' | 'validatedAt'>
  ): Promise<AssumptionRecord> {
    const record: AssumptionRecord = {
      ...recordData,
      id: this.generateId(),
      createdAt: this.now(),
    };

    return this.upsertDocument(CORTEX_COLLECTIONS.ASSUMPTION_LOG, record);
  }

  async updateAssumptionRecord(
    id: string,
    updates: Partial<AssumptionRecord>
  ): Promise<AssumptionRecord> {
    const existing = await this.retrieveDocument<AssumptionRecord>(
      CORTEX_COLLECTIONS.ASSUMPTION_LOG,
      id
    );
    if (!existing) {
      throw new Error(`Assumption not found: ${id}`);
    }

    const updated: AssumptionRecord = {
      ...existing,
      ...updates,
      ...(updates.validationStatus ? { validatedAt: this.now() } : {}),
    };

    return this.upsertDocument(CORTEX_COLLECTIONS.ASSUMPTION_LOG, updated);
  }

 findAssumptionRecords(
    validationStatus?: string,
    scope?: { project?: string; branch?: string; org?: string }
  ): Promise<AssumptionRecord[]> {
    const filters: Record<string, unknown> = { ...scope };
    if (validationStatus) filters.validationStatus = validationStatus;

    return this.searchDocuments<AssumptionRecord>(CORTEX_COLLECTIONS.ASSUMPTION_LOG, '', filters);
  }

  // ============================================================================
  // RUNBOOK OPERATIONS
  // ============================================================================

 createRunbookRecord(
    recordData: Omit<RunbookRecord, 'id' | 'createdAt' | 'updatedAt'>
  ): Promise<RunbookRecord> {
    const record: RunbookRecord = {
      ...recordData,
      id: this.generateId(),
      createdAt: this.now(),
      updatedAt: this.now(),
    };

    return this.upsertDocument(CORTEX_COLLECTIONS.RUNBOOK, record);
  }

  async updateRunbookRecord(id: string, updates: Partial<RunbookRecord>): Promise<RunbookRecord> {
    const existing = await this.retrieveDocument<RunbookRecord>(CORTEX_COLLECTIONS.RUNBOOK, id);
    if (!existing) {
      throw new Error(`Runbook not found: ${id}`);
    }

    const updated: RunbookRecord = {
      ...existing,
      ...updates,
      updatedAt: this.now(),
    };

    return this.upsertDocument(CORTEX_COLLECTIONS.RUNBOOK, updated);
  }

 findRunbookRecords(
    category?: string,
    scope?: { project?: string; branch?: string; org?: string }
  ): Promise<RunbookRecord[]> {
    const filters: Record<string, unknown> = { ...scope };
    if (category) filters.category = category;

    return this.searchDocuments<RunbookRecord>(CORTEX_COLLECTIONS.RUNBOOK, '', filters);
  }

  // ============================================================================
  // DOCUMENTATION OPERATIONS
  // ============================================================================

 createDocumentationSection(
    sectionData: Omit<DocumentationSection, 'id' | 'createdAt' | 'updatedAt'>
  ): Promise<DocumentationSection> {
    const section: DocumentationSection = {
      ...sectionData,
      id: this.generateId(),
      createdAt: this.now(),
      updatedAt: this.now(),
    };

    return this.upsertDocument(CORTEX_COLLECTIONS.DOCUMENTATION, section);
  }

  async updateDocumentationSection(
    id: string,
    updates: Partial<DocumentationSection>
  ): Promise<DocumentationSection> {
    const existing = await this.retrieveDocument<DocumentationSection>(
      CORTEX_COLLECTIONS.DOCUMENTATION,
      id
    );
    if (!existing) {
      throw new Error(`Documentation section not found: ${id}`);
    }

    const updated: DocumentationSection = {
      ...existing,
      ...updates,
      updatedAt: this.now(),
    };

    return this.upsertDocument(CORTEX_COLLECTIONS.DOCUMENTATION, updated);
  }

 findDocumentationSections(
    sectionType?: string,
    parentId?: string,
    scope?: { project?: string; branch?: string; org?: string }
  ): Promise<DocumentationSection[]> {
    const filters: Record<string, unknown> = { ...scope };
    if (sectionType) filters.sectionType = sectionType;
    if (parentId) filters.parentId = parentId;

    return this.searchDocuments<DocumentationSection>(
      CORTEX_COLLECTIONS.DOCUMENTATION,
      '',
      filters
    );
  }

  // ============================================================================
  // AUTHENTICATION OPERATIONS (IAuthenticationRepository)
  // ============================================================================

 createUser(userData: Omit<AuthUser, 'id' | 'createdAt'>): Promise<AuthUser> {
    const user: AuthUser = {
      ...userData,
      id: this.generateId(),
      createdAt: this.now(),
    };

    return this.upsertDocument(CORTEX_COLLECTIONS.AUTH_USERS, user);
  }

 findUser(id: string): Promise<AuthUser | null> {
    return this.retrieveDocument<AuthUser>(CORTEX_COLLECTIONS.AUTH_USERS, id);
  }

  async findUserByUsername(username: string): Promise<AuthUser | null> {
    const users = await this.searchDocuments<AuthUser>(CORTEX_COLLECTIONS.AUTH_USERS, '', {
      username,
    });
    return users.length > 0 ? users[0] : null;
  }

  async updateUser(id: string, updates: Partial<AuthUser>): Promise<AuthUser> {
    const existing = await this.findUser(id);
    if (!existing) {
      throw new Error(`User not found: ${id}`);
    }

    const updated: AuthUser = {
      ...existing,
      ...updates,
    };

    return this.upsertDocument(CORTEX_COLLECTIONS.AUTH_USERS, updated);
  }

  async deactivateUser(id: string): Promise<void> {
    await this.updateUser(id, { isActive: false });
  }

 createApiKey(apiKeyData: Omit<ApiKey, 'id' | 'createdAt' | 'lastUsed'>): Promise<ApiKey> {
    const apiKey: ApiKey = {
      ...apiKeyData,
      id: this.generateId(),
      createdAt: this.now(),
    };

    return this.upsertDocument(CORTEX_COLLECTIONS.API_KEYS, apiKey);
  }

  async findApiKey(key: string): Promise<ApiKey | null> {
    const apiKeys = await this.searchDocuments<ApiKey>(CORTEX_COLLECTIONS.API_KEYS, '', { key });
    return apiKeys.length > 0 ? apiKeys[0] : null;
  }

  async updateApiKeyUsage(id: string): Promise<void> {
    const existing = await this.retrieveDocument<ApiKey>(CORTEX_COLLECTIONS.API_KEYS, id);
    if (_existing) {
      await this.upsertDocument(CORTEX_COLLECTIONS.API_KEYS, {
        ...existing,
        lastUsed: this.now(),
      });
    }
  }

  async revokeApiKey(id: string): Promise<void> {
    await this.deleteDocument(CORTEX_COLLECTIONS.API_KEYS, id);
  }

  async revokeToken(token: string, revokedBy: string, reason: string): Promise<void> {
    const entry: TokenRevocationEntry = {
      id: this.generateId(),
      token,
      revokedAt: this.now(),
      revokedBy,
      reason,
    };

    await this.upsertDocument(CORTEX_COLLECTIONS.TOKEN_REVOCATION_LIST, entry);
  }

  async isTokenRevoked(token: string): Promise<boolean> {
    const revocations = await this.searchDocuments<TokenRevocationEntry>(
      CORTEX_COLLECTIONS.TOKEN_REVOCATION_LIST,
      '',
      { token }
    );
    return revocations.length > 0;
  }

 createSecurityEvent(
    eventData: Omit<SecurityEvent, 'id' | 'timestamp'>
  ): Promise<SecurityEvent> {
    const event: SecurityEvent = {
      ...eventData,
      id: this.generateId(),
      timestamp: this.now(),
    };

    return this.upsertDocument(CORTEX_COLLECTIONS.SECURITY_EVENTS, event);
  }

 findSecurityEvents(userId?: string, from?: Date, to?: Date): Promise<SecurityEvent[]> {
    const filters: Record<string, unknown> = {};
    if (userId) filters.userId = userId;
    if (from) filters.from = from.toISOString();
    if (to) filters.to = to.toISOString();

    return this.searchDocuments<SecurityEvent>(CORTEX_COLLECTIONS.SECURITY_EVENTS, '', filters);
  }

  // ============================================================================
  // HEALTH AND LIFECYCLE OPERATIONS
  // ============================================================================

  async healthCheck(): Promise<boolean> {
    try {
      // Check if client is available and responsive
      await this.client.getCollections();
      return true;
    } catch (error) {
      logger.warn({ error }, 'Qdrant repository health check failed');
      return false;
    }
  }

  async close(): Promise<void> {
    try {
      // Close the client connection if it has a close method
      if (this.client && typeof (this.client as unknown).close === 'function') {
        await (this.client as unknown).close();
      }
      logger.info('Qdrant repository closed successfully');
    } catch (error) {
      logger.error('Error closing Qdrant repository:', error);
      throw error;
    }
  }
}
