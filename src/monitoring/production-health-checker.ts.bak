/**
 * Production Health Checker
 *
 * Comprehensive health checking system for production environments.
 * Validates service dependencies, system resources, and application state.
 * Provides liveness and readiness probes for container orchestration.
 *
 * @author Cortex Team
 * @version 2.0.1
 */

import * as fs from 'fs';
import * as os from 'os';
import {
  migrateHealthCheckConfig,
  validateHealthCheckConfig,
  type StandardHealthCheckConfig,
  type LegacyHealthCheckConfig,
} from '../config/configuration-migration.js';
import type {
  ProductionHealthResult,
  HealthCheck,
  HealthCheckResult,
} from '../types/unified-health-interfaces.js';
import { type HealthCheckConfig as UnifiedHealthCheckConfig } from '../types/unified-health-interfaces.js';

// Re-export for backward compatibility
export type { ProductionHealthResult as HealthCheckResult };

/**
 * Legacy HealthCheckConfig interface for backward compatibility
 * @deprecated Use StandardHealthCheckConfig instead
 */
export interface HealthCheckConfig
  extends Omit<UnifiedHealthCheckConfig, 'timeoutMs' | 'retryAttempts' | 'retryDelayMs'> {
  enabled: boolean;
  intervalMs: number;
  timeoutMs?: number;
  failureThreshold: number;
  successThreshold: number;
  retryAttempts?: number;
  retryDelayMs?: number;
  timeout?: number;
  retries?: number;
  retryDelay?: number;
  enableDetailedChecks: boolean;
  skipOptionalChecks: boolean;
}

/**
 * Internal configuration interface that extends standard health check config
 */
interface InternalProductionHealthConfig extends StandardHealthCheckConfig {
  enableDetailedChecks: boolean;
  skipOptionalChecks: boolean;
}

export class ProductionHealthChecker {
  private config: InternalProductionHealthConfig;

  constructor(config?: Partial<HealthCheckConfig>) {
    // Create configuration with environment defaults and migration
    const legacyConfig: LegacyHealthCheckConfig = {
      enabled: true,
      timeout: parseInt(process.env.HEALTH_CHECK_TIMEOUT || '10000'),
      timeoutMs: parseInt(process.env.HEALTH_CHECK_TIMEOUT_MS || '10000'),
      retries: parseInt(process.env.HEALTH_CHECK_RETRIES || '3'),
      retryAttempts: parseInt(process.env.HEALTH_CHECK_RETRY_ATTEMPTS || '3'),
      retryDelay: parseInt(process.env.HEALTH_CHECK_RETRY_DELAY || '1000'),
      retryDelayMs: parseInt(process.env.HEALTH_CHECK_RETRY_DELAY_MS || '1000'),
      ...config,
    };

    // Migrate to standard configuration
    const standardConfig = migrateHealthCheckConfig(legacyConfig);

    // Validate the migrated configuration
    const validation = validateHealthCheckConfig(standardConfig);
    if (!validation.valid) {
      console.warn(
        `[production-health-checker] Configuration validation failed: ${validation.errors.join(', ')}`
      );
    }

    // Create internal configuration with production-specific settings
    this.config = {
      ...standardConfig,
      enableDetailedChecks:
        config?.enableDetailedChecks ?? process.env.ENABLE_DETAILED_HEALTH_CHECKS === 'true',
      skipOptionalChecks:
        config?.skipOptionalChecks ?? process.env.SKIP_OPTIONAL_HEALTH_CHECKS === 'true',
    };
  }

  /**
   * Create a ProductionHealthChecker with builder pattern
   */
  static builder(): ProductionHealthCheckerBuilder {
    return new ProductionHealthCheckerBuilder();
  }

  // Import logger lazily to avoid circular dependencies
  private get logger() {
    return {
      info: (message: string, data?: unknown) =>
        { console.log(`[health-checker] ${message}`, data || ''); },
      warn: (message: string, data?: unknown) =>
        { console.warn(`[health-checker] ${message}`, data || ''); },
      error: (message: string, data?: unknown) =>
        { console.error(`[health-checker] ${message}`, data || ''); },
    };
  }

  /**
   * Get the current configuration (read-only)
   */
  public getConfiguration(): Readonly<InternalProductionHealthConfig> {
    return { ...this.config };
  }

  /**
   * Update configuration with migration and validation
   */
  public updateConfiguration(config: Partial<HealthCheckConfig>): void {
    const legacyConfig: LegacyHealthCheckConfig = {
      ...this.config,
      ...config,
    };

    const standardConfig = migrateHealthCheckConfig(legacyConfig);
    const validation = validateHealthCheckConfig(standardConfig);

    if (!validation.valid) {
      throw new Error(`Invalid configuration update: ${validation.errors.join(', ')}`);
    }

    this.config = {
      ...standardConfig,
      enableDetailedChecks: config.enableDetailedChecks ?? this.config.enableDetailedChecks,
      skipOptionalChecks: config.skipOptionalChecks ?? this.config.skipOptionalChecks,
    };
  }

  /**
   * Perform pre-startup health check
   */
  async performPreStartupHealthCheck(): Promise<ProductionHealthResult> {
    this.logger.info('Performing pre-startup health check');

    const checks: HealthCheck[] = [
      await this.checkEnvironmentVariables(),
      await this.checkNodeVersion(),
      await this.checkMemoryUsage(),
      await this.checkDiskSpace(),
      await this.checkQdrantConnection(),
    ];

    // Add optional checks if enabled
    if (!this.config.skipOptionalChecks) {
      checks.push(await this.checkOpenAIConnection(), await this.checkFileSystemAccess());
    }

    return this.aggregateHealthResults('pre-startup', checks);
  }

  /**
   * Perform post-startup health check
   */
  async performPostStartupHealthCheck(): Promise<HealthCheckResult> {
    this.logger.info('Performing post-startup health check');

    const checks: HealthCheck[] = [
      await this.checkEnvironmentVariables(),
      await this.checkNodeVersion(),
      await this.checkMemoryUsage(),
      await this.checkDiskSpace(),
      await this.checkQdrantConnection(),
    ];

    // Add detailed checks if enabled
    if (this.config.enableDetailedChecks) {
      checks.push(
        await this.checkSystemLoad(),
        await this.checkCacheHealth(),
        await this.checkWorkerHealth()
      );
    }

    return this.aggregateHealthResults('post-startup', checks);
  }

  /**
   * Liveness probe for container orchestration
   */
  async livenessProbe(): Promise<HealthCheckResult> {
    this.logger.info('Performing liveness probe');

    const checks: HealthCheck[] = [await this.checkMemoryUsage(), await this.checkNodeVersion()];

    return this.aggregateHealthResults('liveness', checks);
  }

  /**
   * Readiness probe for container orchestration
   */
  async readinessProbe(): Promise<HealthCheckResult> {
    this.logger.info('Performing readiness probe');

    const checks: HealthCheck[] = [
      await this.checkEnvironmentVariables(),
      await this.checkQdrantConnection(),
    ];

    return this.aggregateHealthResults('readiness', checks);
  }

  /**
   * Check environment variables
   */
  private async checkEnvironmentVariables(): Promise<HealthCheck> {
    const startTime = Date.now();
    const requiredVars = ['NODE_ENV', 'QDRANT_URL'];

    const optionalVars = ['OPENAI_API_KEY', 'LOG_LEVEL'];

    const missingVars: string[] = [];
    const invalidVars: string[] = [];

    for (const varName of requiredVars) {
      const value = process.env[varName];
      if (!value) {
        missingVars.push(varName);
      }
    }

    // Check for invalid values
    const nodeEnv = process.env.NODE_ENV;
    if (nodeEnv && !['development', 'production', 'test'].includes(nodeEnv)) {
      invalidVars.push(`NODE_ENV="${nodeEnv}" is not a valid value`);
    }

    const duration = Date.now() - startTime;

    if (missingVars.length > 0) {
      return {
        name: 'environment-variables',
        status: 'fail',
        duration,
        message: `Missing required environment variables: ${missingVars.join(', ')}`,
        details: { missing: missingVars },
        critical: true,
      };
    }

    if (invalidVars.length > 0) {
      return {
        name: 'environment-variables',
        status: 'warn',
        duration,
        message: `Invalid environment variable values: ${invalidVars.join(', ')}`,
        details: { invalid: invalidVars },
        critical: false,
      };
    }

    return {
      name: 'environment-variables',
      status: 'pass',
      duration,
      message: 'Environment variables check passed',
      details: { required: requiredVars, optional: optionalVars },
      critical: false,
    };
  }

  /**
   * Check Node.js version
   */
  private async checkNodeVersion(): Promise<HealthCheck> {
    const startTime = Date.now();
    const nodeVersion = process.version;
    const majorVersion = parseInt(nodeVersion.slice(1).split('.')[0]);

    const duration = Date.now() - startTime;

    if (majorVersion < 20) {
      return {
        name: 'node-version',
        status: 'warn',
        duration,
        message: `Node.js version ${nodeVersion} is below recommended minimum (20.x)`,
        details: { version: nodeVersion, recommended: '>=20.x' },
        critical: false,
      };
    }

    return {
      name: 'node-version',
      status: 'pass',
      duration,
      message: `Node.js version check passed: ${nodeVersion}`,
      details: { version: nodeVersion },
      critical: false,
    };
  }

  /**
   * Check memory usage
   */
  private async checkMemoryUsage(): Promise<HealthCheck> {
    const startTime = Date.now();
    const memUsage = process.memoryUsage();
    const totalMemory = os.totalmem();
    const freeMemory = os.freemem();
    const usedMemory = totalMemory - freeMemory;
    const memoryUsagePercent = (usedMemory / totalMemory) * 100;

    const duration = Date.now() - startTime;

    // Check if we're using too much memory
    const heapUsedPercent = (memUsage.heapUsed / memUsage.heapTotal) * 100;

    if (heapUsedPercent > 90) {
      return {
        name: 'memory-usage',
        status: 'fail',
        duration,
        message: `Critical memory usage: ${String(heapUsedPercent.toFixed(1))}%`,
        details: {
          heapUsed: memUsage.heapUsed,
          heapTotal: memUsage.heapTotal,
          heapUsedPercent,
          systemMemoryPercent: memoryUsagePercent,
        },
        critical: true,
      };
    }

    if (heapUsedPercent > 80) {
      return {
        name: 'memory-usage',
        status: 'warn',
        duration,
        message: `High memory usage: ${String(heapUsedPercent.toFixed(1))}%`,
        details: {
          heapUsed: memUsage.heapUsed,
          heapTotal: memUsage.heapTotal,
          heapUsedPercent,
          systemMemoryPercent: memoryUsagePercent,
        },
        critical: false,
      };
    }

    return {
      name: 'memory-usage',
      status: 'pass',
      duration,
      message: `Memory usage check passed: ${String(heapUsedPercent.toFixed(1))}%`,
      details: {
        heapUsed: memUsage.heapUsed,
        heapTotal: memUsage.heapTotal,
        heapUsedPercent,
        systemMemoryPercent: memoryUsagePercent,
      },
      critical: false,
    };
  }

  /**
   * Check disk space
   */
  private async checkDiskSpace(): Promise<HealthCheck> {
    const startTime = Date.now();

    try {
      const stats = fs.statSync(process.cwd());
      const duration = Date.now() - startTime;

      return {
        name: 'disk-space',
        status: 'pass',
        duration,
        message: 'Disk space check passed',
        details: { accessible: true },
        critical: false,
      };
    } catch (error) {
      const duration = Date.now() - startTime;

      return {
        name: 'disk-space',
        status: 'fail',
        duration,
        message: `Disk space check failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
        details: { error: error instanceof Error ? error.message : 'Unknown error' },
        critical: true,
      };
    }
  }

  /**
   * Check Qdrant connection
   */
  private async checkQdrantConnection(): Promise<HealthCheck> {
    const startTime = Date.now();

    try {
      const qdrantUrl = process.env.QDRANT_URL;
      if (!qdrantUrl) {
        throw new Error('QDRANT_URL environment variable is not set');
      }

      const response = await this.fetchWithTimeout(`${qdrantUrl}/health`, 5000);
      const duration = Date.now() - startTime;

      if (response.ok) {
        return {
          name: 'qdrant-connection',
          status: 'pass',
          duration,
          message: 'Qdrant connection check passed',
          details: { url: qdrantUrl, status: response.status },
          critical: true,
        };
      } else {
        return {
          name: 'qdrant-connection',
          status: 'fail',
          duration,
          message: `Qdrant connection failed with status ${response.status}`,
          details: { url: qdrantUrl, status: response.status },
          critical: true,
        };
      }
    } catch (error) {
      const duration = Date.now() - startTime;
      return {
        name: 'qdrant-connection',
        status: 'fail',
        duration,
        message: `Qdrant connection failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
        details: { error: error instanceof Error ? error.message : 'Unknown error' },
        critical: true,
      };
    }
  }

  /**
   * Check OpenAI connection
   */
  private async checkOpenAIConnection(): Promise<HealthCheck> {
    const startTime = Date.now();

    try {
      const apiKey = process.env.OPENAI_API_KEY;
      if (!apiKey) {
        throw new Error('OPENAI_API_KEY environment variable is not set');
      }

      const response = await this.fetchWithTimeout('https://api.openai.com/v1/models', 5000, {
        Authorization: `Bearer ${apiKey}`,
      });
      const duration = Date.now() - startTime;

      if (response.ok) {
        return {
          name: 'openai-connection',
          status: 'pass',
          duration,
          message: 'OpenAI connection check passed',
          details: { status: response.status },
          critical: false,
        };
      } else {
        return {
          name: 'openai-connection',
          status: 'warn',
          duration,
          message: `OpenAI connection failed with status ${response.status}`,
          details: { status: response.status },
          critical: false,
        };
      }
    } catch (error) {
      const duration = Date.now() - startTime;
      return {
        name: 'openai-connection',
        status: 'warn',
        duration,
        message: `OpenAI connection failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
        details: { error: error instanceof Error ? error.message : 'Unknown error' },
        critical: false,
      };
    }
  }

  /**
   * Check file system access
   */
  private async checkFileSystemAccess(): Promise<HealthCheck> {
    const startTime = Date.now();

    try {
      // Test read access
      const packageJson = fs.readFileSync('./package.json', 'utf8');

      // Test write access (create and delete a temp file)
      const testFile = './.health-check-test';
      fs.writeFileSync(testFile, 'test');
      fs.unlinkSync(testFile);

      const duration = Date.now() - startTime;

      return {
        name: 'file-system-access',
        status: 'pass',
        duration,
        message: 'File system access check passed',
        details: { readAccess: true, writeAccess: true },
        critical: false,
      };
    } catch (error) {
      const duration = Date.now() - startTime;
      return {
        name: 'file-system-access',
        status: 'fail',
        duration,
        message: `File system access failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
        details: { error: error instanceof Error ? error.message : 'Unknown error' },
        critical: true,
      };
    }
  }

  /**
   * Check system load
   */
  private async checkSystemLoad(): Promise<HealthCheck> {
    const startTime = Date.now();
    const loadAvg = os.loadavg();
    const cpuCount = os.cpus().length;
    const uptime = os.uptime();

    const duration = Date.now() - startTime;

    // Check 1-minute load average
    const load1Min = loadAvg[0];
    const loadPercent = (load1Min / cpuCount) * 100;

    if (uptime < 5) {
      // Skip load check on recently started systems
      return {
        name: 'system-load',
        status: 'pass',
        duration,
        message: 'System load check skipped (system recently started)',
        details: { load1Min, cpuCount, uptime },
        critical: false,
      };
    }

    if (loadPercent > 90) {
      return {
        name: 'system-load',
        status: 'fail',
        duration,
        message: `Critical system load: ${String(loadPercent.toFixed(1))}%`,
        details: { load1Min, cpuCount, loadPercent },
        critical: true,
      };
    }

    if (loadPercent > 80) {
      return {
        name: 'system-load',
        status: 'warn',
        duration,
        message: `High system load: ${String(loadPercent.toFixed(1))}%`,
        details: { load1Min, cpuCount, loadPercent },
        critical: false,
      };
    }

    return {
      name: 'system-load',
      status: 'pass',
      duration,
      message: `System load check passed: ${String(loadPercent.toFixed(1))}%`,
      details: { load1Min, cpuCount, loadPercent },
      critical: false,
    };
  }

  /**
   * Check cache health (placeholder implementation)
   */
  private async checkCacheHealth(): Promise<HealthCheck> {
    const startTime = Date.now();

    // This is a placeholder - actual implementation would check cache metrics
    const cacheHitRate = 0.85; // Example value
    const queryTime = 150; // Example query time in ms

    const duration = Date.now() - startTime;

    if (queryTime > 5000) {
      return {
        name: 'cache-health',
        status: 'warn',
        duration,
        message: `Slow cache queries: ${queryTime}ms average`,
        details: { queryTime, cacheHitRate },
        critical: false,
      };
    }

    if (cacheHitRate < 0.8) {
      return {
        name: 'cache-health',
        status: 'warn',
        duration,
        message: `Low cache hit rate: ${String((cacheHitRate * 100).toFixed(1))}%`,
        details: { queryTime, cacheHitRate },
        critical: false,
      };
    }

    return {
      name: 'cache-health',
      status: 'pass',
      duration,
      message: `Cache health check passed`,
      details: { queryTime, cacheHitRate },
      critical: false,
    };
  }

  /**
   * Check worker health (placeholder implementation)
   */
  private async checkWorkerHealth(): Promise<HealthCheck> {
    const startTime = Date.now();

    // This is a placeholder - actual implementation would check worker processes
    const workerCount = 4;
    const activeWorkers = 4;

    const duration = Date.now() - startTime;

    if (activeWorkers < workerCount) {
      return {
        name: 'worker-health',
        status: 'warn',
        duration,
        message: `Some workers are not active: ${activeWorkers}/${workerCount}`,
        details: { workerCount, activeWorkers },
        critical: false,
      };
    }

    return {
      name: 'worker-health',
      status: 'pass',
      duration,
      message: `Worker health check passed`,
      details: { workerCount, activeWorkers },
      critical: false,
    };
  }

  /**
   * Aggregate health check results
   */
  private aggregateHealthResults(_checkName: string,  _checks: HealthCheck[]): HealthCheckResult {
    const total = checks.length;
    const passed = checks.filter((check) => check.status === 'pass').length;
    const failed = checks.filter((check) => check.status === 'fail').length;
    const warnings = checks.filter((check) => check.status === 'warn').length;

    const criticalFailures = checks.filter((check) => check.status === 'fail' && check.critical);

    let overallStatus: 'healthy' | 'unhealthy' | 'degraded';
    if (criticalFailures.length > 0) {
      overallStatus = 'unhealthy';
    } else if (failed > 0) {
      overallStatus = 'degraded';
    } else {
      overallStatus = 'healthy';
    }

    const issues = checks
      .filter((check) => check.status !== 'pass')
      .map((check) => `${check.name}: ${check.message || 'Unknown error'}`);

    return {
      status: overallStatus,
      timestamp: new Date().toISOString(),
      duration: checks.reduce((sum,  _check) => sum + check.duration, 0),
      checks,
      summary: {
        total,
        passed,
        failed,
        warnings,
      },
      issues,
      metadata: {
        checkName,
        timestamp: new Date().toISOString(),
      },
    };
  }

  /**
   * Fetch with timeout helper
   */
  private async fetchWithTimeout(
    url: string,
    timeoutMs: number,
    headers: Record<string, string> = {}
  ): Promise<Response> {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => { controller.abort(); }, timeoutMs);

    try {
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'User-Agent': 'Cortex-Memory-Health-Check/2.0.1',
          ...headers,
        },
        signal: controller.signal,
      });

      clearTimeout(timeoutId);
      return response;
    } catch (error) {
      clearTimeout(timeoutId);
      throw error;
    }
  }
}

/**
 * Builder for ProductionHealthChecker
 */
export class ProductionHealthCheckerBuilder {
  private config: Partial<HealthCheckConfig> = {};

  /**
   * Set timeout in milliseconds
   */
  timeoutMs(_timeoutMs: number): this {
    this.config.timeoutMs = timeoutMs;
    return this;
  }

  /**
   * Set timeout in seconds (convenience method)
   */
  timeoutSeconds(_seconds: number): this {
    this.config.timeoutMs = seconds * 1000;
    return this;
  }

  /**
   * Set timeout (legacy property for backward compatibility)
   */
  timeout(_timeout: number): this {
    this.config.timeout = timeout;
    return this;
  }

  /**
   * Set retry attempts
   */
  retryAttempts(_attempts: number): this {
    this.config.retryAttempts = attempts;
    return this;
  }

  /**
   * Set retry attempts (legacy property for backward compatibility)
   */
  retries(_retries: number): this {
    this.config.retries = retries;
    return this;
  }

  /**
   * Set retry delay in milliseconds
   */
  retryDelayMs(_delayMs: number): this {
    this.config.retryDelayMs = delayMs;
    return this;
  }

  /**
   * Set retry delay in seconds (convenience method)
   */
  retryDelaySeconds(_seconds: number): this {
    this.config.retryDelayMs = seconds * 1000;
    return this;
  }

  /**
   * Set retry delay (legacy property for backward compatibility)
   */
  retryDelay(_delay: number): this {
    this.config.retryDelay = delay;
    return this;
  }

  /**
   * Enable or disable detailed checks
   */
  enableDetailedChecks(_enabled: boolean): this {
    this.config.enableDetailedChecks = enabled;
    return this;
  }

  /**
   * Enable or disable optional checks
   */
  skipOptionalChecks(_skip: boolean): this {
    this.config.skipOptionalChecks = skip;
    return this;
  }

  /**
   * Enable or disable health checks
   */
  enabled(_enabled: boolean): this {
    this.config.enabled = enabled;
    return this;
  }

  /**
   * Set check interval in milliseconds
   */
  intervalMs(_intervalMs: number): this {
    this.config.intervalMs = intervalMs;
    return this;
  }

  /**
   * Set check interval in seconds (convenience method)
   */
  intervalSeconds(_seconds: number): this {
    this.config.intervalMs = seconds * 1000;
    return this;
  }

  /**
   * Set failure threshold
   */
  failureThreshold(_threshold: number): this {
    this.config.failureThreshold = threshold;
    return this;
  }

  /**
   * Set success threshold
   */
  successThreshold(_threshold: number): this {
    this.config.successThreshold = threshold;
    return this;
  }

  /**
   * Build the ProductionHealthChecker instance
   */
  build(): ProductionHealthChecker {
    return new ProductionHealthChecker(this.config);
  }
}
export default ProductionHealthChecker;
