/**
 * Notification Channel Implementations for MCP Cortex Alerting
 *
 * Provides concrete implementations for various notification channels:
 * - Email notifications (SMTP, SendGrid, AWS SES)
 * - Slack notifications (Webhooks, Bot API)
 * - PagerDuty notifications (Events API, Webhooks)
 * - Microsoft Teams notifications (Webhooks)
 * - AWS SNS notifications
 * - Generic webhook notifications
 *
 * @author Cortex Team
 * @version 2.0.0
 * @since 2025
 */

import type { Alert } from './alert-management-service.js';
import { logger } from '@/utils/logger.js';

// ============================================================================
// Base Notification Channel Interface
// ============================================================================

export interface NotificationChannel {
  type: string;
  send(alert: Alert, config: unknown): Promise<NotificationResult>;
  validate(config: unknown): boolean;
  healthCheck(config: unknown): Promise<ChannelHealthResult>;
}

export interface NotificationResult {
  success: boolean;
  messageId?: string;
  response?: unknown;
  error?: string;
  metadata?: Record<string, unknown>;
}

export interface ChannelHealthResult {
  healthy: boolean;
  responseTime: number;
  error?: string;
  metadata?: Record<string, unknown>;
}

// ============================================================================
// Email Notification Channel
// ============================================================================

export class EmailNotificationChannel implements NotificationChannel {
  type = 'email';

  async send(alert: Alert, config: EmailConfig): Promise<NotificationResult> {
    try {
      const emailContent = this.generateEmailContent(alert, config);

      switch (config.provider) {
        case 'smtp':
          return await this.sendSMTP(emailContent, config);
        case 'sendgrid':
          return await this.sendSendGrid(emailContent, config);
        case 'ses':
          return await this.sendSES(emailContent, config);
        default:
          throw new Error(`Unsupported email provider: ${config.provider}`);
      }
    } catch (error) {
      logger.error({ alertId: alert.id, error }, 'Failed to send email notification');
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  validate(config: EmailConfig): boolean {
    return !!(
      config.provider &&
      config.to &&
      Array.isArray(config.to) &&
      config.to.length > 0 &&
      config.from &&
      config.subject
    );
  }

  async healthCheck(config: EmailConfig): Promise<ChannelHealthResult> {
    const startTime = Date.now();
    try {
      // Perform a simple connectivity check based on provider
      switch (config.provider) {
        case 'smtp':
          // Check SMTP connectivity
          await this.checkSMTPConnectivity(config);
          break;
        case 'sendgrid':
          // Check SendGrid API
          await this.checkSendGridAPI(config);
          break;
        case 'ses':
          // Check AWS SES
          await this.checkSESAPI(config);
          break;
      }

      return {
        healthy: true,
        responseTime: Date.now() - startTime,
      };
    } catch (error) {
      return {
        healthy: false,
        responseTime: Date.now() - startTime,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  private generateEmailContent(_alert: Alert,  config: EmailConfig): EmailContent {
    const template = config.template || 'default';
    const subject = this.processTemplate(config.subject, alert, config);
    const htmlBody = this.processTemplate(this.getEmailTemplate(template, 'html'), alert, config);
    const textBody = this.processTemplate(this.getEmailTemplate(template, 'text'), alert, config);

    return {
      to: config.to,
      cc: config.cc || [],
      bcc: config.bcc || [],
      from: config.from,
      subject,
      htmlBody,
      textBody,
      attachments: config.attachments || [],
      headers: config.headers || {},
    };
  }

  private processTemplate(_template: string,  _alert: Alert,  config: EmailConfig): string {
    return template
      .replace(/\{\{alert\.id\}\}/g, alert.id)
      .replace(/\{\{alert\.title\}\}/g, alert.title)
      .replace(/\{\{alert\.message\}\}/g, alert.message)
      .replace(/\{\{alert\.severity\}\}/g, alert.severity.toUpperCase())
      .replace(/\{\{alert\.source\.component\}\}/g, alert.source.component)
      .replace(/\{\{alert\.timestamp\}\}/g, alert.timestamp.toISOString())
      .replace(/\{\{alert\.runbookUrl\}\}/g, this.generateRunbookUrl(alert, config));
  }

  private getEmailTemplate(_templateName: string,  _format: 'html' | 'text'): string {
    const templates: Record<string, Record<string, string>> = {
      default: {
        html: `
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>{{alert.title}}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { background: #f8f9fa; padding: 20px; border-radius: 5px; margin-bottom: 20px; }
        .severity-critical { border-left: 5px solid #dc3545; }
        .severity-warning { border-left: 5px solid #ffc107; }
        .severity-info { border-left: 5px solid #17a2b8; }
        .content { line-height: 1.6; }
        .footer { margin-top: 30px; padding-top: 20px; border-top: 1px solid #eee; color: #666; }
        .btn { display: inline-block; padding: 10px 20px; background: #007bff; color: white; text-decoration: none; border-radius: 5px; }
    </style>
</head>
<body>
    <div class="header severity-{{alert.severity}}">
        <h2>{{alert.title}}</h2>
        <p><strong>Severity:</strong> {{alert.severity.toUpperCase()}}</p>
        <p><strong>Time:</strong> {{alert.timestamp}}</p>
        <p><strong>Component:</strong> {{alert.source.component}}</p>
    </div>

    <div class="content">
        <h3>Details</h3>
        <p>{{alert.message}}</p>

        <h3>Source Information</h3>
        <ul>
            <li><strong>Component:</strong> {{alert.source.component}}</li>
            <li><strong>Metric:</strong> {{alert.source.metric}}</li>
            <li><strong>Current Value:</strong> {{alert.source.value}}</li>
            <li><strong>Threshold:</strong> {{alert.source.threshold}}</li>
        </ul>

        {{#if alert.runbookUrl}}
        <h3>Runbook</h3>
        <p><a href="{{alert.runbookUrl}}" class="btn">View Runbook</a></p>
        {{/if}}
    </div>

    <div class="footer">
        <p>This alert was generated by MCP Cortex Monitoring System.</p>
        <p>If you believe this is a false positive, please contact the operations team.</p>
    </div>
</body>
</html>`,
        text: `
ALERT: {{alert.title}}

Severity: {{alert.severity.toUpperCase()}}
Time: {{alert.timestamp}}
Component: {{alert.source.component}}

Details:
{{alert.message}}

Source Information:
- Component: {{alert.source.component}}
- Metric: {{alert.source.metric}}
- Current Value: {{alert.source.value}}
- Threshold: {{alert.source.threshold}}

{{#if alert.runbookUrl}}
Runbook: {{alert.runbookUrl}}
{{/if}}

---
This alert was generated by MCP Cortex Monitoring System.
`,
      },
      'database-down': {
        html: `
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>CRITICAL: Database Connectivity Loss</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .alert-critical { background: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; padding: 20px; border-radius: 5px; margin-bottom: 20px; }
        .section { margin: 20px 0; }
        .btn { display: inline-block; padding: 10px 20px; background: #dc3545; color: white; text-decoration: none; border-radius: 5px; }
        .btn-secondary { background: #6c757d; }
    </style>
</head>
<body>
    <div class="alert-critical">
        <h2>üö® CRITICAL: Database Connectivity Loss</h2>
        <p>The system has lost connectivity to the primary database. Immediate action is required.</p>
    </div>

    <div class="section">
        <h3>Impact</h3>
        <ul>
            <li>All database operations are failing</li>
            <li>Application functionality is severely impacted</li>
            <li>Data persistence is not available</li>
        </ul>
    </div>

    <div class="section">
        <h3>Immediate Actions Required</h3>
        <ol>
            <li>Verify database server status</li>
            <li>Check network connectivity</li>
            <li>Review database logs for errors</li>
            <li>Initiate failover procedures if necessary</li>
        </ol>
    </div>

    <div class="section">
        <h3>Quick Actions</h3>
        <p><a href="#" class="btn">Acknowledge Alert</a> <a href="#" class="btn btn-secondary">View Dashboard</a></p>
    </div>
</body>
</html>`,
        text: `
CRITICAL: Database Connectivity Loss

The system has lost connectivity to the primary database. Immediate action is required.

IMPACT:
- All database operations are failing
- Application functionality is severely impacted
- Data persistence is not available

IMMEDIATE ACTIONS REQUIRED:
1. Verify database server status
2. Check network connectivity
3. Review database logs for errors
4. Initiate failover procedures if necessary

Quick Actions:
- Acknowledge Alert: [Link]
- View Dashboard: [Link]

---
Generated by MCP Cortex Monitoring System at {{alert.timestamp}}
`,
      },
      'memory-pressure': {
        html: `
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>WARNING: High Memory Usage Detected</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .alert-warning { background: #fff3cd; border: 1px solid #ffeaa7; color: #856404; padding: 20px; border-radius: 5px; margin-bottom: 20px; }
        .metric { background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 10px 0; }
        .btn { display: inline-block; padding: 10px 20px; background: #ffc107; color: #212529; text-decoration: none; border-radius: 5px; }
    </style>
</head>
<body>
    <div class="alert-warning">
        <h2>‚ö†Ô∏è WARNING: High Memory Usage Detected</h2>
        <p>System memory usage has exceeded the warning threshold. Performance may be impacted.</p>
    </div>

    <div class="section">
        <h3>Current Metrics</h3>
        <div class="metric">
            <strong>Memory Usage:</strong> {{alert.source.value}}%
            <br><strong>Threshold:</strong> {{alert.source.threshold}}%
        </div>
    </div>

    <div class="section">
        <h3>Recommended Actions</h3>
        <ul>
            <li>Monitor memory usage trends</li>
            <li>Check for memory leaks in application</li>
            <li>Consider scaling resources if usage continues</li>
            <li>Review recent deployments for issues</li>
        </ul>
    </div>
</body>
</html>`,
        text: `
WARNING: High Memory Usage Detected

System memory usage has exceeded the warning threshold. Performance may be impacted.

CURRENT METRICS:
Memory Usage: {{alert.source.value}}%
Threshold: {{alert.source.threshold}}

RECOMMENDED ACTIONS:
- Monitor memory usage trends
- Check for memory leaks in application
- Consider scaling resources if usage continues
- Review recent deployments for issues

---
Generated by MCP Cortex Monitoring System at {{alert.timestamp}}
`,
      },
    };

    return templates[templateName]?.[format] || templates.default[format];
  }

  private generateRunbookUrl(_alert: Alert,  config: EmailConfig): string {
    const baseUrl = config.runbookBaseUrl || 'https://docs.example.com/runbooks';
    return `${baseUrl}/${alert.ruleId}`;
  }

  private async sendSMTP(email: EmailContent, config: EmailConfig): Promise<NotificationResult> {
    // Placeholder for SMTP implementation
    // In a real implementation, you would use nodemailer or similar
    logger.info(
      {
        to: email.to,
        subject: email.subject,
        provider: 'smtp',
      },
      'Sending SMTP email'
    );

    return {
      success: true,
      messageId: `smtp-${Date.now()}`,
      metadata: {
        provider: 'smtp',
        recipients: email.to.length,
      },
    };
  }

  private async sendSendGrid(
    email: EmailContent,
    config: EmailConfig
  ): Promise<NotificationResult> {
    // Placeholder for SendGrid implementation
    if (!config.apiKey) {
      throw new Error('SendGrid API key is required');
    }

    logger.info(
      {
        to: email.to,
        subject: email.subject,
        provider: 'sendgrid',
      },
      'Sending SendGrid email'
    );

    return {
      success: true,
      messageId: `sg-${Date.now()}`,
      metadata: {
        provider: 'sendgrid',
        recipients: email.to.length,
      },
    };
  }

  private async sendSES(email: EmailContent, config: EmailConfig): Promise<NotificationResult> {
    // Placeholder for AWS SES implementation
    if (!config.region || !config.accessKeyId || !config.secretAccessKey) {
      throw new Error('AWS SES credentials are required');
    }

    logger.info(
      {
        to: email.to,
        subject: email.subject,
        provider: 'ses',
        region: config.region,
      },
      'Sending SES email'
    );

    return {
      success: true,
      messageId: `ses-${Date.now()}`,
      metadata: {
        provider: 'ses',
        recipients: email.to.length,
        region: config.region,
      },
    };
  }

  private async checkSMTPConnectivity(config: EmailConfig): Promise<void> {
    // Placeholder for SMTP connectivity check
    logger.debug({ provider: 'smtp' }, 'Checking SMTP connectivity');
  }

  private async checkSendGridAPI(config: EmailConfig): Promise<void> {
    // Placeholder for SendGrid API check
    if (!config.apiKey) {
      throw new Error('SendGrid API key is required');
    }
    logger.debug({ provider: 'sendgrid' }, 'Checking SendGrid API');
  }

  private async checkSESAPI(config: EmailConfig): Promise<void> {
    // Placeholder for AWS SES API check
    if (!config.region) {
      throw new Error('AWS region is required');
    }
    logger.debug({ provider: 'ses', region: config.region }, 'Checking AWS SES API');
  }
}

// ============================================================================
// Slack Notification Channel
// ============================================================================

export class SlackNotificationChannel implements NotificationChannel {
  type = 'slack';

  async send(alert: Alert, config: SlackConfig): Promise<NotificationResult> {
    try {
      const payload = this.generateSlackPayload(alert, config);

      if (config.webhookUrl) {
        return await this.sendWebhook(payload, config);
      } else if (config.botToken) {
        return await this.sendBotAPI(payload, config);
      } else {
        throw new Error('Either webhookUrl or botToken is required for Slack notifications');
      }
    } catch (error) {
      logger.error({ alertId: alert.id, error }, 'Failed to send Slack notification');
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  validate(config: SlackConfig): boolean {
    return !!(
      (config.webhookUrl || config.botToken) &&
      (config.channel || config.webhookUrl) // Channel not needed for webhooks
    );
  }

  async healthCheck(config: SlackConfig): Promise<ChannelHealthResult> {
    const startTime = Date.now();
    try {
      if (config.webhookUrl) {
        await this.checkWebhookHealth(config);
      } else if (config.botToken) {
        await this.checkBotAPIHealth(config);
      } else {
        throw new Error('No valid Slack configuration found');
      }

      return {
        healthy: true,
        responseTime: Date.now() - startTime,
      };
    } catch (error) {
      return {
        healthy: false,
        responseTime: Date.now() - startTime,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  private generateSlackPayload(_alert: Alert,  config: SlackConfig): SlackPayload {
    const color = this.getSeverityColor(alert.severity);
    const emoji = this.getSeverityEmoji(alert.severity);

    const payload: SlackPayload = {
      username: config.username || 'MCP Cortex Alerts',
      icon_emoji: config.iconEmoji || ':robot_face:',
      channel: config.channel,
      attachments: [
        {
          color,
          title: `${emoji} ${alert.title}`,
          text: alert.message,
          fields: [
            {
              title: 'Severity',
              value: alert.severity.toUpperCase(),
              short: true,
            },
            {
              title: 'Component',
              value: alert.source.component,
              short: true,
            },
            {
              title: 'Metric',
              value: `${alert.source.metric}: ${alert.source.value}`,
              short: true,
            },
            {
              title: 'Threshold',
              value: alert.source.threshold.toString(),
              short: true,
            },
            {
              title: 'Time',
              value: alert.timestamp.toLocaleString(),
              short: true,
            },
            {
              title: 'Status',
              value: alert.status,
              short: true,
            },
          ],
          footer: 'MCP Cortex Monitoring',
          ts: Math.floor(alert.timestamp.getTime() / 1000),
          actions: this.generateSlackActions(alert, config),
        },
      ],
    };

    return payload;
  }

  private getSeverityColor(severity: string): string {
    switch (_severity) {
      case 'emergency':
      case 'critical':
        return '#dc3545'; // Red
      case 'warning':
        return '#ffc107'; // Yellow
      case 'info':
        return '#17a2b8'; // Blue
      default:
        return '#6c757d'; // Gray
    }
  }

  private getSeverityEmoji(severity: string): string {
    switch (_severity) {
      case 'emergency':
        return 'üö®';
      case 'critical':
        return 'üî•';
      case 'warning':
        return '‚ö†Ô∏è';
      case 'info':
        return '‚ÑπÔ∏è';
      default:
        return 'üìã';
    }
  }

  private generateSlackActions(_alert: Alert,  config: SlackConfig): SlackAction[] {
    const actions: SlackAction[] = [];

    if (config.enableAcknowledge && alert.status === 'firing') {
      actions.push({
        type: 'button',
        text: 'Acknowledge',
        url: `${config.baseUrl}/alerts/${alert.id}/acknowledge`,
        style: 'primary',
      });
    }

    if (config.enableResolve) {
      actions.push({
        type: 'button',
        text: 'Resolve',
        url: `${config.baseUrl}/alerts/${alert.id}/resolve`,
        style: 'danger',
      });
    }

    if (config.runbookUrl) {
      actions.push({
        type: 'button',
        text: 'View Runbook',
        url: `${config.runbookUrl}/${alert.ruleId}`,
      });
    }

    if (config.dashboardUrl) {
      actions.push({
        type: 'button',
        text: 'View Dashboard',
        url: config.dashboardUrl,
      });
    }

    return actions;
  }

  private async sendWebhook(
    payload: SlackPayload,
    config: SlackConfig
  ): Promise<NotificationResult> {
    // Placeholder for webhook implementation
    logger.info(
      {
        channel: config.channel,
        provider: 'slack-webhook',
      },
      'Sending Slack webhook'
    );

    return {
      success: true,
      messageId: `slack-webhook-${Date.now()}`,
      metadata: {
        provider: 'slack-webhook',
        channel: config.channel,
      },
    };
  }

  private async sendBotAPI(
    payload: SlackPayload,
    config: SlackConfig
  ): Promise<NotificationResult> {
    // Placeholder for Bot API implementation
    if (!config.botToken) {
      throw new Error('Bot token is required for Slack Bot API');
    }

    logger.info(
      {
        channel: config.channel,
        provider: 'slack-bot',
      },
      'Sending Slack Bot API message'
    );

    return {
      success: true,
      messageId: `slack-bot-${Date.now()}`,
      metadata: {
        provider: 'slack-bot',
        channel: config.channel,
      },
    };
  }

  private async checkWebhookHealth(config: SlackConfig): Promise<void> {
    // Placeholder for webhook health check
    logger.debug({ provider: 'slack-webhook' }, 'Checking Slack webhook health');
  }

  private async checkBotAPIHealth(config: SlackConfig): Promise<void> {
    // Placeholder for Bot API health check
    if (!config.botToken) {
      throw new Error('Bot token is required for health check');
    }
    logger.debug({ provider: 'slack-bot' }, 'Checking Slack Bot API health');
  }
}

// ============================================================================
// PagerDuty Notification Channel
// ============================================================================

export class PagerDutyNotificationChannel implements NotificationChannel {
  type = 'pagerduty';

  async send(alert: Alert, config: PagerDutyConfig): Promise<NotificationResult> {
    try {
      const event = this.generatePagerDutyEvent(alert, config);
      return await this.sendEvent(event, config);
    } catch (error) {
      logger.error({ alertId: alert.id, error }, 'Failed to send PagerDuty notification');
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  validate(config: PagerDutyConfig): boolean {
    return !!(config.integrationKey || config.apiKey);
  }

  async healthCheck(config: PagerDutyConfig): Promise<ChannelHealthResult> {
    const startTime = Date.now();
    try {
      if (config.apiKey) {
        await this.checkAPIHealth(config);
      } else if (config.integrationKey) {
        await this.checkEventsAPIHealth(config);
      } else {
        throw new Error('No valid PagerDuty configuration found');
      }

      return {
        healthy: true,
        responseTime: Date.now() - startTime,
      };
    } catch (error) {
      return {
        healthy: false,
        responseTime: Date.now() - startTime,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  private generatePagerDutyEvent(_alert: Alert,  config: PagerDutyConfig): PagerDutyEvent {
    const severity = this.mapSeverityToPagerDuty(alert.severity);

    const event: PagerDutyEvent = {
      routing_key: config.integrationKey!,
      event_action: 'trigger',
      dedup_key: alert.id,
      payload: {
        summary: alert.title,
        source: alert.source.component,
        severity,
        timestamp: alert.timestamp.toISOString(),
        component: alert.source.component,
        group: 'mcp-cortex',
        class: 'system-alert',
        custom_details: {
          alertId: alert.id,
          ruleId: alert.ruleId,
          ruleName: alert.ruleName,
          message: alert.message,
          metric: alert.source.metric,
          value: alert.source.value,
          threshold: alert.source.threshold,
          severity: alert.severity,
          status: alert.status,
          runbookId: alert.metadata?.runbookId,
        },
      },
    };

    if (config.escalationPolicy) {
      event.payload.escalation_policy = {
        id: config.escalationPolicy,
      };
    }

    if (config.assignee) {
      event.payload.assigned_to = config.assignee;
    }

    return event;
  }

  private mapSeverityToPagerDuty(severity: string): 'critical' | 'error' | 'warning' | 'info' {
    switch (_severity) {
      case 'emergency':
      case 'critical':
        return 'critical';
      case 'warning':
        return 'warning';
      case 'info':
        return 'info';
      default:
        return 'error';
    }
  }

  private async sendEvent(
    event: PagerDutyEvent,
    config: PagerDutyConfig
  ): Promise<NotificationResult> {
    // Placeholder for PagerDuty Events API implementation
    logger.info(
      {
        dedupKey: event.dedup_key,
        severity: event.payload.severity,
        provider: 'pagerduty-events',
      },
      'Sending PagerDuty event'
    );

    return {
      success: true,
      messageId: `pd-${Date.now()}`,
      metadata: {
        provider: 'pagerduty-events',
        dedupKey: event.dedup_key,
        incidentId: `incident-${Date.now()}`,
      },
    };
  }

  private async checkAPIHealth(config: PagerDutyConfig): Promise<void> {
    // Placeholder for PagerDuty REST API health check
    if (!config.apiKey) {
      throw new Error('API key is required for health check');
    }
    logger.debug({ provider: 'pagerduty-api' }, 'Checking PagerDuty API health');
  }

  private async checkEventsAPIHealth(config: PagerDutyConfig): Promise<void> {
    // Placeholder for PagerDuty Events API health check
    if (!config.integrationKey) {
      throw new Error('Integration key is required for health check');
    }
    logger.debug({ provider: 'pagerduty-events' }, 'Checking PagerDuty Events API health');
  }
}

// ============================================================================
// Teams Notification Channel
// ============================================================================

export class TeamsNotificationChannel implements NotificationChannel {
  type = 'teams';

  async send(alert: Alert, config: TeamsConfig): Promise<NotificationResult> {
    try {
      const payload = this.generateTeamsPayload(alert, config);
      return await this.sendWebhook(payload, config);
    } catch (error) {
      logger.error({ alertId: alert.id, error }, 'Failed to send Teams notification');
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  validate(config: TeamsConfig): boolean {
    return !!config.webhookUrl;
  }

  async healthCheck(config: TeamsConfig): Promise<ChannelHealthResult> {
    const startTime = Date.now();
    try {
      await this.checkWebhookHealth(config);
      return {
        healthy: true,
        responseTime: Date.now() - startTime,
      };
    } catch (error) {
      return {
        healthy: false,
        responseTime: Date.now() - startTime,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  private generateTeamsPayload(_alert: Alert,  config: TeamsConfig): TeamsPayload {
    const themeColor = this.getSeverityColor(alert.severity);
    const summary = `[${alert.severity.toUpperCase()}] ${alert.title}`;

    const payload: TeamsPayload = {
      '@type': 'MessageCard',
      '@context': 'http://schema.org/extensions',
      summary,
      themeColor,
      sections: [
        {
          activityTitle: alert.title,
          activitySubtitle: `Severity: ${alert.severity.toUpperCase()}`,
          activityImage: this.getSeverityImage(alert.severity),
          facts: [
            {
              name: 'Component',
              value: alert.source.component,
            },
            {
              name: 'Metric',
              value: `${alert.source.metric}: ${alert.source.value}`,
            },
            {
              name: 'Threshold',
              value: alert.source.threshold.toString(),
            },
            {
              name: 'Time',
              value: alert.timestamp.toLocaleString(),
            },
            {
              name: 'Status',
              value: alert.status,
            },
          ],
          text: alert.message,
        },
      ],
      potentialActions: this.generateTeamsActions(alert, config),
    };

    return payload;
  }

  private getSeverityColor(severity: string): string {
    switch (_severity) {
      case 'emergency':
      case 'critical':
        return 'FF0000'; // Red
      case 'warning':
        return 'FFA500'; // Orange
      case 'info':
        return '0078D4'; // Blue
      default:
        return '808080'; // Gray
    }
  }

  private getSeverityImage(severity: string): string {
    switch (_severity) {
      case 'emergency':
        return 'https://img.icons8.com/color/48/000000/alarm.png';
      case 'critical':
        return 'https://img.icons8.com/color/48/000000/fire.png';
      case 'warning':
        return 'https://img.icons8.com/color/48/000000/warning.png';
      case 'info':
        return 'https://img.icons8.com/color/48/000000/info.png';
      default:
        return 'https://img.icons8.com/color/48/000000/info.png';
    }
  }

  private generateTeamsActions(_alert: Alert,  config: TeamsConfig): TeamsAction[] {
    const actions: TeamsAction[] = [];

    if (config.enableAcknowledge && alert.status === 'firing') {
      actions.push({
        '@type': 'OpenUri',
        name: 'Acknowledge',
        targets: [
          {
            os: 'default',
            uri: `${config.baseUrl}/alerts/${alert.id}/acknowledge`,
          },
        ],
      });
    }

    if (config.enableResolve) {
      actions.push({
        '@type': 'OpenUri',
        name: 'Resolve',
        targets: [
          {
            os: 'default',
            uri: `${config.baseUrl}/alerts/${alert.id}/resolve`,
          },
        ],
      });
    }

    if (config.runbookUrl) {
      actions.push({
        '@type': 'OpenUri',
        name: 'View Runbook',
        targets: [
          {
            os: 'default',
            uri: `${config.runbookUrl}/${alert.ruleId}`,
          },
        ],
      });
    }

    if (config.dashboardUrl) {
      actions.push({
        '@type': 'OpenUri',
        name: 'View Dashboard',
        targets: [
          {
            os: 'default',
            uri: config.dashboardUrl,
          },
        ],
      });
    }

    return actions;
  }

  private async sendWebhook(
    payload: TeamsPayload,
    config: TeamsConfig
  ): Promise<NotificationResult> {
    // Placeholder for Teams webhook implementation
    logger.info(
      {
        provider: 'teams-webhook',
      },
      'Sending Teams webhook'
    );

    return {
      success: true,
      messageId: `teams-${Date.now()}`,
      metadata: {
        provider: 'teams-webhook',
      },
    };
  }

  private async checkWebhookHealth(config: TeamsConfig): Promise<void> {
    // Placeholder for Teams webhook health check
    logger.debug({ provider: 'teams-webhook' }, 'Checking Teams webhook health');
  }
}

// ============================================================================
// Webhook Notification Channel
// ============================================================================

export class WebhookNotificationChannel implements NotificationChannel {
  type = 'webhook';

  async send(alert: Alert, config: WebhookConfig): Promise<NotificationResult> {
    try {
      const payload = this.generateWebhookPayload(alert, config);
      return await this.sendWebhookRequest(payload, config);
    } catch (error) {
      logger.error({ alertId: alert.id, error }, 'Failed to send webhook notification');
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  validate(config: WebhookConfig): boolean {
    return !!(config.url && config.method);
  }

  async healthCheck(config: WebhookConfig): Promise<ChannelHealthResult> {
    const startTime = Date.now();
    try {
      await this.checkWebhookHealth(config);
      return {
        healthy: true,
        responseTime: Date.now() - startTime,
      };
    } catch (error) {
      return {
        healthy: false,
        responseTime: Date.now() - startTime,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  private generateWebhookPayload(_alert: Alert,  config: WebhookConfig): unknown {
    const basePayload = {
      alert: {
        id: alert.id,
        title: alert.title,
        message: alert.message,
        severity: alert.severity,
        status: alert.status,
        timestamp: alert.timestamp.toISOString(),
        source: alert.source,
        ruleId: alert.ruleId,
        ruleName: alert.ruleName,
      },
      metadata: alert.metadata,
    };

    if (config.template) {
      // Apply custom template
      return this.applyTemplate(config.template, basePayload, alert);
    }

    return basePayload;
  }

  private applyTemplate(_template: unknown,  _basePayload: unknown,  _alert: Alert): unknown {
    // Simple template processing - in a real implementation, you might use a template engine
    if (typeof template === 'string') {
      return JSON.parse(template.replace(/\{\{alert\}\}/g, JSON.stringify(basePayload.alert)));
    } else if (typeof template === 'object') {
      return { ...template, ...basePayload };
    }
    return basePayload;
  }

  private async sendWebhookRequest(
    payload: unknown,
    config: WebhookConfig
  ): Promise<NotificationResult> {
    // Placeholder for webhook request implementation
    logger.info(
      {
        url: config.url,
        method: config.method,
        provider: 'webhook',
      },
      'Sending webhook request'
    );

    return {
      success: true,
      messageId: `webhook-${Date.now()}`,
      metadata: {
        provider: 'webhook',
        url: config.url,
        method: config.method,
      },
    };
  }

  private async checkWebhookHealth(config: WebhookConfig): Promise<void> {
    // Placeholder for webhook health check
    logger.debug({ url: config.url, provider: 'webhook' }, 'Checking webhook health');
  }
}

// ============================================================================
// SNS Notification Channel
// ============================================================================

export class SNSNotificationChannel implements NotificationChannel {
  type = 'sns';

  async send(alert: Alert, config: SNSConfig): Promise<NotificationResult> {
    try {
      const message = this.generateSNSMessage(alert, config);
      return await this.publishMessage(message, config);
    } catch (error) {
      logger.error({ alertId: alert.id, error }, 'Failed to send SNS notification');
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  validate(config: SNSConfig): boolean {
    return !!(config.topicArn && config.region);
  }

  async healthCheck(config: SNSConfig): Promise<ChannelHealthResult> {
    const startTime = Date.now();
    try {
      await this.checkSNSHealth(config);
      return {
        healthy: true,
        responseTime: Date.now() - startTime,
      };
    } catch (error) {
      return {
        healthy: false,
        responseTime: Date.now() - startTime,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  private generateSNSMessage(_alert: Alert,  config: SNSConfig): SNSMessage {
    const message = {
      alert: {
        id: alert.id,
        title: alert.title,
        message: alert.message,
        severity: alert.severity,
        status: alert.status,
        timestamp: alert.timestamp.toISOString(),
        source: alert.source,
        ruleId: alert.ruleId,
        ruleName: alert.ruleName,
      },
      metadata: alert.metadata,
    };

    return {
      TopicArn: config.topicArn,
      Message: JSON.stringify(message),
      Subject: `[${alert.severity.toUpperCase()}] ${alert.title}`,
      MessageAttributes: {
        severity: {
          DataType: 'String',
          StringValue: alert.severity,
        },
        component: {
          DataType: 'String',
          StringValue: alert.source.component,
        },
        alertId: {
          DataType: 'String',
          StringValue: alert.id,
        },
      },
    };
  }

  private async publishMessage(
    message: SNSMessage,
    config: SNSConfig
  ): Promise<NotificationResult> {
    // Placeholder for SNS implementation
    logger.info(
      {
        topicArn: config.topicArn,
        subject: message.Subject,
        provider: 'sns',
      },
      'Publishing SNS message'
    );

    return {
      success: true,
      messageId: `sns-${Date.now()}`,
      metadata: {
        provider: 'sns',
        topicArn: config.topicArn,
        messageId: `message-${Date.now()}`,
      },
    };
  }

  private async checkSNSHealth(config: SNSConfig): Promise<void> {
    // Placeholder for SNS health check
    logger.debug({ topicArn: config.topicArn, provider: 'sns' }, 'Checking SNS health');
  }
}

// ============================================================================
// Notification Channel Registry
// ============================================================================

export class NotificationChannelRegistry {
  private channels: Map<string, NotificationChannel> = new Map();

  constructor() {
    this.registerDefaultChannels();
  }

  private registerDefaultChannels(): void {
    this.register(new EmailNotificationChannel());
    this.register(new SlackNotificationChannel());
    this.register(new PagerDutyNotificationChannel());
    this.register(new TeamsNotificationChannel());
    this.register(new WebhookNotificationChannel());
    this.register(new SNSNotificationChannel());
  }

  register(_channel: NotificationChannel): void {
    this.channels.set(channel.type, channel);
  }

  get(type: string): NotificationChannel | undefined {
    return this.channels.get(type);
  }

  getAll(): NotificationChannel[] {
    return Array.from(this.channels.values());
  }

  validateConfig(type: string,  config: unknown): boolean {
    const channel = this.get(type);
    return channel ? channel.validate(config) : false;
  }
}

// Export singleton instance
export const notificationChannelRegistry = new NotificationChannelRegistry();

// ============================================================================
// Configuration Interfaces
// ============================================================================

export interface EmailConfig {
  provider: 'smtp' | 'sendgrid' | 'ses';
  to: string[];
  cc?: string[];
  bcc?: string[];
  from: string;
  subject: string;
  template?: string;
  attachments?: unknown[];
  headers?: Record<string, string>;
  runbookBaseUrl?: string;

  // SMTP specific
  host?: string;
  port?: number;
  secure?: boolean;
  auth?: {
    user: string;
    pass: string;
  };

  // SendGrid specific
  apiKey?: string;

  // SES specific
  region?: string;
  accessKeyId?: string;
  secretAccessKey?: string;
}

export interface SlackConfig {
  webhookUrl?: string;
  botToken?: string;
  channel?: string;
  username?: string;
  iconEmoji?: string;
  enableAcknowledge?: boolean;
  enableResolve?: boolean;
  baseUrl?: string;
  runbookUrl?: string;
  dashboardUrl?: string;
}

export interface PagerDutyConfig {
  integrationKey?: string; // Events API v2
  apiKey?: string; // REST API
  escalationPolicy?: string;
  assignee?: {
    id: string;
    type: 'user_reference' | 'escalation_policy_reference';
  };
}

export interface TeamsConfig {
  webhookUrl: string;
  enableAcknowledge?: boolean;
  enableResolve?: boolean;
  baseUrl?: string;
  runbookUrl?: string;
  dashboardUrl?: string;
}

export interface WebhookConfig {
  url: string;
  method: 'POST' | 'PUT' | 'PATCH';
  headers?: Record<string, string>;
  timeout?: number;
  retryAttempts?: number;
  template?: unknown;
}

export interface SNSConfig {
  topicArn: string;
  region: string;
  accessKeyId?: string;
  secretAccessKey?: string;
}

// ============================================================================
// Message Interfaces
// ============================================================================

export interface EmailContent {
  to: string[];
  cc: string[];
  bcc: string[];
  from: string;
  subject: string;
  htmlBody: string;
  textBody: string;
  attachments: unknown[];
  headers: Record<string, string>;
}

export interface SlackPayload {
  username?: string;
  icon_emoji?: string;
  channel?: string;
  attachments: SlackAttachment[];
}

export interface SlackAttachment {
  color: string;
  title: string;
  text?: string;
  fields: SlackField[];
  footer?: string;
  ts?: number;
  actions?: SlackAction[];
}

export interface SlackField {
  title: string;
  value: string;
  short: boolean;
}

export interface SlackAction {
  type: string;
  text: string;
  url?: string;
  style?: string;
}

export interface PagerDutyEvent {
  routing_key: string;
  event_action: 'trigger' | 'acknowledge' | 'resolve';
  dedup_key?: string;
  payload: {
    summary: string;
    source: string;
    severity: 'critical' | 'error' | 'warning' | 'info';
    timestamp: string;
    component?: string;
    group?: string;
    class?: string;
    custom_details?: Record<string, unknown>;
    escalation_policy?: unknown;
    assigned_to?: unknown;
  };
}

export interface TeamsPayload {
  '@type': string;
  '@context': string;
  summary: string;
  themeColor: string;
  sections: TeamsSection[];
  potentialActions?: TeamsAction[];
}

export interface TeamsSection {
  activityTitle?: string;
  activitySubtitle?: string;
  activityImage?: string;
  facts: TeamsFact[];
  text?: string;
}

export interface TeamsFact {
  name: string;
  value: string;
}

export interface TeamsAction {
  '@type': string;
  name: string;
  targets: TeamsTarget[];
}

export interface TeamsTarget {
  os: string;
  uri: string;
}

export interface SNSMessage {
  TopicArn: string;
  Message: string;
  Subject?: string;
  MessageAttributes?: Record<
    string,
    {
      DataType: string;
      StringValue?: string;
      BinaryValue?: Buffer;
    }
  >;
}
