/**
 * Alert Metrics Collectors Module
 *
 * Responsible for collecting metrics from various sources:
 * - Alert management metrics
 * - System performance metrics
 * - Notification channel metrics
 * - Health check metrics
 *
 * @author Cortex Team
 * @version 2.0.0
 * @since 2025
 */

import { EventEmitter } from 'events';
import { createQdrantError, ErrorCodes } from '../../../db/adapters/modules/error-contract.js';
import { logger } from '@/utils/logger.js';

/**
 * Base collector interface
 */
export interface MetricsCollector {
  start(): Promise<void>;
  stop(): Promise<void>;
  collect(): Promise<CollectedMetrics>;
  isRunning(): boolean;
}

/**
 * Collected metrics interface
 */
export interface CollectedMetrics {
  timestamp: Date;
  source: string;
  _metrics: Record<string, unknown>;
  metadata?: Record<string, unknown>;
}

/**
 * Alert metrics collector
 */
export class AlertMetricsCollector extends EventEmitter implements MetricsCollector {
  private isRunningFlag = false;
  private collectionInterval: NodeJS.Timeout | null = null;

  constructor(
    private alertManagementService: unknown, 
    private config: {
      intervalMs: number;
      batchSize: number;
      timeoutMs: number;
    }
  ) {
    super();
  }

  async start(): Promise<void> {
    try {
      if (this.isRunningFlag) {
        logger.warn('Alert metrics collector already running');
        return;
      }

      logger.info('Starting alert metrics collector');
      this.isRunningFlag = true;

      // Collect metrics on interval
      this.collectionInterval = setInterval(async () => {
        if (this.isRunningFlag) {
          try {
            const metrics = await this.collect();
            this.emit('metrics_collected', metrics);
          } catch (error) {
            logger.error({ error }, 'Error collecting alert metrics');
            this.emit('collection_error', error);
          }
        }
      }, this.config.intervalMs);

      logger.info('Alert metrics collector started');
    } catch (error) {
      logger.error({ error }, 'Failed to start alert metrics collector');
      throw createQdrantError(
        'Failed to start alert metrics collector',
        ErrorCodes.METRICS_ERROR,
        error as Error
      );
    }
  }

 stop(): Promise<void> {
    try {
      logger.info('Stopping alert metrics collector');
      this.isRunningFlag = false;

      if (this.collectionInterval) {
        clearInterval(this.collectionInterval);
        this.collectionInterval = null;
      }

      this.removeAllListeners();
      logger.info('Alert metrics collector stopped');
    } catch (error) {
      logger.error({ error }, 'Failed to stop alert metrics collector');
    }
  }

  isRunning(): boolean {
    return this.isRunningFlag;
  }

 collect(): Promise<CollectedMetrics> {
    try {
      const timestamp = new Date();

      // Get metrics from alert management service
      const alertMetrics = this.alertManagementService.getAlertMetrics();
      const activeAlerts = this.alertManagementService.getActiveAlerts();
      const alertHistory = this.alertManagementService.getAlertHistory();

      const _metrics: Record<string, unknown> = {
        // Basic counts
        total: alertMetrics.total || 0,
        active: alertMetrics.active || 0,
        resolved: alertMetrics.resolved || 0,
        acknowledged: alertMetrics.acknowledged || 0,
        suppressed: alertMetrics.suppressed || 0,

        // By severity
        bySeverity: alertMetrics.bySeverity || {},

        // By status
        byStatus: alertMetrics.byStatus || {},

        // By rule
        byRule: alertMetrics.byRule || {},

        // By component
        byComponent: alertMetrics.byComponent || {},

        // By source
        bySource: alertMetrics.bySource || {},

        // Performance metrics
        notificationsSent: alertMetrics.notificationsSent || 0,
        notificationSuccessRate: alertMetrics.notificationSuccessRate || 0,
        averageResponseTime: alertMetrics.averageResponseTime || 0,

        // Calculated metrics
        activeAlertsCount: activeAlerts.length,
        historicalAlertsCount: alertHistory.length,
        resolutionRate: this.calculateResolutionRate(alertHistory),
        acknowledgmentRate: this.calculateAcknowledgmentRate(alertHistory),
        escalationRate: this.calculateEscalationRate(alertHistory),

        // Time-based metrics
        meanTimeToAcknowledge: this.calculateMeanTimeToAcknowledge(alertHistory),
        meanTimeToResolve: this.calculateMeanTimeToResolve(alertHistory),
        averageResolutionTime: alertMetrics.averageResolutionTime || 0,
      };

      return {
        timestamp,
        source: 'alert-management',
        metrics,
        metadata: {
          collectionInterval: this.config.intervalMs,
          batchSize: this.config.batchSize,
        },
      };
    } catch (error) {
      logger.error({ error }, 'Failed to collect alert metrics');
      throw createQdrantError(
        'Failed to collect alert metrics',
        ErrorCodes.METRICS_ERROR,
        error as Error
      );
    }
  }

  private calculateResolutionRate(_alertHistory: unknown[]): number {
    if (alertHistory.length === 0) return 0;
    const resolved = alertHistory.filter((alert) => alert.status === 'resolved').length;
    return (resolved / alertHistory.length) * 100;
  }

  private calculateAcknowledgmentRate(_alertHistory: unknown[]): number {
    if (alertHistory.length === 0) return 0;
    const acknowledged = alertHistory.filter((alert) => alert.acknowledgedAt).length;
    return (acknowledged / alertHistory.length) * 100;
  }

  private calculateEscalationRate(_alertHistory: unknown[]): number {
    if (alertHistory.length === 0) return 0;
    const escalated = alertHistory.filter((alert) => alert.escalated).length;
    return (escalated / alertHistory.length) * 100;
  }

  private calculateMeanTimeToAcknowledge(_alertHistory: unknown[]): number {
    const acknowledgedAlerts = alertHistory.filter(
      (alert) => alert.acknowledgedAt && alert.timestamp
    );

    if (acknowledgedAlerts.length === 0) return 0;

    const totalTime = acknowledgedAlerts.reduce((sum,  _alert) => {
      const ackTime = new Date(alert.acknowledgedAt).getTime();
      const createdTime = new Date(alert.timestamp).getTime();
      return sum + (ackTime - createdTime);
    }, 0);

    return totalTime / acknowledgedAlerts.length;
  }

  private calculateMeanTimeToResolve(_alertHistory: unknown[]): number {
    const resolvedAlerts = alertHistory.filter((alert) => alert.resolvedAt && alert.timestamp);

    if (resolvedAlerts.length === 0) return 0;

    const totalTime = resolvedAlerts.reduce((sum,  _alert) => {
      const resolvedTime = new Date(alert.resolvedAt).getTime();
      const createdTime = new Date(alert.timestamp).getTime();
      return sum + (resolvedTime - createdTime);
    }, 0);

    return totalTime / resolvedAlerts.length;
  }
}

/**
 * System performance metrics collector
 */
export class SystemPerformanceCollector extends EventEmitter implements MetricsCollector {
  private isRunningFlag = false;
  private collectionInterval: NodeJS.Timeout | null = null;

  constructor(
    private config: {
      intervalMs: number;
      includeMemory: boolean;
      includeCPU: boolean;
      includeDisk: boolean;
      includeNetwork: boolean;
    }
  ) {
    super();
  }

  async start(): Promise<void> {
    try {
      if (this.isRunningFlag) {
        logger.warn('System performance collector already running');
        return;
      }

      logger.info('Starting system performance collector');
      this.isRunningFlag = true;

      this.collectionInterval = setInterval(async () => {
        if (this.isRunningFlag) {
          try {
            const metrics = await this.collect();
            this.emit('metrics_collected', metrics);
          } catch (error) {
            logger.error({ error }, 'Error collecting system performance metrics');
            this.emit('collection_error', error);
          }
        }
      }, this.config.intervalMs);

      logger.info('System performance collector started');
    } catch (error) {
      logger.error({ error }, 'Failed to start system performance collector');
      throw createQdrantError(
        'Failed to start system performance collector',
        ErrorCodes.METRICS_ERROR,
        error as Error
      );
    }
  }

 stop(): Promise<void> {
    try {
      logger.info('Stopping system performance collector');
      this.isRunningFlag = false;

      if (this.collectionInterval) {
        clearInterval(this.collectionInterval);
        this.collectionInterval = null;
      }

      this.removeAllListeners();
      logger.info('System performance collector stopped');
    } catch (error) {
      logger.error({ error }, 'Failed to stop system performance collector');
    }
  }

  isRunning(): boolean {
    return this.isRunningFlag;
  }

  async collect(): Promise<CollectedMetrics> {
    try {
      const timestamp = new Date();
      const _metrics: Record<string, unknown> = {};

      if (this.config.includeMemory) {
        metrics.memory = await this.collectMemoryMetrics();
      }

      if (this.config.includeCPU) {
        metrics.cpu = await this.collectCPUMetrics();
      }

      if (this.config.includeDisk) {
        metrics.disk = await this.collectDiskMetrics();
      }

      if (this.config.includeNetwork) {
        metrics.network = await this.collectNetworkMetrics();
      }

      // Process-level metrics
      metrics.process = {
        uptime: process.uptime(),
        memoryUsage: process.memoryUsage(),
        cpuUsage: process.cpuUsage(),
        pid: process.pid,
      };

      return {
        timestamp,
        source: 'system-performance',
        metrics,
        metadata: {
          interval: this.config.intervalMs,
          nodeVersion: process.version,
          platform: process.platform,
        },
      };
    } catch (error) {
      logger.error({ error }, 'Failed to collect system performance metrics');
      throw createQdrantError(
        'Failed to collect system performance metrics',
        ErrorCodes.METRICS_ERROR,
        error as Error
      );
    }
  }

  private async collectMemoryMetrics(): Promise<unknown> {
    const memUsage = process.memoryUsage();

    return {
      rss: memUsage.rss,
      heapTotal: memUsage.heapTotal,
      heapUsed: memUsage.heapUsed,
      external: memUsage.external,
      arrayBuffers: memUsage.arrayBuffers,
      heapUsedPercent: (memUsage.heapUsed / memUsage.heapTotal) * 100,
      totalMemory: require('os').totalmem(),
      freeMemory: require('os').freemem(),
      usedMemoryPercent:
        ((require('os').totalmem() - require('os').freemem()) / require('os').totalmem()) * 100,
    };
  }

  private async collectCPUMetrics(): Promise<unknown> {
    const cpus = require('os').cpus();
    const loadAvg = require('os').loadavg();

    return {
      cpuCount: cpus.length,
      model: cpus[0]?.model,
      speed: cpus[0]?.speed,
      loadAverage: {
        oneMinute: loadAvg[0],
        fiveMinutes: loadAvg[1],
        fifteenMinutes: loadAvg[2],
      },
      usage: process.cpuUsage(),
    };
  }

  private async collectDiskMetrics(): Promise<unknown> {
    try {
      const fs = require('fs');
      const stats = fs.statSync('.');

      return {
        available: stats.size || 0,
        // Note: More detailed disk metrics would require additional dependencies
      };
    } catch (error) {
      return { error: 'Disk metrics not available' };
    }
  }

  private async collectNetworkMetrics(): Promise<unknown> {
    try {
      const networkInterfaces = require('os').networkInterfaces();

      return {
        interfaces: Object.keys(networkInterfaces).reduce<unknown>((acc, name) => {
          const iface = networkInterfaces[name];
          if (_iface) {
            acc[name] = iface.map(
              (info: {
                address: unknown;
                netmask: unknown;
                family: unknown;
                mac: unknown;
                internal: unknown;
              }) => ({
                address: info.address,
                netmask: info.netmask,
                family: info.family,
                mac: info.mac,
                internal: info.internal,
              })
            );
          }
          return acc;
        }, {}),
      };
    } catch (error) {
      return { error: 'Network metrics not available' };
    }
  }
}

/**
 * Notification metrics collector
 */
export class NotificationMetricsCollector extends EventEmitter implements MetricsCollector {
  private isRunningFlag = false;
  private collectionInterval: NodeJS.Timeout | null = null;

  constructor(
    private notificationChannels: unknown, 
    private config: {
      intervalMs: number;
      trackByChannel: boolean;
      trackSuccessRates: boolean;
    }
  ) {
    super();
  }

  async start(): Promise<void> {
    try {
      if (this.isRunningFlag) {
        logger.warn('Notification metrics collector already running');
        return;
      }

      logger.info('Starting notification metrics collector');
      this.isRunningFlag = true;

      this.collectionInterval = setInterval(async () => {
        if (this.isRunningFlag) {
          try {
            const metrics = await this.collect();
            this.emit('metrics_collected', metrics);
          } catch (error) {
            logger.error({ error }, 'Error collecting notification metrics');
            this.emit('collection_error', error);
          }
        }
      }, this.config.intervalMs);

      logger.info('Notification metrics collector started');
    } catch (error) {
      logger.error({ error }, 'Failed to start notification metrics collector');
      throw createQdrantError(
        'Failed to start notification metrics collector',
        ErrorCodes.METRICS_ERROR,
        error as Error
      );
    }
  }

 stop(): Promise<void> {
    try {
      logger.info('Stopping notification metrics collector');
      this.isRunningFlag = false;

      if (this.collectionInterval) {
        clearInterval(this.collectionInterval);
        this.collectionInterval = null;
      }

      this.removeAllListeners();
      logger.info('Notification metrics collector stopped');
    } catch (error) {
      logger.error({ error }, 'Failed to stop notification metrics collector');
    }
  }

  isRunning(): boolean {
    return this.isRunningFlag;
  }

  async collect(): Promise<CollectedMetrics> {
    try {
      const timestamp = new Date();
      const _metrics: Record<string, unknown> = {};

      // Collect metrics from notification channels
      const channels = this.notificationChannels.getAllChannels();
      const channelMetrics: Record<string, unknown> = {};

      for (const [name, channel] of Object.entries(channels)) {
        const channelStats = await this.collectChannelMetrics(channel);
        channelMetrics[name] = channelStats;
      }

      metrics.channels = channelMetrics;

      // Aggregate metrics
      const allMetrics = Object.values(channelMetrics);
      metrics.total = {
        sent: allMetrics.reduce((sum: number,  _m: unknown) => sum + (m.sent || 0), 0),
        failed: allMetrics.reduce((sum: number,  _m: unknown) => sum + (m.failed || 0), 0),
        pending: allMetrics.reduce((sum: number,  _m: unknown) => sum + (m.pending || 0), 0),
        successRate: this.calculateOverallSuccessRate(allMetrics),
        averageDeliveryTime: this.calculateAverageDeliveryTime(allMetrics),
      };

      return {
        timestamp,
        source: 'notification-channels',
        metrics,
        metadata: {
          interval: this.config.intervalMs,
          channelCount: Object.keys(channels).length,
        },
      };
    } catch (error) {
      logger.error({ error }, 'Failed to collect notification metrics');
      throw createQdrantError(
        'Failed to collect notification metrics',
        ErrorCodes.METRICS_ERROR,
        error as Error
      );
    }
  }

  private async collectChannelMetrics(channel: unknown): Promise<unknown> {
    try {
      // Get metrics from channel (this would depend on channel implementation)
      const channelConfig = channel.getConfig();
      const channelStats = channel.getStats?.() || {};

      return {
        sent: channelStats.sent || 0,
        failed: channelStats.failed || 0,
        pending: channelStats.pending || 0,
        successRate: channelStats.successRate || 0,
        averageDeliveryTime: channelStats.averageDeliveryTime || 0,
        lastActivity: channelStats.lastActivity,
        isHealthy: channelStats.isHealthy !== false,
        config: {
          type: channelConfig?.type,
          enabled: channelConfig?.enabled,
        },
      };
    } catch (error) {
      return {
        error: error instanceof Error ? error.message : 'Unknown error',
        isHealthy: false,
      };
    }
  }

  private calculateOverallSuccessRate(_channelMetrics: unknown[]): number {
    const totalSent = channelMetrics.reduce((sum,  _m) => sum + (m.sent || 0), 0);
    const totalFailed = channelMetrics.reduce((sum,  _m) => sum + (m.failed || 0), 0);
    const total = totalSent + totalFailed;

    return total > 0 ? (totalSent / total) * 100 : 100;
  }

  private calculateAverageDeliveryTime(_channelMetrics: unknown[]): number {
    const validMetrics = channelMetrics.filter((m) => m.averageDeliveryTime > 0);
    if (validMetrics.length === 0) return 0;

    const totalTime = validMetrics.reduce((sum,  _m) => sum + m.averageDeliveryTime, 0);
    return totalTime / validMetrics.length;
  }
}

/**
 * Health check metrics collector
 */
export class HealthCheckMetricsCollector extends EventEmitter implements MetricsCollector {
  private isRunningFlag = false;
  private collectionInterval: NodeJS.Timeout | null = null;

  constructor(
    private healthCheckService: unknown, 
    private config: {
      intervalMs: number;
      includeComponentDetails: boolean;
      trackTrends: boolean;
    }
  ) {
    super();
  }

  async start(): Promise<void> {
    try {
      if (this.isRunningFlag) {
        logger.warn('Health check metrics collector already running');
        return;
      }

      logger.info('Starting health check metrics collector');
      this.isRunningFlag = true;

      this.collectionInterval = setInterval(async () => {
        if (this.isRunningFlag) {
          try {
            const metrics = await this.collect();
            this.emit('metrics_collected', metrics);
          } catch (error) {
            logger.error({ error }, 'Error collecting health check metrics');
            this.emit('collection_error', error);
          }
        }
      }, this.config.intervalMs);

      logger.info('Health check metrics collector started');
    } catch (error) {
      logger.error({ error }, 'Failed to start health check metrics collector');
      throw createQdrantError(
        'Failed to start health check metrics collector',
        ErrorCodes.METRICS_ERROR,
        error as Error
      );
    }
  }

 stop(): Promise<void> {
    try {
      logger.info('Stopping health check metrics collector');
      this.isRunningFlag = false;

      if (this.collectionInterval) {
        clearInterval(this.collectionInterval);
        this.collectionInterval = null;
      }

      this.removeAllListeners();
      logger.info('Health check metrics collector stopped');
    } catch (error) {
      logger.error({ error }, 'Failed to stop health check metrics collector');
    }
  }

  isRunning(): boolean {
    return this.isRunningFlag;
  }

  async collect(): Promise<CollectedMetrics> {
    try {
      const timestamp = new Date();
      const healthResult = await this.healthCheckService.performHealthCheck();

      const _metrics: Record<string, unknown> = {
        overall: {
          status: healthResult.status,
          timestamp: healthResult.timestamp,
          duration: healthResult.duration,
          uptimeSeconds: healthResult.uptime_seconds,
          version: healthResult.version,
        },
        summary: {
          totalComponents: healthResult.summary?.total_components || 0,
          healthyComponents: healthResult.summary?.healthy_components || 0,
          degradedComponents: healthResult.summary?.degraded_components || 0,
          unhealthyComponents: healthResult.summary?.unhealthy_components || 0,
          healthScore: this.calculateHealthScore(healthResult),
        },
        systemMetrics: healthResult.system_metrics || {},
      };

      if (this.config.includeComponentDetails) {
        metrics.components =
          healthResult.components?.map((component: unknown) => ({
            name: component.name,
            type: component.type,
            status: component.status,
            lastCheck: component.last_check,
            responseTime: component.response_time_ms,
            errorRate: component.error_rate,
            uptime: component.uptime_percentage,
            details: component.details,
          })) || [];
      }

      if (this.config.trackTrends) {
        metrics.trends = {
          issues: healthResult.issues || [],
          recommendations: this.generateRecommendations(healthResult),
          changeTracking: this.trackChanges(healthResult),
        };
      }

      return {
        timestamp,
        source: 'health-checks',
        metrics,
        metadata: {
          interval: this.config.intervalMs,
          includeComponentDetails: this.config.includeComponentDetails,
          trackTrends: this.config.trackTrends,
        },
      };
    } catch (error) {
      logger.error({ error }, 'Failed to collect health check metrics');
      throw createQdrantError(
        'Failed to collect health check metrics',
        ErrorCodes.METRICS_ERROR,
        error as Error
      );
    }
  }

  private calculateHealthScore(_healthResult: unknown): number {
    const summary = healthResult.summary;
    if (!summary || summary.total_components === 0) return 0;

    const healthyWeight = 1.0;
    const degradedWeight = 0.5;
    const unhealthyWeight = 0.0;

    const score =
      (summary.healthy_components * healthyWeight +
        summary.degraded_components * degradedWeight +
        summary.unhealthy_components * unhealthyWeight) /
      summary.total_components;

    return Math.round(score * 100);
  }

  private generateRecommendations(_healthResult: unknown): string[] {
    const recommendations: string[] = [];
    const components = healthResult.components || [];

    components.forEach((component: unknown) => {
      if (component.status === 'unhealthy') {
        recommendations.push(`Investigate ${component.name} - component is unhealthy`);
      } else if (component.error_rate > 10) {
        recommendations.push(
          `${component.name} has high error rate (${String(component.error_rate.toFixed(1))}%)`
        );
      } else if (component.response_time_ms > 5000) {
        recommendations.push(
          `${component.name} has high response time (${component.response_time_ms}ms)`
        );
      } else if (component.uptime_percentage < 95) {
        recommendations.push(
          `${component.name} has low availability (${String(component.uptime_percentage.toFixed(1))}%)`
        );
      }
    });

    return recommendations;
  }

  private trackChanges(_healthResult: unknown): unknown {
    // Placeholder for change tracking
    // In a real implementation, this would track changes over time
    return {
      lastStatusChange: new Date(),
      statusChanges: 0,
      componentChanges: {},
    };
  }
}

// Export all collectors
export {
  AlertMetricsCollector as AlertCollector,
  SystemPerformanceCollector as SystemCollector,
  NotificationMetricsCollector as NotificationCollector,
  HealthCheckMetricsCollector as HealthCollector,
};

export type { MetricsCollector, CollectedMetrics };
