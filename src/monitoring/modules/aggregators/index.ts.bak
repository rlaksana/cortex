/**
 * Alert Metrics Aggregators Module
 *
 * Responsible for aggregating collected metrics:
 * - Time-based aggregations (sliding windows, fixed windows)
 * - Statistical aggregations (averages, percentiles)
 * - Group-based aggregations (by component, severity, etc.)
 * - Trend analysis and anomaly detection
 *
 * @author Cortex Team
 * @version 2.0.0
 * @since 2025
 */

import { EventEmitter } from 'events';
import { createQdrantError, ErrorCodes } from '../../../db/adapters/modules/error-contract.js';
import { aggregationConfigSchema } from '../validation-schemas.js';
import { logger } from '@/utils/logger.js';

/**
 * Base aggregator interface
 */
export interface MetricsAggregator {
  aggregate(_metrics: unknown[], config: unknown): Promise<AggregatedMetrics>;
  start(): Promise<void>;
  stop(): Promise<void>;
  isRunning(): boolean;
}

/**
 * Aggregated metrics interface
 */
export interface AggregatedMetrics {
  timestamp: Date;
  source: string;
  aggregation: {
    type: 'avg' | 'sum' | 'min' | 'max' | 'count' | 'rate';
    timeWindow: string;
    groupBy?: string[];
  };
  _metrics: Record<string, number>;
  metadata?: Record<string, unknown>;
}

/**
 * Time window aggregation strategies
 */
export enum TimeWindowStrategy {
  FIXED = 'fixed',
  SLIDING = 'sliding',
  TUMBLING = 'tumbling',
}

/**
 * Time-based metrics aggregator
 */
export class TimeBasedAggregator extends EventEmitter implements MetricsAggregator {
  private isRunningFlag = false;
  private aggregationInterval: NodeJS.Timeout | null = null;
  private metricsBuffer: Map<string, unknown[]> = new Map();

  constructor(
    private config: {
      intervalMs: number;
      maxBufferSize: number;
      retentionMs: number;
      windowStrategy: TimeWindowStrategy;
    }
  ) {
    super();
  }

  async start(): Promise<void> {
    try {
      if (this.isRunningFlag) {
        logger.warn('Time-based aggregator already running');
        return;
      }

      logger.info('Starting time-based metrics aggregator');
      this.isRunningFlag = true;

      // Process aggregations on interval
      this.aggregationInterval = setInterval(async () => {
        if (this.isRunningFlag) {
          try {
            await this.processAggregations();
          } catch (error) {
            logger.error({ error }, 'Error processing time-based aggregations');
            this.emit('aggregation_error', error);
          }
        }
      }, this.config.intervalMs);

      logger.info('Time-based metrics aggregator started');
    } catch (error) {
      logger.error({ error }, 'Failed to start time-based aggregator');
      throw createQdrantError(
        'Failed to start time-based aggregator',
        ErrorCodes.METRICS_ERROR,
        error as Error
      );
    }
  }

 stop(): Promise<void> {
    try {
      logger.info('Stopping time-based metrics aggregator');
      this.isRunningFlag = false;

      if (this.aggregationInterval) {
        clearInterval(this.aggregationInterval);
        this.aggregationInterval = null;
      }

      this.metricsBuffer.clear();
      this.removeAllListeners();
      logger.info('Time-based metrics aggregator stopped');
    } catch (error) {
      logger.error({ error }, 'Failed to stop time-based aggregator');
    }
  }

  isRunning(): boolean {
    return this.isRunningFlag;
  }

 aggregate(_metrics: unknown[], config: unknown): Promise<AggregatedMetrics> {
    try {
      aggregationConfigSchema.parse(config);

      const timestamp = new Date();
      const aggregation = {
        type: config.aggregationType as 'avg' | 'sum' | 'min' | 'max' | 'count' | 'rate',
        timeWindow: `${config.timeWindow.size} ${config.timeWindow.unit}`,
        groupBy: config.groupBy,
      };

      const aggregatedMetrics = this.performAggregation(metrics, config);

      const result: AggregatedMetrics = {
        timestamp,
        source: 'time-based-aggregator',
        aggregation,
        _metrics: aggregatedMetrics,
        metadata: {
          inputMetricsCount: metrics.length,
          timeWindowStrategy: this.config.windowStrategy,
        },
      };

      return result;
    } catch (error) {
      logger.error({ error, config }, 'Failed to aggregate metrics');
      throw createQdrantError(
        'Failed to aggregate metrics',
        ErrorCodes.METRICS_ERROR,
        error as Error
      );
    }
  }

  addMetrics(_metrics: unknown[]): void {
    try {
      for (const metric of metrics) {
        const source = metric.source || 'unknown';

        if (!this.metricsBuffer.has(source)) {
          this.metricsBuffer.set(source, []);
        }

        const buffer = this.metricsBuffer.get(source)!;
        buffer.push(metric);

        // Maintain buffer size limit
        if (buffer.length > this.config.maxBufferSize) {
          buffer.shift();
        }
      }
    } catch (error) {
      logger.error({ error }, 'Failed to add metrics to buffer');
    }
  }

  private async processAggregations(): Promise<void> {
    try {
      const now = new Date();
      const windowStart = new Date(now.getTime() - this.config.retentionMs);

      for (const [source,  metrics] of this.metricsBuffer) {
        // Filter metrics within time window
        const recentMetrics = metrics.filter((m) => new Date(m.timestamp) >= windowStart);

        if (recentMetrics.length === 0) continue;

        // Perform default aggregations
        const defaultConfig = {
          aggregationType: 'avg' as const,
          timeWindow: { size: this.config.retentionMs / 1000, unit: 'seconds' as const },
        };

        const aggregated = await this.aggregate(recentMetrics, defaultConfig);
        this.emit('aggregation_completed', aggregated);
      }
    } catch (error) {
      logger.error({ error }, 'Error processing aggregations');
    }
  }

  private performAggregation(_metrics: unknown[], config: unknown): Record<string, number> {
    const result: Record<string, number> = {};

    // Group metrics if groupBy is specified
    let groups = metrics;
    if (config.groupBy && config.groupBy.length > 0) {
      groups = this.groupMetrics(metrics, config.groupBy);
    } else {
      groups = [metrics];
    }

    for (const group of groups) {
      const groupId = this.getGroupId(group, config.groupBy);
      const groupMetrics = Array.isArray(group) ? group : [group];

      const aggregated = this.calculateAggregation(groupMetrics, config.aggregationType);

      // Merge group metrics into result
      for (const [key, value] of Object.entries(aggregated)) {
        const fullKey = groupId ? `${groupId}.${key}` : key;
        result[fullKey] = value;
      }
    }

    return result;
  }

  private groupMetrics(_metrics: unknown[],  _groupBy: string[]): unknown[] {
    const groups: Record<string, unknown[]> = {};

    for (const metric of metrics) {
      const key = groupBy.map((field) => this.getNestedValue(metric, field) || 'unknown').join('.');

      if (!groups[key]) {
        groups[key] = [];
      }
      groups[key].push(metric);
    }

    return Object.values(groups);
  }

  private getGroupId(_group: unknown[],  groupBy?: string[]): string {
    if (!groupBy || groupBy.length === 0 || group.length === 0) {
      return '';
    }

    const firstItem = Array.isArray(group) ? group[0] : group;
    return groupBy.map((field) => this.getNestedValue(firstItem, field) || 'unknown').join('.');
  }

  private getNestedValue(_obj: unknown,  _path: string): unknown {
    return path.split('.').reduce((current,  _key) => current?.[key], obj);
  }

  private calculateAggregation(_metrics: unknown[], type: string): Record<string, number> {
    const numericMetrics = this.extractNumericMetrics(metrics);

    switch (_type) {
      case 'avg':
        return this.calculateAverage(numericMetrics);
      case 'sum':
        return this.calculateSum(numericMetrics);
      case 'min':
        return this.calculateMin(numericMetrics);
      case 'max':
        return this.calculateMax(numericMetrics);
      case 'count':
        return this.calculateCount(metrics);
      case 'rate':
        return this.calculateRate(numericMetrics);
      default:
        throw new Error(`Unknown aggregation type: ${type}`);
    }
  }

  private extractNumericMetrics(_metrics: unknown[]): Record<string, number[]> {
    const numeric: Record<string, number[]> = {};

    for (const metric of metrics) {
      for (const [key, value] of Object.entries(metric.metrics || {})) {
        if (typeof value === 'number' && isFinite(value)) {
          if (!numeric[key]) {
            numeric[key] = [];
          }
          numeric[key].push(value);
        }
      }
    }

    return numeric;
  }

  private calculateAverage(numericMetrics: Record<string, number[]>): Record<string, number> {
    const result: Record<string, number> = {};

    for (const [key, values] of Object.entries(numericMetrics)) {
      if (values.length > 0) {
        result[key] = values.reduce((sum,  _val) => sum + val, 0) / values.length;
      }
    }

    return result;
  }

  private calculateSum(numericMetrics: Record<string, number[]>): Record<string, number> {
    const result: Record<string, number> = {};

    for (const [key, values] of Object.entries(numericMetrics)) {
      if (values.length > 0) {
        result[key] = values.reduce((sum,  _val) => sum + val, 0);
      }
    }

    return result;
  }

  private calculateMin(numericMetrics: Record<string, number[]>): Record<string, number> {
    const result: Record<string, number> = {};

    for (const [key, values] of Object.entries(numericMetrics)) {
      if (values.length > 0) {
        result[key] = Math.min(...values);
      }
    }

    return result;
  }

  private calculateMax(numericMetrics: Record<string, number[]>): Record<string, number> {
    const result: Record<string, number> = {};

    for (const [key, values] of Object.entries(numericMetrics)) {
      if (values.length > 0) {
        result[key] = Math.max(...values);
      }
    }

    return result;
  }

  private calculateCount(_metrics: unknown[]): Record<string, number> {
    return {
      count: metrics.length,
    };
  }

  private calculateRate(numericMetrics: Record<string, number[]>): Record<string, number> {
    const result: Record<string, number> = {};

    for (const [key, values] of Object.entries(numericMetrics)) {
      if (values.length >= 2) {
        // Simple rate calculation: (last - first) / time span
        const firstValue = values[0];
        const lastValue = values[values.length - 1];
        const rate = lastValue - firstValue;
        result[key] = rate;
      }
    }

    return result;
  }
}

/**
 * Statistical aggregator
 */
export class StatisticalAggregator extends EventEmitter implements MetricsAggregator {
  private isRunningFlag = false;
  private aggregationInterval: NodeJS.Timeout | null = null;
  private samplesBuffer: Map<string, number[]> = new Map();

  constructor(
    private config: {
      intervalMs: number;
      percentiles: number[];
      sampleSize: number;
    }
  ) {
    super();
  }

  async start(): Promise<void> {
    try {
      if (this.isRunningFlag) {
        logger.warn('Statistical aggregator already running');
        return;
      }

      logger.info('Starting statistical metrics aggregator');
      this.isRunningFlag = true;

      this.aggregationInterval = setInterval(async () => {
        if (this.isRunningFlag) {
          try {
            await this.processStatisticalAggregations();
          } catch (error) {
            logger.error({ error }, 'Error processing statistical aggregations');
            this.emit('aggregation_error', error);
          }
        }
      }, this.config.intervalMs);

      logger.info('Statistical metrics aggregator started');
    } catch (error) {
      logger.error({ error }, 'Failed to start statistical aggregator');
      throw createQdrantError(
        'Failed to start statistical aggregator',
        ErrorCodes.METRICS_ERROR,
        error as Error
      );
    }
  }

 stop(): Promise<void> {
    try {
      logger.info('Stopping statistical metrics aggregator');
      this.isRunningFlag = false;

      if (this.aggregationInterval) {
        clearInterval(this.aggregationInterval);
        this.aggregationInterval = null;
      }

      this.samplesBuffer.clear();
      this.removeAllListeners();
      logger.info('Statistical metrics aggregator stopped');
    } catch (error) {
      logger.error({ error }, 'Failed to stop statistical aggregator');
    }
  }

  isRunning(): boolean {
    return this.isRunningFlag;
  }

 aggregate(_metrics: unknown[], config: unknown): Promise<AggregatedMetrics> {
    try {
      aggregationConfigSchema.parse(config);

      const timestamp = new Date();
      const numericMetrics = this.extractNumericValues(metrics);

      const statisticalMetrics = this.calculateStatistics(numericMetrics);

      const result: AggregatedMetrics = {
        timestamp,
        source: 'statistical-aggregator',
        aggregation: {
          type: 'avg' as const, // Statistical aggregator uses multiple types
          timeWindow: `${config.timeWindow.size} ${config.timeWindow.unit}`,
        },
        _metrics: statisticalMetrics,
        metadata: {
          inputMetricsCount: metrics.length,
          percentiles: this.config.percentiles,
          sampleSize: this.config.sampleSize,
        },
      };

      return result;
    } catch (error) {
      logger.error({ error, config }, 'Failed to perform statistical aggregation');
      throw createQdrantError(
        'Failed to perform statistical aggregation',
        ErrorCodes.METRICS_ERROR,
        error as Error
      );
    }
  }

  addSample(_metricName: string,  _value: number): void {
    try {
      if (!this.samplesBuffer.has(metricName)) {
        this.samplesBuffer.set(metricName, []);
      }

      const samples = this.samplesBuffer.get(metricName)!;
      samples.push(value);

      // Maintain sample size limit
      if (samples.length > this.config.sampleSize) {
        samples.shift();
      }
    } catch (error) {
      logger.error({ error, metricName, value }, 'Failed to add sample');
    }
  }

  private async processStatisticalAggregations(): Promise<void> {
    try {
      for (const [metricName,  samples] of this.samplesBuffer) {
        if (samples.length === 0) continue;

        const stats = this.calculateStatistics({ [metricName]: samples });

        const result: AggregatedMetrics = {
          timestamp: new Date(),
          source: 'statistical-aggregator',
          aggregation: {
            type: 'avg' as const,
            timeWindow: `${this.config.intervalMs}ms`,
          },
          _metrics: stats,
          metadata: {
            metricName,
            sampleSize: samples.length,
            percentiles: this.config.percentiles,
          },
        };

        this.emit('aggregation_completed', result);
      }
    } catch (error) {
      logger.error({ error }, 'Error processing statistical aggregations');
    }
  }

  private extractNumericValues(_metrics: unknown[]): Record<string, number[]> {
    const numeric: Record<string, number[]> = {};

    for (const metric of metrics) {
      for (const [key, value] of Object.entries(metric.metrics || {})) {
        if (typeof value === 'number' && isFinite(value)) {
          if (!numeric[key]) {
            numeric[key] = [];
          }
          numeric[key].push(value);
        }
      }
    }

    return numeric;
  }

  private calculateStatistics(numericMetrics: Record<string, number[]>): Record<string, number> {
    const result: Record<string, number> = {};

    for (const [metricName, values] of Object.entries(numericMetrics)) {
      if (values.length === 0) continue;

      // Basic statistics
      const sorted = [...values].sort((a,  _b) => a - b);
      const sum = values.reduce((s,  _v) => s + v, 0);
      const mean = sum / values.length;

      // Add basic stats
      result[`${metricName}.count`] = values.length;
      result[`${metricName}.sum`] = sum;
      result[`${metricName}.mean`] = mean;
      result[`${metricName}.min`] = sorted[0];
      result[`${metricName}.max`] = sorted[sorted.length - 1];

      // Calculate standard deviation
      const variance =
        values.reduce((sum,  _val) => sum + Math.pow(val - mean, 2), 0) / values.length;
      result[`${metricName}.stddev`] = Math.sqrt(variance);

      // Calculate percentiles
      for (const percentile of this.config.percentiles) {
        const index = Math.floor((percentile / 100) * (sorted.length - 1));
        result[`${metricName}.p${percentile}`] = sorted[index];
      }

      // Calculate median (50th percentile)
      const medianIndex = Math.floor(0.5 * (sorted.length - 1));
      result[`${metricName}.median`] = sorted[medianIndex];
    }

    return result;
  }
}

/**
 * Group-based aggregator
 */
export class GroupBasedAggregator extends EventEmitter implements MetricsAggregator {
  private isRunningFlag = false;
  private aggregationInterval: NodeJS.Timeout | null = null;
  private groupedMetrics: Map<string, unknown[]> = new Map();

  constructor(
    private config: {
      intervalMs: number;
      groupByFields: string[];
      maxGroups: number;
      aggregationTypes: string[];
    }
  ) {
    super();
  }

  async start(): Promise<void> {
    try {
      if (this.isRunningFlag) {
        logger.warn('Group-based aggregator already running');
        return;
      }

      logger.info('Starting group-based metrics aggregator');
      this.isRunningFlag = true;

      this.aggregationInterval = setInterval(async () => {
        if (this.isRunningFlag) {
          try {
            await this.processGroupAggregations();
          } catch (error) {
            logger.error({ error }, 'Error processing group aggregations');
            this.emit('aggregation_error', error);
          }
        }
      }, this.config.intervalMs);

      logger.info('Group-based metrics aggregator started');
    } catch (error) {
      logger.error({ error }, 'Failed to start group-based aggregator');
      throw createQdrantError(
        'Failed to start group-based aggregator',
        ErrorCodes.METRICS_ERROR,
        error as Error
      );
    }
  }

 stop(): Promise<void> {
    try {
      logger.info('Stopping group-based metrics aggregator');
      this.isRunningFlag = false;

      if (this.aggregationInterval) {
        clearInterval(this.aggregationInterval);
        this.aggregationInterval = null;
      }

      this.groupedMetrics.clear();
      this.removeAllListeners();
      logger.info('Group-based metrics aggregator stopped');
    } catch (error) {
      logger.error({ error }, 'Failed to stop group-based aggregator');
    }
  }

  isRunning(): boolean {
    return this.isRunningFlag;
  }

 aggregate(_metrics: unknown[], config: unknown): Promise<AggregatedMetrics> {
    try {
      aggregationConfigSchema.parse(config);

      const timestamp = new Date();
      const groups = this.groupMetricsByFields(metrics, this.config.groupByFields);
      const aggregatedResults: Record<string, unknown> = {};

      for (const [groupId,  groupMetrics] of groups) {
        const groupAggregations = this.calculateGroupAggregations(groupMetrics);
        aggregatedResults[groupId] = groupAggregations;
      }

      const result: AggregatedMetrics = {
        timestamp,
        source: 'group-based-aggregator',
        aggregation: {
          type: 'avg' as const,
          timeWindow: `${config.timeWindow.size} ${config.timeWindow.unit}`,
          groupBy: this.config.groupByFields,
        },
        _metrics: this.flattenGroupMetrics(aggregatedResults),
        metadata: {
          inputMetricsCount: metrics.length,
          groupCount: groups.size,
          groupByFields: this.config.groupByFields,
          aggregationTypes: this.config.aggregationTypes,
        },
      };

      return result;
    } catch (error) {
      logger.error({ error, config }, 'Failed to perform group-based aggregation');
      throw createQdrantError(
        'Failed to perform group-based aggregation',
        ErrorCodes.METRICS_ERROR,
        error as Error
      );
    }
  }

  addMetrics(_metrics: unknown[]): void {
    try {
      for (const metric of metrics) {
        const groupId = this.generateGroupId(metric);

        if (!this.groupedMetrics.has(groupId)) {
          this.groupedMetrics.set(groupId, []);
        }

        const group = this.groupedMetrics.get(groupId)!;
        group.push(metric);

        // Limit group size to prevent memory issues
        if (group.length > 1000) {
          group.shift();
        }
      }

      // Limit total number of groups
      if (this.groupedMetrics.size > this.config.maxGroups) {
        const oldestGroup = this.groupedMetrics.keys().next().value;
        this.groupedMetrics.delete(oldestGroup);
      }
    } catch (error) {
      logger.error({ error }, 'Failed to add metrics to groups');
    }
  }

  private async processGroupAggregations(): Promise<void> {
    try {
      for (const [groupId,  groupMetrics] of this.groupedMetrics) {
        if (groupMetrics.length === 0) continue;

        const groupAggregations = this.calculateGroupAggregations(groupMetrics);

        const result: AggregatedMetrics = {
          timestamp: new Date(),
          source: 'group-based-aggregator',
          aggregation: {
            type: 'avg' as const,
            timeWindow: `${this.config.intervalMs}ms`,
            groupBy: this.config.groupByFields,
          },
          _metrics: this.flattenGroupMetrics({ [groupId]: groupAggregations }),
          metadata: {
            groupId,
            groupSize: groupMetrics.length,
            aggregationTypes: this.config.aggregationTypes,
          },
        };

        this.emit('aggregation_completed', result);
      }
    } catch (error) {
      logger.error({ error }, 'Error processing group aggregations');
    }
  }

  private groupMetricsByFields(_metrics: unknown[], fields: string[]): Map<string, unknown[]> {
    const groups = new Map<string, unknown[]>();

    for (const metric of metrics) {
      const groupId = this.generateGroupId(metric);

      if (!groups.has(groupId)) {
        groups.set(groupId, []);
      }
      groups.get(groupId)!.push(metric);
    }

    return groups;
  }

  private generateGroupId(_metric: unknown): string {
    return this.config.groupByFields
      .map((field) => this.getNestedValue(metric, field) || 'unknown')
      .join('.');
  }

  private getNestedValue(_obj: unknown,  _path: string): unknown {
    return path.split('.').reduce((current,  _key) => current?.[key], obj);
  }

  private calculateGroupAggregations(groupMetrics: unknown[]): Record<string, number> {
    const numericMetrics = this.extractNumericMetrics(groupMetrics);
    const result: Record<string, number> = {};

    for (const [metricName, values] of Object.entries(numericMetrics)) {
      if (values.length === 0) continue;

      for (const aggregationType of this.config.aggregationTypes) {
        const value = this.calculateSingleAggregation(values, aggregationType);
        result[`${metricName}.${aggregationType}`] = value;
      }
    }

    return result;
  }

  private extractNumericMetrics(_metrics: unknown[]): Record<string, number[]> {
    const numeric: Record<string, number[]> = {};

    for (const metric of metrics) {
      for (const [key, value] of Object.entries(metric.metrics || {})) {
        if (typeof value === 'number' && isFinite(value)) {
          if (!numeric[key]) {
            numeric[key] = [];
          }
          numeric[key].push(value);
        }
      }
    }

    return numeric;
  }

  private calculateSingleAggregation(_values: number[],  type: string): number {
    switch (_type) {
      case 'avg':
        return values.reduce((sum,  _val) => sum + val, 0) / values.length;
      case 'sum':
        return values.reduce((sum,  _val) => sum + val, 0);
      case 'min':
        return Math.min(...values);
      case 'max':
        return Math.max(...values);
      case 'count':
        return values.length;
      case 'median': {
        const sorted = [...values].sort((a,  _b) => a - b);
        const index = Math.floor(0.5 * (sorted.length - 1));
        return sorted[index];
      }
      default:
        throw new Error(`Unknown aggregation type: ${type}`);
    }
  }

  private flattenGroupMetrics(groupedMetrics: Record<string, unknown>): Record<string, number> {
    const result: Record<string, number> = {};

    for (const [groupId, metrics] of Object.entries(groupedMetrics)) {
      for (const [metricName, value] of Object.entries(metrics)) {
        result[`${groupId}.${metricName}`] = value as number;
      }
    }

    return result;
  }
}

// Export all aggregators
export {
  TimeBasedAggregator as TimeAggregator,
  StatisticalAggregator as StatsAggregator,
  GroupBasedAggregator as GroupAggregator,
};

export type { MetricsAggregator, AggregatedMetrics, TimeWindowStrategy };
