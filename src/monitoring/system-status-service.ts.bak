/**
 * Enhanced System Status Service
 *
 * Provides comprehensive system-level health monitoring with per-component
 * health, version tracking, and degraded mode detection.
 *
 * Features:
 * - Component-level health with dependency mapping
 * - Version tracking and compatibility checking
 * - Degraded mode detection and flagging
 * - Real-time status aggregation
 * - SLO/SLA monitoring
 * - Alert integration
 *
 * @author Cortex Team
 * @version 1.0.0
 * @since 2025-11-10
 */

import { EventEmitter } from 'events';
import type {
  ComponentHealth,
  SystemHealthResult,
  SLACompliance,
} from '../types/unified-health-interfaces.js';
import {
  HealthStatus,
  DependencyType,
  AlertSeverity,
  HealthTrend,
} from '../types/unified-health-interfaces.js';
import { logger } from '@/utils/logger.js';

/**
 * Component version information
 */
export interface ComponentVersion {
  component: string;
  version: string;
  buildNumber?: string;
  commitHash?: string;
  buildDate?: Date;
  compatibilityMatrix: {
    minCompatibleVersion?: string;
    maxCompatibleVersion?: string;
    requiredApiVersions?: string[];
  };
}

/**
 * Component dependency mapping
 */
export interface ComponentDependency {
  component: string;
  dependsOn: string[];
  required: boolean;
  healthyRequired: boolean;
  impact: 'low' | 'medium' | 'high' | 'critical';
}

/**
 * Degraded mode configuration
 */
export interface DegradedModeConfig {
  enabled: boolean;
  triggerConditions: {
    maxUnhealthyCritical: number;
    maxUnhealthyHigh: number;
    maxDegradedComponents: number;
    responseTimeThreshold: number;
    errorRateThreshold: number;
  };
  fallbackBehavior: {
    disableNonCriticalFeatures: boolean;
    enableCaching: boolean;
    increaseTimeouts: boolean;
    reduceConcurrency: boolean;
  };
  recoveryConditions: {
    minHealthyComponents: number;
    maxResponseTime: number;
    maxErrorRate: number;
    stablePeriod: number; // milliseconds
  };
}

/**
 * Enhanced component health with version and dependency info
 */
export interface EnhancedComponentHealth extends ComponentHealth {
  version: ComponentVersion;
  dependencies: ComponentDependency[];
  degraded: boolean;
  degradedReason?: string;
  slaStatus?: SLACompliance;
  lastVersionCheck: Date;
  metrics: {
    requestsPerSecond: number;
    averageResponseTime: number;
    p95ResponseTime: number;
    p99ResponseTime: number;
    errorRate: number;
    throughput: number;
  };
}

/**
 * System status with enhanced monitoring
 */
export interface EnhancedSystemStatus extends SystemHealthResult {
  components: EnhancedComponentHealth[];
  degraded: boolean;
  degradedMode?: {
    active: boolean;
    reason: string;
    activatedAt: Date;
    configuration: DegradedModeConfig;
    affectedComponents: string[];
  };
  versions: {
    system: string;
    components: Record<string, ComponentVersion>;
    lastCheck: Date;
    compatibilityIssues: Array<{
      component: string;
      issue: string;
      severity: 'low' | 'medium' | 'high' | 'critical';
    }>;
  };
  dependencies: {
    graph: Record<string, ComponentDependency[]>;
    healthImpact: Record<
      string,
      {
        downstream: string[];
        impactLevel: 'low' | 'medium' | 'high' | 'critical';
        estimatedImpact: number; // 0-100
      }
    >;
  };
  alerts: Array<{
    id: string;
    component: string;
    severity: AlertSeverity;
    title: string;
    message: string;
    timestamp: Date;
    acknowledged: boolean;
    resolvedAt?: Date;
  }>;
  slo: {
    compliance: Record<
      string,
      {
        sloName: string;
        compliance: number;
        target: number;
        status: 'compliant' | 'warning' | 'violation';
      }
    >;
    overallCompliance: number;
  };
  trends: {
    overall: HealthTrend;
    components: Record<string, HealthTrend>;
  };
}

/**
 * System Status Service Configuration
 */
export interface SystemStatusConfig {
  // Health check intervals
  healthCheckInterval: number;
  versionCheckInterval: number;
  dependencyCheckInterval: number;
  sloEvaluationInterval: number;

  // Degraded mode settings
  degradedMode: DegradedModeConfig;

  // Alerting settings
  alerting: {
    enabled: boolean;
    cooldownPeriod: number;
    escalationPolicy: {
      warningDelay: number;
      criticalDelay: number;
      emergencyDelay: number;
    };
  };

  // SLO settings
  slo: {
    enabled: boolean;
    targets: {
      availability: number; // 99.9
      responseTime: number; // 200ms
      errorRate: number; // 0.1%
    };
    evaluationWindow: number; // 24 hours
  };

  // Version compatibility
  versionCompatibility: {
    strictMode: boolean;
    warnOnIncompatible: boolean;
    allowBetaVersions: boolean;
  };
}

/**
 * Enhanced System Status Service
 */
export class SystemStatusService extends EventEmitter {
  private config: SystemStatusConfig;
  private startTime: number;
  private currentStatus: EnhancedSystemStatus | null = null;
  private healthCheckTimer: NodeJS.Timeout | null = null;
  private versionCheckTimer: NodeJS.Timeout | null = null;
  private dependencyCheckTimer: NodeJS.Timeout | null = null;
  private sloEvaluationTimer: NodeJS.Timeout | null = null;
  private isShuttingDown = false;

  // Component health tracking
  private componentHealthCache = new Map<string, EnhancedComponentHealth>();
  private componentVersions = new Map<string, ComponentVersion>();
  private dependencyGraph = new Map<string, ComponentDependency[]>();
  private alertHistory = new Map<string, unknown>();
  private sloMetrics = new Map<string, unknown>();

  constructor(config?: Partial<SystemStatusConfig>) {
    super();

    this.config = {
      healthCheckInterval: 30000, // 30 seconds
      versionCheckInterval: 300000, // 5 minutes
      dependencyCheckInterval: 60000, // 1 minute
      sloEvaluationInterval: 60000, // 1 minute

      degradedMode: {
        enabled: true,
        triggerConditions: {
          maxUnhealthyCritical: 1,
          maxUnhealthyHigh: 2,
          maxDegradedComponents: 3,
          responseTimeThreshold: 1000,
          errorRateThreshold: 10,
        },
        fallbackBehavior: {
          disableNonCriticalFeatures: true,
          enableCaching: true,
          increaseTimeouts: true,
          reduceConcurrency: true,
        },
        recoveryConditions: {
          minHealthyComponents: 2,
          maxResponseTime: 500,
          maxErrorRate: 5,
          stablePeriod: 300000, // 5 minutes
        },
      },

      alerting: {
        enabled: true,
        cooldownPeriod: 300000, // 5 minutes
        escalationPolicy: {
          warningDelay: 60000, // 1 minute
          criticalDelay: 30000, // 30 seconds
          emergencyDelay: 10000, // 10 seconds
        },
      },

      slo: {
        enabled: true,
        targets: {
          availability: 99.9,
          responseTime: 200,
          errorRate: 0.1,
        },
        evaluationWindow: 86400000, // 24 hours
      },

      versionCompatibility: {
        strictMode: false,
        warnOnIncompatible: true,
        allowBetaVersions: false,
      },

      ...config,
    };

    this.startTime = Date.now();
    this.initializeComponentRegistry();
  }

  /**
   * Start system status monitoring
   */
  startMonitoring(): void {
    this.stopMonitoring(); // Ensure clean restart

    // Start health check timer
    this.healthCheckTimer = setInterval(() => {
      if (!this.isShuttingDown) {
        this.performHealthCheck();
      }
    }, this.config.healthCheckInterval);

    // Start version check timer
    this.versionCheckTimer = setInterval(() => {
      if (!this.isShuttingDown) {
        this.checkComponentVersions();
      }
    }, this.config.versionCheckInterval);

    // Start dependency check timer
    this.dependencyCheckTimer = setInterval(() => {
      if (!this.isShuttingDown) {
        this.checkComponentDependencies();
      }
    }, this.config.dependencyCheckInterval);

    // Start SLO evaluation timer
    this.sloEvaluationTimer = setInterval(() => {
      if (!this.isShuttingDown) {
        this.evaluateSLOCompliance();
      }
    }, this.config.sloEvaluationInterval);

    // Perform initial checks
    this.performHealthCheck();
    this.checkComponentVersions();
    this.checkComponentDependencies();
    this.evaluateSLOCompliance();

    logger.info(this.getMonitoringConfig(), 'System status monitoring started');
    this.emit('monitoring_started');
  }

  /**
   * Stop system status monitoring
   */
  stopMonitoring(): void {
    this.isShuttingDown = true;

    if (this.healthCheckTimer) {
      clearInterval(this.healthCheckTimer);
      this.healthCheckTimer = null;
    }

    if (this.versionCheckTimer) {
      clearInterval(this.versionCheckTimer);
      this.versionCheckTimer = null;
    }

    if (this.dependencyCheckTimer) {
      clearInterval(this.dependencyCheckTimer);
      this.dependencyCheckTimer = null;
    }

    if (this.sloEvaluationTimer) {
      clearInterval(this.sloEvaluationTimer);
      this.sloEvaluationTimer = null;
    }

    logger.info('System status monitoring stopped');
    this.emit('monitoring_stopped');
  }

  /**
   * Get current system status
   */
  getSystemStatus(): EnhancedSystemStatus | null {
    return this.currentStatus;
  }

  /**
   * Get component health details
   */
  getComponentHealth(_componentName: string): EnhancedComponentHealth | null {
    return this.componentHealthCache.get(componentName) || null;
  }

  /**
   * Get system degraded mode status
   */
  getDegradedModeStatus(): {
    active: boolean;
    reason?: string;
    activatedAt?: Date;
    configuration: DegradedModeConfig;
  } {
    return {
      active: this.currentStatus?.degradedMode?.active || false,
      reason: this.currentStatus?.degradedMode?.reason,
      activatedAt: this.currentStatus?.degradedMode?.activatedAt,
      configuration: this.config.degradedMode,
    };
  }

  /**
   * Get version compatibility status
   */
  getVersionCompatibility(): {
    overall: boolean;
    components: Record<string, boolean>;
    issues: Array<{
      component: string;
      issue: string;
      severity: string;
    }>;
  } {
    if (!this.currentStatus) {
      return {
        overall: false,
        components: {},
        issues: [],
      };
    }

    const components: Record<string, boolean> = {};
    this.currentStatus.versions.components.forEach((version: unknown,  _name: string | number) => {
      components[name] = true; // Assume compatible if loaded
    });

    return {
      overall: this.currentStatus.versions.compatibilityIssues.length === 0,
      components,
      issues: this.currentStatus.versions.compatibilityIssues,
    };
  }

  /**
   * Get SLO compliance status
   */
  getSLOCompliance(): {
    overall: number;
    targets: Record<string, number>;
    current: Record<string, number>;
    status: 'compliant' | 'warning' | 'violation';
  } {
    if (!this.currentStatus) {
      return {
        overall: 0,
        targets: {},
        current: {},
        status: 'violation',
      };
    }

    const targets: Record<string, number> = {
      availability: this.config.slo.targets.availability,
      responseTime: this.config.slo.targets.responseTime,
      errorRate: this.config.slo.targets.errorRate,
    };

    return {
      overall: this.currentStatus.slo.overallCompliance,
      targets,
      current: this.currentStatus.slo.compliance,
      status:
        this.currentStatus.slo.overallCompliance >= 99.9
          ? 'compliant'
          : this.currentStatus.slo.overallCompliance >= 99.0
            ? 'warning'
            : 'violation',
    };
  }

  /**
   * Manually trigger degraded mode
   */
  activateDegradedMode(_reason: string): void {
    if (this.currentStatus) {
      this.currentStatus.degradedMode = {
        active: true,
        reason,
        activatedAt: new Date(),
        configuration: this.config.degradedMode,
        affectedComponents: this.currentStatus.components
          .filter((c) => c.status !== HealthStatus.HEALTHY)
          .map((c) => c.name),
      };

      logger.warn({ reason }, 'Degraded mode manually activated');
      this.emit('degraded_mode_activated', { reason, timestamp: new Date() });
    }
  }

  /**
   * Manually deactivate degraded mode
   */
  deactivateDegradedMode(): void {
    if (this.currentStatus?.degradedMode?.active) {
      const previousReason = this.currentStatus.degradedMode.reason;
      this.currentStatus.degradedMode.active = false;

      logger.info({ previousReason }, 'Degraded mode manually deactivated');
      this.emit('degraded_mode_deactivated', {
        previousReason,
        timestamp: new Date(),
      });
    }
  }

  // Private methods

  private initializeComponentRegistry(): void {
    // Initialize known components with default versions
    const components = [
      {
        name: 'database',
        version: '1.0.0',
        type: DependencyType.DATABASE,
        dependencies: [],
      },
      {
        name: 'qdrant',
        version: '1.7.0',
        type: DependencyType.VECTOR_DB,
        dependencies: ['database'],
      },
      {
        name: 'embedding_service',
        version: '1.2.0',
        type: DependencyType.EMBEDDING_SERVICE,
        dependencies: [],
      },
      {
        name: 'metrics_service',
        version: '1.0.0',
        type: DependencyType.MONITORING,
        dependencies: ['database'],
      },
      {
        name: 'system',
        version: process.env.npm_package_version || '2.0.0',
        type: DependencyType.MONITORING,
        dependencies: ['metrics_service'],
      },
    ];

    components.forEach((comp) => {
      this.componentVersions.set(comp.name, {
        component: comp.name,
        version: comp.version,
        compatibilityMatrix: {
          requiredApiVersions: ['v1'],
        },
      });

      this.dependencyGraph.set(
        comp.name, 
        comp.dependencies.map((dep) => ({
          component: comp.name,
          dependsOn: [dep],
          required: true,
          healthyRequired: comp.name !== 'embedding_service', // Embedding service can operate independently
          impact:
            comp.name === 'database' ? 'critical' : comp.name === 'qdrant' ? 'high' : 'medium',
        }))
      );
    });
  }

  private async performHealthCheck(): Promise<void> {
    try {
      const components: EnhancedComponentHealth[] = [];
      const now = new Date();

      // Simulate health checks for known components
      for (const [componentName,  version] of this.componentVersions) {
        const health = await this.checkComponentHealth(componentName, version);
        components.push(health);
        this.componentHealthCache.set(componentName, health);
      }

      // Calculate overall status
      const overallStatus = this.calculateOverallStatus(components);
      const degraded = this.evaluateDegradedMode(components);

      // Create enhanced system status
      const systemStatus: EnhancedSystemStatus = {
        status: overallStatus,
        timestamp: now,
        duration: Date.now() - this.startTime,
        uptime_seconds: Math.floor((Date.now() - this.startTime) / 1000),
        version: process.env.npm_package_version || '2.0.0',
        components,
        degraded: degraded.active,
        degradedMode: degraded.active ? degraded : undefined,
        system_metrics: this.getSystemMetrics(),
        summary: {
          total_components: components.length,
          healthy_components: components.filter((c) => c.status === HealthStatus.HEALTHY).length,
          degraded_components: components.filter((c) => c.status === HealthStatus.DEGRADED).length,
          unhealthy_components: components.filter(
            (c) => c.status === HealthStatus.UNHEALTHY || c.status === HealthStatus.CRITICAL
          ).length,
        },
        versions: {
          system: process.env.npm_package_version || '2.0.0',
          components: Object.fromEntries(this.componentVersions),
          lastCheck: now,
          compatibilityIssues: [], // Would be populated by version checking
        },
        dependencies: {
          graph: Object.fromEntries(this.dependencyGraph),
          healthImpact: this.calculateDependencyImpact(components),
        },
        alerts: this.generateAlerts(components),
        slo: {
          compliance: this.calculateSLOCompliance(components),
          overallCompliance: this.calculateOverallSLOCompliance(components),
        },
        trends: {
          overall: HealthTrend.STABLE, // Would be calculated from historical data
          components: Object.fromEntries(components.map((c) => [c.name, HealthTrend.STABLE])),
        },
      };

      this.currentStatus = systemStatus;

      // Emit status change if needed
      this.emit('health_check', systemStatus);

      // Handle degraded mode transitions
      if (degraded.active && !this.currentStatus.degradedMode?.active) {
        this.emit('degraded_mode_activated', degraded);
      } else if (!degraded.active && this.currentStatus.degradedMode?.active) {
        this.emit('degraded_mode_deactivated', { timestamp: now });
      }
    } catch (error) {
      logger.error(
        { error: error instanceof Error ? error.message : 'Unknown error' },
        'Health check failed'
      );
      this.emit('health_check_error', { error, timestamp: new Date() });
    }
  }

  private async checkComponentHealth(
    componentName: string,
    version: ComponentVersion
  ): Promise<EnhancedComponentHealth> {
    const startTime = Date.now();

    // Simulate component health check with some randomness
    const isHealthy = Math.random() > 0.1; // 90% success rate
    const responseTime = Math.random() * 500 + 50; // 50-550ms
    const errorRate = isHealthy ? Math.random() * 2 : Math.random() * 20 + 10; // 0-2% or 10-30%

    const status = isHealthy
      ? errorRate > 1
        ? HealthStatus.DEGRADED
        : HealthStatus.HEALTHY
      : errorRate > 20
        ? HealthStatus.CRITICAL
        : HealthStatus.UNHEALTHY;

    const type = this.getComponentType(componentName);
    const dependencies = this.dependencyGraph.get(componentName) || [];

    return {
      name: componentName,
      type,
      status,
      last_check: new Date(),
      response_time_ms: responseTime,
      error_rate: errorRate,
      uptime_percentage: isHealthy ? 100 - errorRate : 0,
      version,
      dependencies,
      degraded: status === HealthStatus.DEGRADED,
      degradedReason: status === HealthStatus.DEGRADED ? 'High error rate' : undefined,
      lastVersionCheck: new Date(),
      metrics: {
        requestsPerSecond: Math.random() * 100,
        averageResponseTime: responseTime,
        p95ResponseTime: responseTime * 1.5,
        p99ResponseTime: responseTime * 2,
        errorRate,
        throughput: Math.random() * 1000,
      },
      details: {
        health_check_duration: Date.now() - startTime,
        last_successful_check: isHealthy ? new Date() : undefined,
        consecutive_failures: isHealthy ? 0 : Math.floor(Math.random() * 5) + 1,
      },
    };
  }

  private async checkComponentVersions(): Promise<void> {
    try {
      const now = new Date();
      const compatibilityIssues: Array<{
        component: string;
        issue: string;
        severity: 'low' | 'medium' | 'high' | 'critical';
      }> = [];

      for (const [componentName,  version] of this.componentVersions) {
        // Simulate version checking
        if (
          version.version.includes('beta') &&
          !this.config.versionCompatibility.allowBetaVersions
        ) {
          compatibilityIssues.push({
            component: componentName,
            issue: 'Beta version not allowed in production',
            severity: 'medium',
          });
        }
      }

      if (this.currentStatus) {
        this.currentStatus.versions.lastCheck = now;
        this.currentStatus.versions.compatibilityIssues = compatibilityIssues;
      }

      logger.debug(
        {
          componentsChecked: this.componentVersions.size,
          issuesFound: compatibilityIssues.length,
        },
        'Component version check completed'
      );
    } catch (error) {
      logger.error(
        { error: error instanceof Error ? error.message : 'Unknown error' },
        'Component version check failed'
      );
    }
  }

  private async checkComponentDependencies(): Promise<void> {
    try {
      const dependencyIssues: string[] = [];

      for (const [componentName,  dependencies] of this.dependencyGraph) {
        for (const dep of dependencies) {
          const depHealth = this.componentHealthCache.get(dep.dependsOn[0]);
          if (!depHealth) {
            dependencyIssues.push(
              `${componentName} depends on ${String(dep.dependsOn[0])} but dependency not found`
            );
          } else if (dep.required && depHealth.status === HealthStatus.UNHEALTHY) {
            dependencyIssues.push(
              `${componentName} requires ${String(dep.dependsOn[0])} but it's unhealthy`
            );
          }
        }
      }

      if (dependencyIssues.length > 0) {
        logger.warn({ issues: dependencyIssues }, 'Component dependency issues detected');
      }
    } catch (error) {
      logger.error(
        { error: error instanceof Error ? error.message : 'Unknown error' },
        'Component dependency check failed'
      );
    }
  }

  private async evaluateSLOCompliance(): Promise<void> {
    try {
      if (!this.currentStatus) return;

      const compliance = this.calculateSLOCompliance(this.currentStatus.components);
      const overallCompliance = this.calculateOverallSLOCompliance(this.currentStatus.components);

      this.currentStatus.slo.compliance = compliance;
      this.currentStatus.slo.overallCompliance = overallCompliance;

      // Check for SLO violations
      if (overallCompliance < this.config.slo.targets.availability) {
        this.emit('slo_violation', {
          slo: 'availability',
          current: overallCompliance,
          target: this.config.slo.targets.availability,
          timestamp: new Date(),
        });
      }
    } catch (error) {
      logger.error(
        { error: error instanceof Error ? error.message : 'Unknown error' },
        'SLO compliance evaluation failed'
      );
    }
  }

  private calculateOverallStatus(_components: EnhancedComponentHealth[]): HealthStatus {
    const criticalCount = components.filter((c) => c.status === HealthStatus.CRITICAL).length;
    const unhealthyCount = components.filter((c) => c.status === HealthStatus.UNHEALTHY).length;
    const degradedCount = components.filter((c) => c.status === HealthStatus.DEGRADED).length;

    if (criticalCount > 0) return HealthStatus.CRITICAL;
    if (unhealthyCount > 0) return HealthStatus.UNHEALTHY;
    if (degradedCount > 0) return HealthStatus.DEGRADED;
    return HealthStatus.HEALTHY;
  }

  private evaluateDegradedMode(_components: EnhancedComponentHealth[]): {
    active: boolean;
    reason: string;
    activatedAt: Date;
    configuration: DegradedModeConfig;
    affectedComponents: string[];
  } {
    const triggers = this.config.degradedMode.triggerConditions;
    const criticalUnhealthy = components.filter(
      (c) => c.status === HealthStatus.CRITICAL || c.status === HealthStatus.UNHEALTHY
    ).length;
    const degradedComponents = components.filter((c) => c.status === HealthStatus.DEGRADED).length;

    let shouldActivate = false;
    let reason = '';

    if (criticalUnhealthy >= triggers.maxUnhealthyCritical) {
      shouldActivate = true;
      reason = `Critical components unhealthy: ${criticalUnhealthy}/${triggers.maxUnhealthyCritical}`;
    } else if (criticalUnhealthy >= triggers.maxUnhealthyHigh) {
      shouldActivate = true;
      reason = `High priority components unhealthy: ${criticalUnhealthy}/${triggers.maxUnhealthyHigh}`;
    } else if (degradedComponents >= triggers.maxDegradedComponents) {
      shouldActivate = true;
      reason = `Too many degraded components: ${degradedComponents}/${triggers.maxDegradedComponents}`;
    }

    const highResponseTime = components.some(
      (c) => c.metrics.averageResponseTime > triggers.responseTimeThreshold
    );
    if (_highResponseTime) {
      shouldActivate = true;
      reason = 'High response times detected';
    }

    const highErrorRate = components.some((c) => c.metrics.errorRate > triggers.errorRateThreshold);
    if (_highErrorRate) {
      shouldActivate = true;
      reason = 'High error rates detected';
    }

    return {
      active: shouldActivate,
      reason,
      activatedAt: new Date(),
      configuration: this.config.degradedMode,
      affectedComponents: components
        .filter((c) => c.status !== HealthStatus.HEALTHY)
        .map((c) => c.name),
    };
  }

  private calculateDependencyImpact(_components: EnhancedComponentHealth[]): Record<
    string,
    {
      downstream: string[];
      impactLevel: 'low' | 'medium' | 'high' | 'critical';
      estimatedImpact: number;
    }
  > {
    const impact: Record<string, unknown> = {};

    for (const component of components) {
      const downstream = this.getDownstreamComponents(component.name);
      const unhealthyDownstream = downstream.filter((name) => {
        const depHealth = this.componentHealthCache.get(name);
        return depHealth && depHealth.status !== HealthStatus.HEALTHY;
      });

      let impactLevel: 'low' | 'medium' | 'high' | 'critical' = 'low';
      let estimatedImpact = 0;

      if (component.status === HealthStatus.CRITICAL) {
        impactLevel = 'critical';
        estimatedImpact = 100;
      } else if (component.status === HealthStatus.UNHEALTHY) {
        impactLevel = 'high';
        estimatedImpact = 75;
      } else if (component.status === HealthStatus.DEGRADED) {
        impactLevel = 'medium';
        estimatedImpact = 50;
      }

      // Increase impact based on downstream effects
      if (unhealthyDownstream.length > 0) {
        estimatedImpact += unhealthyDownstream.length * 10;
        if (estimatedImpact > 100) estimatedImpact = 100;
      }

      impact[component.name] = {
        downstream,
        impactLevel,
        estimatedImpact,
      };
    }

    return impact;
  }

  private getDownstreamComponents(_componentName: string): string[] {
    const downstream: string[] = [];
    for (const [name,  dependencies] of this.dependencyGraph) {
      if (dependencies.some((dep) => dep.dependsOn.includes(componentName))) {
        downstream.push(name);
        downstream.push(...this.getDownstreamComponents(name)); // Recursive
      }
    }
    return [...new Set(downstream)]; // Remove duplicates
  }

  private generateAlerts(_components: EnhancedComponentHealth[]): Array<{
    id: string;
    component: string;
    severity: AlertSeverity;
    title: string;
    message: string;
    timestamp: Date;
    acknowledged: boolean;
  }> {
    const alerts: unknown[] = [];

    for (const component of components) {
      if (component.status === HealthStatus.CRITICAL) {
        alerts.push({
          id: `${component.name}-critical-${Date.now()}`,
          component: component.name,
          severity: AlertSeverity.CRITICAL,
          title: `Critical: ${component.name} is down`,
          message: `Component ${component.name} is in critical state and may be offline`,
          timestamp: new Date(),
          acknowledged: false,
        });
      } else if (component.status === HealthStatus.UNHEALTHY) {
        alerts.push({
          id: `${component.name}-unhealthy-${Date.now()}`,
          component: component.name,
          severity: AlertSeverity.WARNING,
          title: `Unhealthy: ${component.name} is degraded`,
          message: `Component ${component.name} is unhealthy and experiencing issues`,
          timestamp: new Date(),
          acknowledged: false,
        });
      }

      if (component.metrics.errorRate > 10) {
        alerts.push({
          id: `${component.name}-error-rate-${Date.now()}`,
          component: component.name,
          severity: AlertSeverity.WARNING,
          title: `High Error Rate: ${component.name}`,
          message: `Error rate for ${component.name} is ${String(component.metrics.errorRate.toFixed(2))}%`,
          timestamp: new Date(),
          acknowledged: false,
        });
      }

      if (component.metrics.averageResponseTime > 500) {
        alerts.push({
          id: `${component.name}-response-time-${Date.now()}`,
          component: component.name,
          severity: AlertSeverity.WARNING,
          title: `High Response Time: ${component.name}`,
          message: `Average response time for ${component.name} is ${String(component.metrics.averageResponseTime.toFixed(0))}ms`,
          timestamp: new Date(),
          acknowledged: false,
        });
      }
    }

    return alerts;
  }

  private calculateSLOCompliance(_components: EnhancedComponentHealth[]): Record<
    string,
    {
      sloName: string;
      compliance: number;
      target: number;
      status: 'compliant' | 'warning' | 'violation';
    }
  > {
    const healthyCount = components.filter((c) => c.status === HealthStatus.HEALTHY).length;
    const totalCount = components.length;
    const availability = (healthyCount / totalCount) * 100;

    const avgResponseTime =
      components.reduce((sum,  _c) => sum + c.metrics.averageResponseTime, 0) / totalCount;
    const avgErrorRate = components.reduce((sum,  _c) => sum + c.metrics.errorRate, 0) / totalCount;

    return {
      availability: {
        sloName: 'Availability',
        compliance: availability,
        target: this.config.slo.targets.availability,
        status: availability >= this.config.slo.targets.availability ? 'compliant' : 'violation',
      },
      responseTime: {
        sloName: 'Response Time',
        compliance: Math.max(
          0,
          100 - (avgResponseTime / this.config.slo.targets.responseTime) * 100
        ),
        target: this.config.slo.targets.responseTime,
        status: avgResponseTime <= this.config.slo.targets.responseTime ? 'compliant' : 'violation',
      },
      errorRate: {
        sloName: 'Error Rate',
        compliance: Math.max(0, 100 - (avgErrorRate / this.config.slo.targets.errorRate) * 100),
        target: this.config.slo.targets.errorRate,
        status: avgErrorRate <= this.config.slo.targets.errorRate ? 'compliant' : 'violation',
      },
    };
  }

  private calculateOverallSLOCompliance(_components: EnhancedComponentHealth[]): number {
    const compliance = this.calculateSLOCompliance(components);
    const values = Object.values(compliance);
    return values.reduce((sum,  _c) => sum + c.compliance, 0) / values.length;
  }

  private getComponentType(_componentName: string): DependencyType {
    const typeMap: Record<string, DependencyType> = {
      database: DependencyType.DATABASE,
      qdrant: DependencyType.VECTOR_DB,
      embedding_service: DependencyType.EMBEDDING_SERVICE,
      metrics_service: DependencyType.MONITORING,
      system: DependencyType.MONITORING,
    };
    return typeMap[componentName] || DependencyType.EXTERNAL_SERVICE;
  }

  private getSystemMetrics() {
    const memUsage = process.memoryUsage();
    return {
      memory_usage_mb: memUsage.heapUsed / (1024 * 1024),
      cpu_usage_percent: 0, // Would require system monitoring
      active_connections: 0, // Would require connection tracking
      qps: 0, // Would require request tracking
    };
  }

  private getMonitoringConfig() {
    return {
      healthCheckInterval: this.config.healthCheckInterval,
      versionCheckInterval: this.config.versionCheckInterval,
      dependencyCheckInterval: this.config.dependencyCheckInterval,
      sloEvaluationInterval: this.config.sloEvaluationInterval,
      degradedModeEnabled: this.config.degradedMode.enabled,
      alertingEnabled: this.config.alerting.enabled,
      sloEnabled: this.config.slo.enabled,
    };
  }

  /**
   * Cleanup method
   */
  cleanup(): void {
    this.stopMonitoring();
    this.removeAllListeners();
    this.componentHealthCache.clear();
    this.componentVersions.clear();
    this.dependencyGraph.clear();
    this.alertHistory.clear();
    this.sloMetrics.clear();
    this.currentStatus = null;
  }
}

// Export singleton instance
export const systemStatusService = new SystemStatusService();
