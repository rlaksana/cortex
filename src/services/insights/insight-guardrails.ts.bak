/**
 * Insight Generation Guardrails
 *
 * Provides guardrails for insight generation including:
 * - Token caps and limits
 * - Deterministic templates
 * - Provenance tracking
 * - Reproducible outputs
 */

import * as crypto from 'crypto';
import type { InsightTypeUnion } from '../../types/insight-interfaces.js';
import { logger } from '@/utils/logger.js';

export interface InsightGuardrailConfig {
  // Token limits and caps
  maxTokensPerInsight: number;
  maxTokensPerBatch: number;
  tokenCountingMethod: 'approximate' | 'exact';

  // Deterministic output controls
  enableDeterministicTemplates: boolean;
  randomSeed?: string;
  templateVersion: string;

  // Provenance tracking
  enableProvenanceTracking: boolean;
  provenanceRetentionDays: number;

  // Reproducibility controls
  enableReproducibleOutputs: boolean;
  includeGenerationMetadata: boolean;
  cacheKeyDeterminism: boolean;
}

export interface InsightProvenance {
  insight_id: string;
  generation_timestamp: string;
  input_items_hash: string;
  template_used: string;
  configuration_snapshot: {
    insight_types: string[];
    confidence_threshold: number;
    max_insights_per_batch: number;
  };
  processing_context: {
    node_id?: string;
    session_id?: string;
    correlation_id: string;
  };
  performance_metrics: {
    generation_time_ms: number;
    tokens_estimated: number;
    memory_usage_mb?: number;
  };
}

export interface InsightTemplate {
  id: string;
  version: string;
  type: string;
  template: string;
  required_fields: string[];
  output_format: 'structured' | 'narrative' | 'bulleted';
}

export class InsightGenerationGuardrails {
  private config: InsightGuardrailConfig;
  private templates: Map<string, InsightTemplate> = new Map();
  private provenanceStore: Map<string, InsightProvenance> = new Map();

  constructor(config?: Partial<InsightGuardrailConfig>) {
    this.config = {
      maxTokensPerInsight: 500,
      maxTokensPerBatch: 2000,
      tokenCountingMethod: 'approximate',
      enableDeterministicTemplates: true,
      templateVersion: '1.0.0',
      enableProvenanceTracking: true,
      provenanceRetentionDays: 30,
      enableReproducibleOutputs: true,
      includeGenerationMetadata: true,
      cacheKeyDeterminism: true,
      ...config,
    };

    this.initializeTemplates();
  }

  /**
   * Validate and enforce token limits for insights
   */
  validateTokenLimits(_insights: InsightTypeUnion[]): {
    valid: boolean;
    violations: Array<{ insight_index: number; estimated_tokens: number; limit: number }>;
    adjusted_insights: InsightTypeUnion[];
  } {
    const violations: Array<{ insight_index: number; estimated_tokens: number; limit: number }> =
      [];
    const adjusted_insights: InsightTypeUnion[] = [];
    let totalTokens = 0;

    for (let i = 0; i < insights.length; i++) {
      const insight = insights[i];
      const estimatedTokens = this.estimateTokens(insight);

      // Check individual insight limit
      if (estimatedTokens > this.config.maxTokensPerInsight) {
        violations.push({
          insight_index: i,
          estimated_tokens: estimatedTokens,
          limit: this.config.maxTokensPerInsight,
        });

        // Truncate insight to fit limit
        const truncatedInsight = this.truncateInsight(insight, this.config.maxTokensPerInsight);
        adjusted_insights.push(truncatedInsight);
        totalTokens += this.estimateTokens(truncatedInsight);
      } else {
        adjusted_insights.push(insight);
        totalTokens += estimatedTokens;
      }
    }

    // Check batch limit
    if (totalTokens > this.config.maxTokensPerBatch) {
      // Remove insights to fit batch limit
      const fittingInsights = this.adjustBatchToFitTokenLimit(
        adjusted_insights,
        this.config.maxTokensPerBatch
      );
      return {
        valid: false,
        violations: [
          ...violations,
          {
            insight_index: -1, // Batch-level violation
            estimated_tokens: totalTokens,
            limit: this.config.maxTokensPerBatch,
          },
        ],
        adjusted_insights: fittingInsights,
      };
    }

    return {
      valid: violations.length === 0,
      violations,
      adjusted_insights,
    };
  }

  /**
   * Apply deterministic templates to insights
   */
  applyDeterministicTemplates(
    _insights: InsightTypeUnion[], 
    context: {
      correlation_id: string;
      session_id?: string;
    }
  ): InsightTypeUnion[] {
    if (!this.config.enableDeterministicTemplates) {
      return insights;
    }

    const deterministicInsights: InsightTypeUnion[] = [];

    for (const insight of insights) {
      const template = this.templates.get(insight.type);
      if (!template) {
        deterministicInsights.push(insight);
        continue;
      }

      // Apply deterministic formatting
      const deterministicInsight = this.applyTemplate(insight, template, context);
      deterministicInsights.push(deterministicInsight);
    }

    return deterministicInsights;
  }

  /**
   * Track provenance for generated insights
   */
  trackProvenance(
    _insights: InsightTypeUnion[], 
    _inputItems: unknown[], 
    context: {
      correlation_id: string;
      session_id?: string;
      processing_time_ms: number;
    }
  ): InsightProvenance[] {
    if (!this.config.enableProvenanceTracking) {
      return [];
    }

    const provenanceRecords: InsightProvenance[] = [];
    const inputItemsHash = this.generateInputItemsHash(inputItems);

    for (const insight of insights) {
      const provenance: InsightProvenance = {
        insight_id: insight.id,
        generation_timestamp: new Date().toISOString(),
        input_items_hash: inputItemsHash,
        template_used: this.templates.get(insight.type)?.id || 'none',
        configuration_snapshot: {
          insight_types: [insight.type],
          confidence_threshold: insight.confidence,
          max_insights_per_batch: 1, // Individual insight
        },
        processing_context: {
          node_id: process.env.NODE_ID || 'unknown',
          session_id: context.session_id,
          correlation_id: context.correlation_id,
        },
        performance_metrics: {
          generation_time_ms: context.processing_time_ms,
          tokens_estimated: this.estimateTokens(insight),
          memory_usage_mb: process.memoryUsage
            ? process.memoryUsage().heapUsed / 1024 / 1024
            : undefined,
        },
      };

      provenanceRecords.push(provenance);
      this.provenanceStore.set(insight.id, provenance);
    }

    return provenanceRecords;
  }

  /**
   * Ensure reproducible outputs
   */
  ensureReproducibleOutputs(
    _insights: InsightTypeUnion[], 
    context: {
      correlation_id: string;
      input_hash: string;
    }
  ): InsightTypeUnion[] {
    if (!this.config.enableReproducibleOutputs) {
      return insights;
    }

    const reproducibleInsights: InsightTypeUnion[] = [];

    for (const insight of insights) {
      const reproducibleInsight: InsightTypeUnion = {
        ...insight,
        metadata: {
          ...insight.metadata,
          ...(this.config.includeGenerationMetadata && {
            reproducible: {
              generation_id: this.generateReproducibleId(context),
              correlation_id: context.correlation_id,
              input_hash: context.input_hash,
              template_version: this.config.templateVersion,
              random_seed: this.config.randomSeed || 'default',
              generated_at: new Date().toISOString(),
            },
          }),
        },
      };

      reproducibleInsights.push(reproducibleInsight);
    }

    return reproducibleInsights;
  }

  /**
   * Generate deterministic cache key
   */
  generateDeterministicCacheKey(input: {
    items: unknown[];
    config: unknown;
    correlation_id: string;
  }): string {
    if (!this.config.cacheKeyDeterminism) {
      return crypto.randomBytes(16).toString('hex');
    }

    const deterministicInput = {
      items_hash: this.generateInputItemsHash(input.items),
      config_hash: crypto.createHash('md5').update(JSON.stringify(input.config)).digest('hex'),
      correlation_id: input.correlation_id,
      template_version: this.config.templateVersion,
      random_seed: this.config.randomSeed || 'default',
    };

    const cacheKey = crypto
      .createHash('sha256')
      .update(JSON.stringify(deterministicInput, Object.keys(deterministicInput).sort()))
      .digest('hex');

    return cacheKey;
  }

  /**
   * Get provenance records
   */
  getProvenance(_insightId: string): InsightProvenance | null {
    return this.provenanceStore.get(insightId) || null;
  }

  /**
   * Clean up old provenance records
   */
  cleanupProvenance(): number {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - this.config.provenanceRetentionDays);

    let cleanedCount = 0;
    for (const [id, provenance] of this.provenanceStore.entries()) {
      const provenanceDate = new Date(provenance.generation_timestamp);
      if (provenanceDate < cutoffDate) {
        this.provenanceStore.delete(id);
        cleanedCount++;
      }
    }

    if (cleanedCount > 0) {
      logger.info(`Cleaned up ${cleanedCount} old provenance records`);
    }

    return cleanedCount;
  }

  // Private helper methods

  private initializeTemplates(): void {
    const defaultTemplates: InsightTemplate[] = [
      {
        id: 'pattern-template',
        version: this.config.templateVersion,
        type: 'patterns',
        template:
          'Pattern Analysis: {title}\nDescription: {description}\nConfidence: {confidence}%\nItems: {item_count}',
        required_fields: ['title', 'description', 'confidence', 'item_count'],
        output_format: 'structured',
      },
      {
        id: 'connection-template',
        version: this.config.templateVersion,
        type: 'connections',
        template:
          'Connection Analysis: {title}\nDescription: {description}\nStrength: {confidence}%\nConnected Items: {item_count}',
        required_fields: ['title', 'description', 'confidence', 'item_count'],
        output_format: 'structured',
      },
      {
        id: 'recommendation-template',
        version: this.config.templateVersion,
        type: 'recommendations',
        template:
          'Recommendation: {title}\nAction: {description}\nPriority: {priority}\nConfidence: {confidence}%\nImpact: {impact_assessment}',
        required_fields: ['title', 'description', 'confidence', 'priority', 'impact_assessment'],
        output_format: 'structured',
      },
      {
        id: 'anomaly-template',
        version: this.config.templateVersion,
        type: 'anomalies',
        template:
          'Anomaly Detected: {title}\nDescription: {description}\nSeverity: {severity}\nConfidence: {confidence}%\nPotential Causes: {potential_causes}',
        required_fields: ['title', 'description', 'confidence', 'severity', 'potential_causes'],
        output_format: 'structured',
      },
      {
        id: 'trend-template',
        version: this.config.templateVersion,
        type: 'trends',
        template:
          'Trend Analysis: {title}\nDescription: {description}\nDirection: {trend_direction}\nStrength: {confidence}%\nPeriod: {time_period}',
        required_fields: ['title', 'description', 'confidence', 'trend_direction', 'time_period'],
        output_format: 'structured',
      },
    ];

    for (const template of defaultTemplates) {
      this.templates.set(template.type, template);
    }
  }

  private estimateTokens(_insight: InsightTypeUnion): number {
    const content = JSON.stringify(insight);

    if (this.config.tokenCountingMethod === 'exact') {
      // Simple token estimation: approximately 4 characters per token
      return Math.ceil(content.length / 4);
    } else {
      // Approximate token counting based on word count
      const words = content.split(/\s+/).length;
      return Math.ceil(words * 1.3); // Account for punctuation and tokens
    }
  }

  private truncateInsight(_insight: InsightTypeUnion,  _maxTokens: number): InsightTypeUnion {
    const currentTokens = this.estimateTokens(insight);
    const reductionRatio = maxTokens / currentTokens;

    const truncatedInsight = { ...insight };

    // Truncate description if available
    if (truncatedInsight.description && typeof truncatedInsight.description === 'string') {
      const targetLength = Math.floor(truncatedInsight.description.length * reductionRatio);
      truncatedInsight.description =
        truncatedInsight.description.substring(0, targetLength) + '... [truncated]';
    }

    // Truncate title if needed
    if (truncatedInsight.title && typeof truncatedInsight.title === 'string') {
      const targetLength = Math.min(
        100,
        Math.floor(truncatedInsight.title.length * reductionRatio)
      );
      truncatedInsight.title = truncatedInsight.title.substring(0, targetLength) + '...';
    }

    return truncatedInsight;
  }

  private adjustBatchToFitTokenLimit(
    _insights: InsightTypeUnion[], 
    _maxTokens: number
  ): InsightTypeUnion[] {
    const fittingInsights: InsightTypeUnion[] = [];
    let currentTokens = 0;

    for (const insight of insights) {
      const insightTokens = this.estimateTokens(insight);

      if (currentTokens + insightTokens <= maxTokens) {
        fittingInsights.push(insight);
        currentTokens += insightTokens;
      } else {
        break; // Stop adding insights to stay within limit
      }
    }

    return fittingInsights;
  }

  private applyTemplate(
    _insight: InsightTypeUnion, 
    _template: InsightTemplate, 
    context: { correlation_id: string }
  ): InsightTypeUnion {
    const templatedInsight = { ...insight };

    // Apply template formatting
    if (template.output_format === 'structured') {
      // Add structured metadata
      templatedInsight.metadata = {
        ...templatedInsight.metadata,
        templateId: template.id,
        templateVersion: template.version,
        correlationId: context.correlation_id,
      } as unknown;
    }

    return templatedInsight;
  }

  private generateInputItemsHash(_items: unknown[]): string {
    const sortedItems = items.sort((a,  _b) => {
      const aId = a.id || '';
      const bId = b.id || '';
      return aId.localeCompare(bId);
    });

    return crypto
      .createHash('sha256')
      .update(JSON.stringify(sortedItems))
      .digest('hex')
      .substring(0, 16);
  }

  private generateReproducibleId(context: { correlation_id: string; input_hash: string }): string {
    const seed = this.config.randomSeed || 'default';
    const reproducibleString = `${context.correlation_id}-${context.input_hash}-${seed}`;

    return crypto.createHash('md5').update(reproducibleString).digest('hex').substring(0, 16);
  }
}

// Export singleton instance
export const insightGenerationGuardrails = new InsightGenerationGuardrails();
