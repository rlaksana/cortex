/**
 * Error Budget Service
 *
 * Comprehensive service for tracking error budgets, calculating burn rates,
 * providing budget projections, and managing budget-based alerting and automation.
 *
 * @author Cortex Team
 * @version 2.0.0
 * @since 2025
 */

import { EventEmitter } from 'events';
import type {
  SLO,
  SLOEvaluation,
  ErrorBudget,
  BudgetProjection,
  BurnRateAnalysis,
  BudgetAlert,
  BudgetConsumption,
  BudgetPeriod,
  ErrorBudgetPolicy,
  BudgetUtilization,
  TimeRange,
} from '../types/slo-interfaces.js';
import { BurnRateTrend } from '../types/slo-interfaces.js';
import type { SLOService } from './slo-service.js';

/**
 * Error Budget Service
 */
export class ErrorBudgetService extends EventEmitter {
  private sloService: SLOService;
  private budgetHistory: Map<string, ErrorBudgetHistory[]> = new Map();
  private burnRateHistory: Map<string, BurnRateDataPoint[]> = new Map();
  private budgetPolicies: Map<string, ErrorBudgetPolicy> = new Map();
  private budgetAlerts: Map<string, BudgetAlert[]> = new Map();
  private isStarted = false;
  private calculationIntervals: Map<string, NodeJS.Timeout> = new Map();

  constructor(_sloService: SLOService) {
    super();
    this.sloService = _sloService;
    this.setupEventHandlers();
  }

  /**
   * Start the error budget service
   */
  async start(): Promise<void> {
    if (this.isStarted) {
      this.emit('warning', 'Error Budget Service is already started');
      return Promise.resolve();
    }

    try {
      this.isStarted = true;
      this.emit('started', 'Error Budget Service started successfully');

      // Initialize budget tracking for all active SLOs
      await this.initializeBudgetTracking();

      // Schedule periodic budget calculations
      this.schedulePeriodicCalculations();
    } catch (error) {
      this.isStarted = false;
      this.emit('error', `Failed to start Error Budget Service: ${error}`);
      throw error;
    }
  }

  /**
   * Stop the error budget service
   */
 async stop(): Promise<void> {
    if (!this.isStarted) {
      this.emit('warning', 'Error Budget Service is not started');
      return Promise.resolve();
    }

    try {
      // Stop all calculation intervals
      for (const [sloId,  interval] of this.calculationIntervals) {
        clearInterval(interval);
      }
      this.calculationIntervals.clear();

      this.isStarted = false;
      this.emit('stopped', 'Error Budget Service stopped successfully');
    } catch (error) {
      this.emit('error', `Error stopping Error Budget Service: ${error}`);
      throw error;
    }
  }

  // ============================================================================
  // Error Budget Calculation
  // ============================================================================

  /**
   * Calculate current error budget for an SLO
   */
  async calculateErrorBudget(sloId: string, timeWindow?: TimeRange): Promise<ErrorBudget> {
    const slo = this.sloService.getSLO(sloId);
    if (!slo) {
      throw new Error(`SLO ${sloId} not found`);
    }

    const evaluation = this.sloService.getLatestEvaluation(sloId);
    if (!evaluation) {
      throw new Error(`No evaluation found for SLO ${sloId}`);
    }

    // Determine calculation period
    const period = timeWindow || this.getBudgetPeriod(slo);

    // Get historical data for the period
    const evaluations = this.sloService.getEvaluations(sloId, 1000);
    const periodEvaluations = this.filterEvaluationsByPeriod(evaluations, period);

    // Calculate budget metrics
    const budgetMetrics = this.calculateBudgetMetrics(slo, periodEvaluations, period);

    // Calculate consumption rates
    const consumption = this.calculateBudgetConsumption(periodEvaluations, period);

    // Generate projection
    const projection = this.generateBudgetProjection(budgetMetrics, consumption, period);

    const errorBudget: ErrorBudget = {
      sloId,
      sloName: slo.name,
      period,
      total: slo.budgeting.errorBudget,
      remaining: budgetMetrics.remaining,
      consumed: budgetMetrics.consumed,
      consumption,
      projection,
      utilization: this.calculateBudgetUtilization(budgetMetrics),
      alerts: await this.generateBudgetAlerts(slo, budgetMetrics, consumption),
      metadata: {
        calculatedAt: new Date(),
        dataPoints: periodEvaluations.length,
        confidence: this.calculateConfidence(periodEvaluations),
        methodology: 'time_weighted_average',
      },
    };

    // Store in history
    this.storeBudgetHistory(sloId, errorBudget);

    this.emit('budget:calculated', errorBudget);
    return errorBudget;
  }

  /**
   * Get error budget history for an SLO
   */
  getErrorBudgetHistory(_sloId: string,  limit?: number): ErrorBudgetHistory[] {
    const history = this.budgetHistory.get(_sloId) || [];
    return limit ? history.slice(-limit) : [...history];
  }

  /**
   * Get current error budgets for multiple SLOs
   */
  async getMultipleErrorBudgets(sloIds: string[]): Promise<ErrorBudget[]> {
    const budgets = await Promise.allSettled(
      sloIds.map((sloId) => this.calculateErrorBudget(sloId))
    );

    return budgets
      .filter(
        (result): result is PromiseFulfilledResult<ErrorBudget> => result.status === 'fulfilled'
      )
      .map((result) => result.value);
  }

  // ============================================================================
  // Burn Rate Analysis
  // ============================================================================

  /**
   * Calculate burn rate analysis
   */
 calculateBurnRateAnalysis(
    sloId: string,
    timeWindow?: TimeRange
  ): Promise<BurnRateAnalysis> {
    const slo = this.sloService.getSLO(sloId);
    if (!slo) {
      throw new Error(`SLO ${sloId} not found`);
    }

    const period = timeWindow || this.getBudgetPeriod(slo);
    const evaluations = this.sloService.getEvaluations(sloId, 1000);
    const periodEvaluations = this.filterEvaluationsByPeriod(evaluations, period);

    // Calculate burn rates at different time scales
    const burnRates = {
      hourly: this.calculateBurnRateAtTimeScale(periodEvaluations, 'hourly'),
      daily: this.calculateBurnRateAtTimeScale(periodEvaluations, 'daily'),
      weekly: this.calculateBurnRateAtTimeScale(periodEvaluations, 'weekly'),
      monthly: this.calculateBurnRateAtTimeScale(periodEvaluations, 'monthly'),
    };

    // Analyze burn rate trend
    const trend = this.analyzeBurnRateTrend(periodEvaluations);

    // Calculate burn rate velocity
    const velocity = this.calculateBurnRateVelocity(periodEvaluations);

    // Assess burn rate health
    const health = this.assessBurnRateHealth(slo, burnRates, trend);

    // Generate burn rate alerts
    const alerts = this.generateBurnRateAlerts(slo, burnRates, trend, health);

    const analysis: BurnRateAnalysis = {
      sloId,
      sloName: slo.name,
      period,
      currentRates: burnRates,
      trend,
      velocity,
      health,
      alerts,
      recommendations: this.generateBurnRateRecommendations(slo, burnRates, trend, health),
      metadata: {
        calculatedAt: new Date(),
        dataPoints: periodEvaluations.length,
        confidence: this.calculateConfidence(periodEvaluations),
      },
    };

    // Store burn rate data point
    this.storeBurnRateDataPoint(sloId, analysis);

    this.emit('burn-rate:analyzed', analysis);
    return analysis;
  }

  /**
   * Get burn rate history
   */
  getBurnRateHistory(_sloId: string,  limit?: number): BurnRateDataPoint[] {
    const history = this.burnRateHistory.get(_sloId) || [];
    return limit ? history.slice(-limit) : [...history];
  }

  /**
   * Compare burn rates across SLOs
   */
  async compareBurnRates(sloIds: string[]): Promise<BurnRateComparison> {
    const analyses = await Promise.all(
      sloIds.map((sloId) => this.calculateBurnRateAnalysis(sloId))
    );

    const comparison: BurnRateComparison = {
      period: analyses[0]?.period || { start: new Date(), end: new Date() },
      sloComparisons: analyses.map((analysis) => ({
        sloId: analysis.sloId,
        sloName: analysis.sloName,
        burnRate: analysis.currentRate,
        trend: analysis.trend,
        health: analysis.health,
      })),
      rankings: this.rankSLOsByBurnRate(analyses),
      insights: this.generateBurnRateInsights(analyses),
      generatedAt: new Date(),
    };

    this.emit('burn-rate:compared', comparison);
    return comparison;
  }

  // ============================================================================
  // Budget Projections
  // ============================================================================

  /**
   * Generate budget projection
   */
  async generateBudgetProjection(
    sloId: string,
    projectionPeriodParam?: TimeRange
  ): Promise<BudgetProjection> {
    const slo = this.sloService.getSLO(sloId);
    if (!slo) {
      throw new Error(`SLO ${sloId} not found`);
    }

    const currentBudget = await this.calculateErrorBudget(sloId);
    const burnRateAnalysis = await this.calculateBurnRateAnalysis(sloId);

    const projectionPeriod = projectionPeriodParam || {
      type: 'fixed',
      start: new Date(),
      end: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days
    };

    // Generate multiple projection scenarios
    const scenarios = await Promise.all([
      this.generateProjectionScenario(
        'current_trend',
        currentBudget,
        burnRateAnalysis,
        projectionPeriod
      ),
      this.generateProjectionScenario(
        'pessimistic',
        currentBudget,
        burnRateAnalysis,
        projectionPeriod
      ),
      this.generateProjectionScenario(
        'optimistic',
        currentBudget,
        burnRateAnalysis,
        projectionPeriod
      ),
    ]);

    // Calculate exhaustion probability
    const exhaustionProbability = this.calculateExhaustionProbability(scenarios);

    // Generate budget recommendations
    const recommendations = this.generateBudgetRecommendations(
      slo,
      currentBudget,
      burnRateAnalysis,
      scenarios
    );

    const projection: BudgetProjection = {
      sloId,
      sloName: slo.name,
      projectionPeriod,
      scenarios,
      exhaustionProbability,
      recommendations,
      metadata: {
        generatedAt: new Date(),
        methodology: 'monte_carlo_simulation',
        iterations: 1000,
        confidence: currentBudget.metadata.confidence,
      },
    };

    this.emit('projection:generated', projection);
    return projection;
  }

  /**
   * Get budget exhaustion forecast
   */
  async getBudgetExhaustionForecast(sloId: string): Promise<ExhaustionForecast> {
    const projection = await this.generateBudgetProjection(sloId);

    // Find earliest exhaustion across scenarios
    const scenarioDates = [
      projection.scenarios.optimistic,
      projection.scenarios.realistic,
      projection.scenarios.pessimistic,
    ].filter((date) => date !== null) as Date[];

    const earliestExhaustion =
      scenarioDates.length > 0
        ? new Date(Math.min(...scenarioDates.map((date: Date) => date.getTime())))
        : null;

    // Calculate time to exhaustion
    const timeToExhaustion = earliestExhaustion ? earliestExhaustion.getTime() - Date.now() : null;

    const forecast: ExhaustionForecast = {
      sloId,
      earliestExhaustion,
      timeToExhaustion,
      probabilityOfExhaustion: projection.exhaustionProbability,
      confidence: projection.metadata.confidence,
      recommendations: this.generateExhaustionRecommendations(
        sloId,
        earliestExhaustion,
        timeToExhaustion
      ),
      generatedAt: new Date(),
    };

    this.emit('exhaustion:forecasted', forecast);
    return forecast;
  }

  // ============================================================================
  // Budget Policies Management
  // ============================================================================

  /**
   * Configure error budget policy
   */
  configureBudgetPolicy(_sloId: string,  _policy: ErrorBudgetPolicy): void {
    this.budgetPolicies.set(sloId, policy);
    this.emit('policy:configured', { sloId, policy });
  }

  /**
   * Get budget policy for an SLO
   */
  getBudgetPolicy(_sloId: string): ErrorBudgetPolicy | undefined {
    return this.budgetPolicies.get(sloId);
  }

  /**
   * Evaluate policy compliance
   */
  async evaluatePolicyCompliance(sloId: string): Promise<PolicyComplianceResult> {
    const policy = this.budgetPolicies.get(sloId);
    if (!policy) {
      throw new Error(`No policy configured for SLO ${sloId}`);
    }

    const budget = await this.calculateErrorBudget(sloId);
    const burnRateAnalysis = await this.calculateBurnRateAnalysis(sloId);

    const compliance = {
      withinBurnRateLimits: this.checkBurnRateCompliance(policy, burnRateAnalysis),
      withinConsumptionLimits: this.checkConsumptionCompliance(policy, budget),
      alertsTriggered: this.checkAlertCompliance(policy, budget, burnRateAnalysis),
      automatedResponses: this.checkAutomationCompliance(policy, budget, burnRateAnalysis),
    };

    const overallCompliance = Object.values(compliance).every((result) => result.compliant);

    const result: PolicyComplianceResult = {
      sloId,
      policyId: policy.id,
      overallCompliance,
      compliance,
      violations: this.identifyPolicyViolations(policy, budget, burnRateAnalysis),
      recommendations: this.generatePolicyRecommendations(policy, budget, burnRateAnalysis),
      evaluatedAt: new Date(),
    };

    this.emit('policy:evaluated', result);
    return result;
  }

  // ============================================================================
  // Budget Alerts Management
  // ============================================================================

  /**
   * Get active budget alerts
   */
  getActiveBudgetAlerts(sloId?: string): BudgetAlert[] {
    const allAlerts = Array.from(this.budgetAlerts.values()).flat();
    const activeAlerts = allAlerts.filter((alert) => !alert.resolved);

    if (_sloId) {
      return activeAlerts.filter((alert) => alert.sloId === sloId);
    }

    return activeAlerts;
  }

  /**
   * Acknowledge a budget alert
   */
 acknowledgeBudgetAlert(alertId: string, acknowledgedBy: string): Promise<boolean> {
    const allAlerts = Array.from(this.budgetAlerts.values()).flat();
    const alert = allAlerts.find((a) => a.id === alertId);

    if (!alert || alert.resolved) {
      return Promise.resolve(false);
    }

    alert.acknowledged = true;
    alert.acknowledgedBy = acknowledgedBy;
    alert.acknowledgedAt = new Date();

    this.emit('alert:acknowledged', alert);
    return Promise.resolve(true);
  }

  /**
   * Resolve a budget alert
   */
 resolveBudgetAlert(
    alertId: string,
    resolvedBy: string,
    resolution?: string
  ): Promise<boolean> {
    const allAlerts = Array.from(this.budgetAlerts.values()).flat();
    const alert = allAlerts.find((a) => a.id === alertId);

    if (!alert) {
      return Promise.resolve(false);
    }

    alert.resolved = true;
    alert.resolvedBy = resolvedBy;
    alert.resolvedAt = new Date();
    alert.resolution = resolution;

    this.emit('alert:resolved', alert);
    return Promise.resolve(true);
  }

  // ============================================================================
  // Private Helper Methods
  // ============================================================================

  /**
   * Setup event handlers
   */
  private setupEventHandlers(): void {
    // Listen for SLO evaluations
    this.sloService.on('slo:evaluated',  async (evaluation: SLOEvaluation) => {
      if (this.isStarted) {
        await this.calculateErrorBudget(evaluation.sloId);
        await this.calculateBurnRateAnalysis(evaluation.sloId);
      }
    });
  }

  /**
   * Initialize budget tracking for all active SLOs
   */
  private async initializeBudgetTracking(): Promise<void> {
    const slos = this.sloService.getAllSLOs();

    for (const slo of slos) {
      if (slo.status === 'active') {
        // Initialize budget calculation
        await this.calculateErrorBudget(slo.id);

        // Start periodic calculations for this SLO
        this.startBudgetCalculation(slo.id);
      }
    }
  }

  /**
   * Start budget calculation for an SLO
   */
  private startBudgetCalculation(_sloId: string): void {
    // Stop existing calculation if any
    this.stopBudgetCalculation(sloId);

    // Start calculation interval
    const interval = setInterval(async () => {
      try {
        await this.calculateErrorBudget(sloId);
        await this.calculateBurnRateAnalysis(sloId);
      } catch (error) {
        this.emit('error', `Budget calculation failed for SLO ${sloId}: ${error}`);
      }
    }, 60000); // Calculate every minute

    this.calculationIntervals.set(sloId, interval);
  }

  /**
   * Stop budget calculation for an SLO
   */
  private stopBudgetCalculation(_sloId: string): void {
    const interval = this.calculationIntervals.get(_sloId);
    if (_interval) {
      clearInterval(interval);
      this.calculationIntervals.delete(sloId);
    }
  }

  /**
   * Schedule periodic calculations
   */
  private schedulePeriodicCalculations(): void {
    // Comprehensive calculation every 5 minutes
    setInterval(
      async () => {
        if (!this.isStarted) return Promise.resolve();

        try {
          const slos = this.sloService.getAllSLOs();
          for (const slo of slos) {
            if (slo.status === 'active') {
              await this.calculateErrorBudget(slo.id);
              await this.calculateBurnRateAnalysis(slo.id);
            }
          }
        } catch (error) {
          this.emit('error', `Periodic budget calculation failed: ${error}`);
        }
      },
      5 * 60 * 1000
    ); // Every 5 minutes
  }

  /**
   * Get budget period for an SLO
   */
  private getBudgetPeriod(_slo: SLO): BudgetPeriod {
    const objectivePeriod = slo.objective.period;
    const now = new Date();

    switch (_objectivePeriod) {
      case 'rolling_7_days':
        return {
          start: new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000),
          end: now,
          type: 'rolling',
          duration: 7 * 24 * 60 * 60 * 1000,
        };
      case 'rolling_30_days':
        return {
          start: new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000),
          end: now,
          type: 'rolling',
          duration: 30 * 24 * 60 * 60 * 1000,
        };
      case 'calendar_month':
        return {
          start: new Date(now.getFullYear(), now.getMonth(), 1),
          end: new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59, 999),
          type: 'calendar',
          duration: 0,
        };
      default:
        return {
          start: new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000),
          end: now,
          type: 'rolling',
          duration: 30 * 24 * 60 * 60 * 1000,
        };
    }
  }

  /**
   * Filter evaluations by period
   */
  private filterEvaluationsByPeriod(
    _evaluations: SLOEvaluation[], 
    _period: BudgetPeriod
  ): SLOEvaluation[] {
    return _evaluations.filter(
      (evaluation: SLOEvaluation) => evaluation.timestamp >= _period.start && evaluation.timestamp <= _period.end
    );
  }

  /**
   * Calculate budget metrics
   */
  private calculateBudgetMetrics(
    _slo: SLO, 
    _evaluations: SLOEvaluation[], 
    _period: BudgetPeriod
  ): { remaining: number; consumed: number; total: number } {
    const totalBudget = slo.budgeting.errorBudget;

    if (evaluations.length === 0) {
      return { remaining: totalBudget, consumed: 0, total: totalBudget };
    }

    // Calculate time-weighted average consumption
    let totalConsumption = 0;
    let totalWeight = 0;

    for (let i = 0; i < evaluations.length; i++) {
      const evaluation = evaluations[i];
      const nextEvaluation = evaluations[i + 1];

      const endTime = nextEvaluation ? nextEvaluation.timestamp : period.end;
      const duration = endTime.getTime() - evaluation.timestamp.getTime();
      const weight = duration;

      totalConsumption += evaluation.budget.consumed * weight;
      totalWeight += weight;
    }

    const averageConsumption = totalWeight > 0 ? totalConsumption / totalWeight : 0;
    const remaining = Math.max(0, totalBudget - averageConsumption);

    return {
      remaining,
      consumed: averageConsumption,
      total: totalBudget,
    };
  }

  /**
   * Calculate budget consumption
   */
  private calculateBudgetConsumption(
    _evaluations: SLOEvaluation[], 
    _period: BudgetPeriod
  ): BudgetConsumption {
    if (evaluations.length === 0) {
      return {
        currentRate: 0,
        averageRate: 0,
        peakRate: 0,
        consumptionVelocity: 0,
        timeToExhaustion: null,
      };
    }

    // Calculate consumption rates
    const rates = evaluations.map((e: SLOEvaluation) => e.budget.burnRate);
    const currentRate = rates[rates.length - 1] || 0;
    const averageRate = rates.reduce((sum: number,  rate: number) => sum + rate, 0) / rates.length;
    const peakRate = Math.max(...rates);

    // Calculate consumption velocity (rate of change of burn rate)
    let velocity = 0;
    if (rates.length >= 2) {
      const recentRates = rates.slice(-5);
      const slope = this.calculateLinearRegression(
        recentRates.map((rate: number,  i: number) => ({ x: i, y: rate }))
      );
      velocity = slope.slope;
    }

    // Calculate time to exhaustion
    const latestEvaluation = evaluations[evaluations.length - 1];
    const timeToExhaustion =
      latestEvaluation && latestEvaluation.budget.burnRate > 0
        ? (latestEvaluation.budget.remaining / latestEvaluation.budget.burnRate) * 60 * 60 * 1000 // Convert to milliseconds
        : null;

    return {
      currentRate,
      averageRate,
      peakRate,
      consumptionVelocity: velocity,
      timeToExhaustion,
    };
  }

  /**
   * Calculate budget utilization
   */
  private calculateBudgetUtilization(budgetMetrics: {
    remaining: number;
    consumed: number;
    total: number;
  }): BudgetUtilization {
    const utilizationPercentage = (budgetMetrics.consumed / budgetMetrics.total) * 100;

    return {
      percentage: utilizationPercentage,
      efficiency: Math.max(0, 100 - utilizationPercentage), // Inverse of utilization
      status: this.getBudgetStatus(utilizationPercentage),
      trend: 'stable', // Would calculate from historical data
    };
  }

  /**
   * Get budget status
   */
  private getBudgetStatus(_percentage: number): 'healthy' | 'warning' | 'critical' | 'exhausted' {
    if (percentage >= 100) return 'exhausted';
    if (percentage >= 80) return 'critical';
    if (percentage >= 60) return 'warning';
    return 'healthy';
  }

  /**
   * Generate budget alerts
   */
  private async generateBudgetAlerts(
    slo: SLO,
    budgetMetrics: { remaining: number; consumed: number; total: number },
    consumption: BudgetConsumption
  ): Promise<BudgetAlert[]> {
    const alerts: BudgetAlert[] = [];
    const utilizationPercentage = (budgetMetrics.consumed / budgetMetrics.total) * 100;

    // Budget exhaustion alert
    if (budgetMetrics.remaining <= 0) {
      alerts.push({
        id: this.generateId(),
        sloId: slo.id,
        type: 'exhaustion',
        severity: 'critical',
        title: 'Error Budget Exhausted',
        message: `Error budget for ${slo.name} has been exhausted`,
        threshold: 0,
        currentValue: budgetMetrics.remaining,
        triggeredAt: new Date(),
        acknowledged: false,
        resolved: false,
      });
    }

    // High consumption rate alert
    if (consumption.currentRate > 2) {
      alerts.push({
        id: this.generateId(),
        sloId: slo.id,
        type: 'burn_rate',
        severity: consumption.currentRate > 5 ? 'critical' : 'warning',
        title: 'High Burn Rate Detected',
        message: `Burn rate is ${String(consumption.currentRate.toFixed(2))}x, exceeding normal levels`,
        threshold: 2,
        currentValue: consumption.currentRate,
        triggeredAt: new Date(),
        acknowledged: false,
        resolved: false,
      });
    }

    // Budget depletion warning
    if (utilizationPercentage >= 80) {
      alerts.push({
        id: this.generateId(),
        sloId: slo.id,
        type: 'exhaustion',
        severity: utilizationPercentage >= 95 ? 'critical' : 'warning',
        title: 'Error Budget Depletion Warning',
        message: `${String(utilizationPercentage.toFixed(1))}% of error budget consumed`,
        threshold: 80,
        currentValue: utilizationPercentage,
        triggeredAt: new Date(),
        acknowledged: false,
        resolved: false,
      });
    }

    // Store alerts
    const existingAlerts = this.budgetAlerts.get(slo.id) || [];
    existingAlerts.push(...alerts);
    this.budgetAlerts.set(slo.id, existingAlerts);

    return alerts;
  }

  /**
   * Calculate burn rate at specific time scale
   */
  private calculateBurnRateAtTimeScale(
    _evaluations: SLOEvaluation[], 
    _timeScale: 'hourly' | 'daily' | 'weekly' | 'monthly'
  ): number {
    if (evaluations.length === 0) return 0;

    const now = new Date();
    let periodStart: Date;

    switch (_timeScale) {
      case 'hourly':
        periodStart = new Date(now.getTime() - 60 * 60 * 1000);
        break;
      case 'daily':
        periodStart = new Date(now.getTime() - 24 * 60 * 60 * 1000);
        break;
      case 'weekly':
        periodStart = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        break;
      case 'monthly':
        periodStart = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        break;
    }

    const periodEvaluations = evaluations.filter((e: SLOEvaluation) => e.timestamp >= periodStart);
    if (periodEvaluations.length < 2) return 0;

    const first = periodEvaluations[0];
    const last = periodEvaluations[periodEvaluations.length - 1];

    const budgetConsumed = last.budget.consumed - first.budget.consumed;
    const timeElapsed = last.timestamp.getTime() - first.timestamp.getTime();
    const hoursElapsed = timeElapsed / (60 * 60 * 1000);

    return hoursElapsed > 0 ? budgetConsumed / hoursElapsed : 0;
  }

  /**
   * Analyze burn rate trend
   */
  private analyzeBurnRateTrend(_evaluations: SLOEvaluation[]): {
    direction: BurnRateTrend;
    confidence: number;
    slope: number;
  } {
    if (evaluations.length < 3) {
      return { direction: BurnRateTrend.UNKNOWN, confidence: 0, slope: 0 };
    }

    const burnRates = evaluations.map((e: SLOEvaluation) => e.budget.burnRate);
    const regression = this.calculateLinearRegression(
      burnRates.map((rate: number,  i: number) => ({ x: i, y: rate }))
    );

    let direction: BurnRateTrend;
    if (Math.abs(regression.slope) < 0.01) {
      direction = BurnRateTrend.STABLE;
    } else if (regression.slope > 0) {
      direction = BurnRateTrend.INCREASING;
    } else {
      direction = BurnRateTrend.DECREASING;
    }

    // Calculate confidence based on correlation
    const correlation = this.calculateCorrelation(burnRates.map((rate: number,  i: number) => ({ x: i, y: rate })));
    const confidence = Math.abs(correlation);

    return {
      direction,
      confidence,
      slope: regression.slope,
    };
  }

  /**
   * Calculate burn rate velocity
   */
  private calculateBurnRateVelocity(_evaluations: SLOEvaluation[]): {
    current: number;
    average: number;
    acceleration: number;
  } {
    if (evaluations.length < 3) {
      return { current: 0, average: 0, acceleration: 0 };
    }

    const burnRates = evaluations.map((e: SLOEvaluation) => e.budget.burnRate);
    const current = burnRates[burnRates.length - 1];
    const average = burnRates.reduce((sum: number,  rate: number) => sum + rate, 0) / burnRates.length;

    // Calculate acceleration (second derivative)
    let acceleration = 0;
    if (burnRates.length >= 3) {
      const recent = burnRates.slice(-3);
      const firstDiff = recent[1] - recent[0];
      const secondDiff = recent[2] - recent[1];
      acceleration = secondDiff - firstDiff;
    }

    return { current, average, acceleration };
  }

  /**
   * Assess burn rate health
   */
  private assessBurnRateHealth(
    _slo: SLO, 
    burnRates: { hourly: number; daily: number; weekly: number; monthly: number }, 
    trend: { direction: BurnRateTrend; confidence: number; slope: number }
  ): {
    status: 'healthy' | 'warning' | 'critical';
    score: number;
    factors: string[];
  } {
    const factors: string[] = [];
    let score = 100;

    // Check current burn rate
    if (burnRates.daily > 2) {
      score -= 30;
      factors.push('High daily burn rate');
    } else if (burnRates.daily > 1) {
      score -= 15;
      factors.push('Elevated daily burn rate');
    }

    // Check trend
    if (trend.direction === BurnRateTrend.INCREASING && trend.confidence > 0.7) {
      score -= 20;
      factors.push('Increasing burn rate trend');
    }

    // Check acceleration
    if (burnRates.daily > burnRates.weekly * 1.5) {
      score -= 15;
      factors.push('Accelerating consumption');
    }

    let status: 'healthy' | 'warning' | 'critical';
    if (score >= 80) {
      status = 'healthy';
    } else if (score >= 60) {
      status = 'warning';
    } else {
      status = 'critical';
    }

    return { status, score, factors };
  }

  /**
   * Generate burn rate alerts
   */
  private generateBurnRateAlerts(
    _slo: SLO, 
    burnRates: { hourly: number; daily: number; weekly: number; monthly: number }, 
    trend: { direction: BurnRateTrend; confidence: number; slope: number }, 
    health: { status: 'healthy' | 'warning' | 'critical'; score: number; factors: string[] }
  ): BudgetAlert[] {
    const alerts: BudgetAlert[] = [];

    // High burn rate alerts
    if (burnRates.daily > 5) {
      alerts.push({
        id: this.generateId(),
        sloId: slo.id,
        type: 'burn_rate',
        severity: 'critical',
        title: 'Critical Burn Rate',
        message: `Daily burn rate is ${String(burnRates.daily.toFixed(2))}x`,
        threshold: 5,
        currentValue: burnRates.daily,
        triggeredAt: new Date(),
        acknowledged: false,
        resolved: false,
      });
    } else if (burnRates.daily > 2) {
      alerts.push({
        id: this.generateId(),
        sloId: slo.id,
        type: 'burn_rate',
        severity: 'warning',
        title: 'High Burn Rate',
        message: `Daily burn rate is ${String(burnRates.daily.toFixed(2))}x`,
        threshold: 2,
        currentValue: burnRates.daily,
        triggeredAt: new Date(),
        acknowledged: false,
        resolved: false,
      });
    }

    // Trend alerts
    if (trend.direction === BurnRateTrend.INCREASING && trend.confidence > 0.8) {
      alerts.push({
        id: this.generateId(),
        sloId: slo.id,
        type: 'burn_rate',
        severity: 'warning',
        title: 'Increasing Burn Rate Trend',
        message: `Burn rate is trending upward with ${String((trend.confidence * 100).toFixed(0))}% confidence`,
        threshold: 0.8,
        currentValue: trend.confidence,
        triggeredAt: new Date(),
        acknowledged: false,
        resolved: false,
      });
    }

    return alerts;
  }

  /**
   * Generate burn rate recommendations
   */
  private generateBurnRateRecommendations(
    _slo: SLO, 
    burnRates: { hourly: number; daily: number; weekly: number; monthly: number }, 
    trend: { direction: BurnRateTrend; confidence: number; slope: number }, 
    health: { status: 'healthy' | 'warning' | 'critical'; score: number; factors: string[] }
  ): string[] {
    const recommendations: string[] = [];

    if (burnRates.daily > 2) {
      recommendations.push(
        'Investigate cause of high burn rate and implement immediate mitigation'
      );
      recommendations.push('Consider traffic throttling or capacity increases');
    }

    if (trend.direction === BurnRateTrend.INCREASING) {
      recommendations.push('Monitor the increasing trend and prepare escalation procedures');
      recommendations.push('Review recent changes that might be affecting performance');
    }

    if (health.factors.includes('Accelerating consumption')) {
      recommendations.push('Implement automated scaling to handle increased load');
      recommendations.push('Review and optimize resource utilization');
    }

    if (recommendations.length === 0) {
      recommendations.push('Continue monitoring burn rate trends');
    }

    return recommendations;
  }

  /**
   * Store budget history
   */
  private storeBudgetHistory(_sloId: string,  _budget: ErrorBudget): void {
    const history = this.budgetHistory.get(_sloId) || [];
    history.push({
      timestamp: budget.metadata.calculatedAt,
      remaining: budget.remaining,
      consumed: budget.consumed,
      utilization: budget.utilization.percentage,
    });

    // Keep only last 1000 data points
    if (history.length > 1000) {
      history.splice(0, history.length - 1000);
    }

    this.budgetHistory.set(sloId, history);
  }

  /**
   * Store burn rate data point
   */
  private storeBurnRateDataPoint(_sloId: string,  _analysis: BurnRateAnalysis): void {
    const history = this.burnRateHistory.get(_sloId) || [];
    history.push({
      timestamp: analysis.metadata.calculatedAt,
      hourlyRate: analysis.currentRate,
      dailyRate: analysis.currentRate,
      weeklyRate: analysis.currentRate,
      monthlyRate: analysis.currentRate,
      trend: analysis.trend.direction,
      healthScore: analysis.health.score,
    });

    // Keep only last 1000 data points
    if (history.length > 1000) {
      history.splice(0, history.length - 1000);
    }

    this.burnRateHistory.set(sloId, history);
  }

  /**
   * Calculate confidence in data
   */
  private calculateConfidence(_evaluations: SLOEvaluation[]): number {
    if (_evaluations.length === 0) return 0;
    if (_evaluations.length < 5) return 0.5;

    // Calculate confidence based on data recency and consistency
    const now = Date.now();
    const recentData = _evaluations.filter((e: SLOEvaluation) => now - e.timestamp.getTime() < 24 * 60 * 60 * 1000);
    const recencyFactor = Math.min(recentData.length / _evaluations.length, 1);

    const consistency = this.calculateConsistency(_evaluations);

    return recencyFactor * 0.6 + consistency * 0.4;
  }

  /**
   * Calculate data consistency
   */
  private calculateConsistency(_evaluations: SLOEvaluation[]): number {
    if (_evaluations.length < 2) return 1;

    const values = _evaluations.map((e: SLOEvaluation) => e.objective.compliance);
    const mean = values.reduce((sum: number,  val: number) => sum + val, 0) / values.length;
    const variance = values.reduce((sum: number,  val: number) => sum + Math.pow(val - mean, 2), 0) / values.length;
    const stdDev = Math.sqrt(variance);

    // Lower standard deviation means higher consistency
    return Math.max(0, 1 - stdDev / mean);
  }

  /**
   * Calculate linear regression
   */
  private calculateLinearRegression(data: { x: number; y: number }[]): {
    slope: number;
    intercept: number;
  } {
    if (data.length < 2) return { slope: 0, intercept: 0 };

    const n = data.length;
    let sumX = 0,
      sumY = 0,
      sumXY = 0,
      sumX2 = 0;

    for (const point of data) {
      sumX += point.x;
      sumY += point.y;
      sumXY += point.x * point.y;
      sumX2 += point.x * point.x;
    }

    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
    const intercept = (sumY - slope * sumX) / n;

    return { slope, intercept };
  }

  /**
   * Calculate correlation coefficient
   */
  private calculateCorrelation(data: { x: number; y: number }[]): number {
    if (data.length < 2) return 0;

    const n = data.length;
    const sumX = data.reduce((sum,  _point) => sum + point.x, 0);
    const sumY = data.reduce((sum,  _point) => sum + point.y, 0);
    const sumXY = data.reduce((sum,  _point) => sum + point.x * point.y, 0);
    const sumX2 = data.reduce((sum,  _point) => sum + point.x * point.x, 0);
    const sumY2 = data.reduce((sum,  _point) => sum + point.y * point.y, 0);

    const numerator = n * sumXY - sumX * sumY;
    const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));

    return denominator === 0 ? 0 : numerator / denominator;
  }

  // Placeholder methods for complex functionality
  private async generateBudgetProjectionInternal(
    budget: unknown,
    consumption: unknown,
    period: unknown
  ): Promise<BudgetProjection> {
    return {
      sloId: budget.sloId,
      sloName: budget.sloName,
      projectionPeriod: period,
      scenarios: [],
      exhaustionProbability: 0,
      recommendations: [],
      metadata: {
        generatedAt: new Date(),
        methodology: 'linear_projection',
        iterations: 100,
        confidence: 0.8,
      },
    };
  }

  private rankSLOsByBurnRate(_analyses: BurnRateAnalysis[]): unknown[] {
    return _analyses.sort((a: BurnRateAnalysis,  b: BurnRateAnalysis) => b.currentRate - a.currentRate);
  }

  private generateBurnRateInsights(_analyses: BurnRateAnalysis[]): string[] {
    return ['Burn rate insights placeholder'];
  }

  private async generateProjectionScenario(
    scenario: string,
    budget: unknown,
    burnRate: unknown,
    period: unknown
  ): Promise<unknown> {
    return {
      scenario,
      exhaustionDate: null,
      finalBudget: budget.remaining,
      confidence: 0.8,
    };
  }

  private calculateExhaustionProbability(_scenarios: unknown[]): number {
    return 0.1; // Placeholder
  }

  private generateBudgetRecommendations(
    _slo: unknown, 
    _budget: unknown, 
    _burnRate: unknown, 
    _scenarios: unknown[]
  ): string[] {
    return ['Budget recommendations placeholder'];
  }

  private generateExhaustionRecommendations(
    _sloId: string, 
    _exhaustionDate: Date | null, 
    _timeToExhaustion: number | null
  ): string[] {
    return ['Exhaustion recommendations placeholder'];
  }

  private checkBurnRateCompliance(
    _policy: unknown, 
    _analysis: unknown
  ): { compliant: boolean; details: string } {
    return { compliant: true, details: 'Compliant' };
  }

  private checkConsumptionCompliance(
    _policy: unknown, 
    _budget: unknown
  ): { compliant: boolean; details: string } {
    return { compliant: true, details: 'Compliant' };
  }

  private checkAlertCompliance(
    _policy: unknown, 
    _budget: unknown, 
    _analysis: unknown
  ): { compliant: boolean; details: string } {
    return { compliant: true, details: 'Compliant' };
  }

  private checkAutomationCompliance(
    _policy: unknown, 
    _budget: unknown, 
    _analysis: unknown
  ): { compliant: boolean; details: string } {
    return { compliant: true, details: 'Compliant' };
  }

  private identifyPolicyViolations(_policy: unknown,  _budget: unknown,  _analysis: unknown): unknown[] {
    return [];
  }

  private generatePolicyRecommendations(
    _policy: unknown, 
    _budget: unknown, 
    _analysis: unknown
  ): string[] {
    return ['Policy recommendations placeholder'];
  }

  private generateId(): string {
    return Math.random().toString(36).substr(2, 9);
  }
}

// ============================================================================
// Additional Type Definitions
// ============================================================================

export interface ErrorBudgetHistory {
  timestamp: Date;
  remaining: number;
  consumed: number;
  utilization: number;
}

export interface BurnRateDataPoint {
  timestamp: Date;
  hourlyRate: number;
  dailyRate: number;
  weeklyRate: number;
  monthlyRate: number;
  trend: BurnRateTrend;
  healthScore: number;
}

export interface BurnRateComparison {
  period: BudgetPeriod;
  sloComparisons: {
    sloId: string;
    sloName: string;
    burnRate: number;
    trend: { direction: BurnRateTrend; confidence: number; slope: number };
    health: { status: 'healthy' | 'warning' | 'critical'; score: number; factors: string[] };
  }[];
  rankings: unknown[];
  insights: string[];
  generatedAt: Date;
}

export interface ExhaustionForecast {
  sloId: string;
  earliestExhaustion: Date | null;
  timeToExhaustion: number | null;
  probabilityOfExhaustion: number;
  confidence: number;
  recommendations: string[];
  generatedAt: Date;
}

export interface PolicyComplianceResult {
  sloId: string;
  policyId: string;
  overallCompliance: boolean;
  compliance: {
    withinBurnRateLimits: { compliant: boolean; details: string };
    withinConsumptionLimits: { compliant: boolean; details: string };
    alertsTriggered: { compliant: boolean; details: string };
    automatedResponses: { compliant: boolean; details: string };
  };
  violations: unknown[];
  recommendations: string[];
  evaluatedAt: Date;
}

// Export singleton instance
export const errorBudgetService = new ErrorBudgetService(
  // Will be injected later
  null as unknown
);
