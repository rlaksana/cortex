/**
 * Security Configuration Manager
 *
 * Centralized configuration management for all security services
 * Provides environment-specific settings, validation, and hot-reload capabilities
 *
 * @author Cortex Security Team
 * @version 1.0.0
 * @since 2025-11-08
 */

import { Injectable } from '../../di/decorators.js';
import { ServiceLifetime, ServicePriority } from '../../di/enhanced-di-container.js';
import type { ILoggerService } from '../../di/service-interfaces.js';
import { AccessControlConfig } from './access-control-service.js';
import { DataSecurityConfig } from './data-security-service.js';
import { JSONSchemaValidationConfig } from './json-schema-validator.js';
import { SecurityMonitoringConfig } from './security-monitoring-service.js';
import { SecurityRuntimeConfig } from './security-runtime-service.js';

/**
 * Environment types
 */
export enum SecurityEnvironment {
  DEVELOPMENT = 'development',
  TESTING = 'testing',
  STAGING = 'staging',
  PRODUCTION = 'production',
}

/**
 * Configuration source types
 */
export enum ConfigSource {
  FILE = 'file',
  ENVIRONMENT = 'environment',
  DATABASE = 'database',
  VAULT = 'vault',
  REMOTE = 'remote',
}

/**
 * Security configuration validation result
 */
export interface ConfigValidationResult {
  valid: boolean;
  errors: Array<{
    path: string;
    message: string;
    severity: 'error' | 'warning';
  }>;
  warnings: Array<{
    path: string;
    message: string;
    recommendation?: string;
  }>;
}

/**
 * Security configuration change event
 */
export interface ConfigChangeEvent {
  service: string;
  property: string;
  oldValue: unknown;
  newValue: unknown;
  source: ConfigSource;
  timestamp: Date;
  userId?: string;
  reason?: string;
}

/**
 * Complete security configuration
 */
export interface CompleteSecurityConfig {
  environment: SecurityEnvironment;
  runtime: SecurityRuntimeConfig;
  accessControl: AccessControlConfig;
  dataSecurity: DataSecurityConfig;
  monitoring: SecurityMonitoringConfig;
  jsonSchemaValidation: JSONSchemaValidationConfig;
  version: string;
  lastUpdated: Date;
  sources: Record<string, ConfigSource>;
}

/**
 * Security Configuration Manager
 */
@Injectable({
  lifetime: ServiceLifetime.SINGLETON,
  priority: ServicePriority.CRITICAL,
  tags: ['security', 'configuration', 'management'],
})
export class SecurityConfigManager {
  private readonly logger: ILoggerService;
  private config: CompleteSecurityConfig;
  private configWatchers: Map<string, Function[]> = new Map();
  private validationSchemas: Map<string, unknown> = new Map();
  private configHistory: ConfigChangeEvent[] = [];

  constructor(_logger: ILoggerService) {
    this.logger = logger;
    this.config = this.initializeDefaultConfig();
    this.initializeValidationSchemas();
    this.loadConfiguration();
    this.startConfigWatching();
  }

  /**
   * Get complete security configuration
   */
  getConfig(): CompleteSecurityConfig {
    return { ...this.config };
  }

  /**
   * Get specific service configuration
   */
  getServiceConfig<T extends keyof CompleteSecurityConfig>(service: T): CompleteSecurityConfig[T] {
    const config = this.config[service];
    if (typeof config === 'object' && config !== null) {
      return { ...config };
    }
    return config;
  }

  /**
   * Get configuration property value
   */
  getConfigValue(_path: string): unknown {
    const parts = path.split('.');
    let current: unknown = this.config;

    for (const part of parts) {
      if (current && typeof current === 'object' && part in current) {
        current = current[part];
      } else {
        return undefined;
      }
    }

    return current;
  }

  /**
   * Update configuration property
   */
  async updateConfig(
    path: string,
    value: unknown,
    source: ConfigSource = ConfigSource.REMOTE,
    userId?: string,
    reason?: string
  ): Promise<ConfigValidationResult> {
    const oldValue = this.getConfigValue(path);

    // Validate the change
    const validationResult = await this.validateConfigChange(path, value);
    if (!validationResult.valid) {
      this.logger.error('Configuration change validation failed', {
        path,
        value,
        errors: validationResult.errors,
      });
      return validationResult;
    }

    // Apply the change
    await this.applyConfigChange(path, value);

    // Record the change
    const changeEvent: ConfigChangeEvent = {
      service: path.split('.')[0],
      property: path,
      oldValue,
      newValue: value,
      source,
      timestamp: new Date(),
      userId,
      reason,
    };

    this.configHistory.push(changeEvent);
    this.notifyConfigWatchers(path, changeEvent);

    this.logger.info('Configuration updated', {
      path,
      source,
      user_id: userId,
      reason,
    });

    return validationResult;
  }

  /**
   * Reload configuration from sources
   */
  async reloadConfiguration(): Promise<void> {
    this.logger.info('Reloading security configuration');

    try {
      const newConfig = await this.loadConfigurationFromSources();
      const validationResult = await this.validateCompleteConfig(newConfig);

      if (!validationResult.valid) {
        this.logger.error('Configuration reload validation failed', {
          errors: validationResult.errors,
        });
        throw new Error('Invalid configuration detected during reload');
      }

      this.config = { ...newConfig };
      this.notifyAllConfigWatchers();

      this.logger.info('Security configuration reloaded successfully', {
        version: this.config.version,
        environment: this.config.environment,
      });
    } catch (error) {
      this.logger.error('Failed to reload security configuration', {
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Validate current configuration
   */
  async validateCurrentConfiguration(): Promise<ConfigValidationResult> {
    return await this.validateCompleteConfig(this.config);
  }

  /**
   * Get configuration history
   */
  getConfigHistory(limit?: number): ConfigChangeEvent[] {
    const history = [...this.configHistory].sort(
      (a,  _b) => b.timestamp.getTime() - a.timestamp.getTime()
    );
    return limit ? history.slice(0, limit) : history;
  }

  /**
   * Export configuration
   */
  exportConfiguration(includeSecrets: boolean = false): string {
    const exportConfig = { ...this.config };

    if (!includeSecrets) {
      // Remove sensitive values
      this.sanitizeForExport(exportConfig);
    }

    return JSON.stringify(exportConfig, null, 2);
  }

  /**
   * Import configuration
   */
  async importConfiguration(
    configJson: string,
    source: ConfigSource = ConfigSource.FILE,
    userId?: string
  ): Promise<ConfigValidationResult> {
    try {
      const importedConfig = JSON.parse(configJson);

      // Validate imported config
      const validationResult = await this.validateCompleteConfig(importedConfig);
      if (!validationResult.valid) {
        return validationResult;
      }

      // Apply imported config
      this.config = { ...importedConfig };
      this.config.lastUpdated = new Date();

      // Record import event
      const changeEvent: ConfigChangeEvent = {
        service: 'all',
        property: 'import',
        oldValue: this.config,
        newValue: importedConfig,
        source,
        timestamp: new Date(),
        userId,
        reason: 'Configuration imported',
      };

      this.configHistory.push(changeEvent);
      this.notifyAllConfigWatchers();

      this.logger.info('Security configuration imported', {
        source,
        user_id: userId,
        version: this.config.version,
      });

      return validationResult;
    } catch (error) {
      this.logger.error('Failed to import configuration', {
        error: error instanceof Error ? error.message : String(error),
      });

      return {
        valid: false,
        errors: [
          {
            path: 'root',
            message: 'Invalid JSON format',
            severity: 'error',
          },
        ],
        warnings: [],
      };
    }
  }

  /**
   * Watch for configuration changes
   */
  watchConfig(_path: string,  _callback: (change: ConfigChangeEvent) => void): () => void {
    if (!this.configWatchers.has(path)) {
      this.configWatchers.set(path, []);
    }

    const watchers = this.configWatchers.get(path)!;
    watchers.push(callback);

    // Return unsubscribe function
    return () => {
      const index = watchers.indexOf(callback);
      if (index >= 0) {
        watchers.splice(index, 1);
      }
    };
  }

  /**
   * Get environment-specific default configuration
   */
  private initializeDefaultConfig(): CompleteSecurityConfig {
    const environment = this.detectEnvironment();

    return {
      environment,
      runtime: this.getDefaultRuntimeConfig(environment),
      accessControl: this.getDefaultAccessControlConfig(environment),
      dataSecurity: this.getDefaultDataSecurityConfig(environment),
      monitoring: this.getDefaultMonitoringConfig(environment),
      jsonSchemaValidation: this.getDefaultJSONSchemaValidationConfig(environment),
      version: '1.0.0',
      lastUpdated: new Date(),
      sources: {
        runtime: ConfigSource.FILE,
        accessControl: ConfigSource.FILE,
        dataSecurity: ConfigSource.FILE,
        monitoring: ConfigSource.FILE,
        jsonSchemaValidation: ConfigSource.FILE,
      },
    };
  }

  /**
   * Get default runtime configuration for environment
   */
  private getDefaultRuntimeConfig(_environment: SecurityEnvironment): SecurityRuntimeConfig {
    const baseConfig = {
      enabled: true,
      strict_mode: false,
      fail_closed: false,
      max_input_size: 1000000,
      validation_timeout_ms: 5000,
      deep_validation_enabled: true,
      role_based_access: true,
      attribute_based_access: true,
      session_validation: true,
      pii_detection_enabled: true,
      data_masking_enabled: true,
      secret_detection_enabled: true,
      anomaly_detection: true,
      behavior_analysis: true,
      threat_intelligence: true,
      rate_limiting_enabled: true,
      adaptive_rate_limiting: false,
      auto_block_enabled: false,
      alert_threshold_violations: 5,
      quarantine_duration_minutes: 60,
    };

    switch (_environment) {
      case SecurityEnvironment.DEVELOPMENT:
        return {
          ...baseConfig,
          strict_mode: false,
          fail_closed: false,
          auto_block_enabled: false,
          alert_threshold_violations: 20,
        };

      case SecurityEnvironment.TESTING:
        return {
          ...baseConfig,
          strict_mode: true,
          fail_closed: false,
          auto_block_enabled: false,
          anomaly_detection: false,
        };

      case SecurityEnvironment.STAGING:
        return {
          ...baseConfig,
          strict_mode: true,
          fail_closed: true,
          auto_block_enabled: true,
          alert_threshold_violations: 3,
        };

      case SecurityEnvironment.PRODUCTION:
        return {
          ...baseConfig,
          strict_mode: true,
          fail_closed: true,
          auto_block_enabled: true,
          adaptive_rate_limiting: true,
          alert_threshold_violations: 2,
          quarantine_duration_minutes: 120,
        };

      default:
        return baseConfig;
    }
  }

  /**
   * Get default access control configuration for environment
   */
  private getDefaultAccessControlConfig(_environment: SecurityEnvironment): AccessControlConfig {
    const baseConfig = {
      enabled: true,
      rbac_enabled: true,
      abac_enabled: true,
      session_validation: true,
      multi_factor_auth: false,
      cache_permissions: true,
      cache_ttl_seconds: 300,
      fail_closed: false,
      audit_access: true,
      ip_whitelist_enabled: false,
      time_based_access: false,
      geo_fencing_enabled: false,
    };

    switch (_environment) {
      case SecurityEnvironment.DEVELOPMENT:
        return {
          ...baseConfig,
          rbac_enabled: false,
          abac_enabled: false,
          multi_factor_auth: false,
          ip_whitelist_enabled: false,
        };

      case SecurityEnvironment.PRODUCTION:
        return {
          ...baseConfig,
          multi_factor_auth: true,
          fail_closed: true,
          ip_whitelist_enabled: true,
          geo_fencing_enabled: true,
        };

      default:
        return baseConfig;
    }
  }

  /**
   * Get default data security configuration for environment
   */
  private getDefaultDataSecurityConfig(_environment: SecurityEnvironment): DataSecurityConfig {
    const baseConfig = {
      enabled: true,
      pii_detection_enabled: true,
      pii_masking_enabled: true,
      secret_detection_enabled: true,
      data_classification_enabled: true,
      encryption_at_rest_enabled: true,
      audit_data_access: true,
      quarantine_sensitive_data: true,
      data_retention_enabled: true,
      gdpr_compliance_enabled: false,
      hipaa_compliance_enabled: false,
      pci_compliance_enabled: false,
    };

    switch (_environment) {
      case SecurityEnvironment.PRODUCTION:
        return {
          ...baseConfig,
          gdpr_compliance_enabled: true,
          quarantine_sensitive_data: true,
        };

      default:
        return baseConfig;
    }
  }

  /**
   * Get default monitoring configuration for environment
   */
  private getDefaultMonitoringConfig(_environment: SecurityEnvironment): SecurityMonitoringConfig {
    const baseConfig = {
      enabled: true,
      anomaly_detection: true,
      behavior_analysis: true,
      threat_intelligence: true,
      real_time_alerts: true,
      automated_response: false,
      learning_enabled: true,
      retention_days: 90,
      alert_thresholds: {
        violation_count_per_minute: 10,
        failed_auth_per_minute: 5,
        data_access_anomaly_score: 0.7,
        behavioral_anomaly_score: 0.8,
      },
      response_actions: {
        auto_block_ip: false,
        auto_block_user: false,
        auto_quarantine_session: false,
        require_mfa: false,
        escalate_to_admin: true,
      },
    };

    switch (_environment) {
      case SecurityEnvironment.PRODUCTION:
        return {
          ...baseConfig,
          automated_response: true,
          retention_days: 365,
          response_actions: {
            auto_block_ip: true,
            auto_block_user: false,
            auto_quarantine_session: true,
            require_mfa: true,
            escalate_to_admin: true,
          },
        };

      default:
        return baseConfig;
    }
  }

  /**
   * Get default JSON schema validation configuration for environment
   */
  private getDefaultJSONSchemaValidationConfig(
    _environment: SecurityEnvironment
  ): JSONSchemaValidationConfig {
    const baseConfig = {
      enabled: true,
      strict_mode: false,
      validation_timeout_ms: 1000,
      max_schema_depth: 10,
      max_array_length: 1000,
      max_string_length: 10000,
      max_object_properties: 100,
      custom_validators_enabled: true,
      security_constraints_enabled: true,
    };

    switch (_environment) {
      case SecurityEnvironment.PRODUCTION:
        return {
          ...baseConfig,
          strict_mode: true,
          validation_timeout_ms: 500,
          max_array_length: 500,
          max_string_length: 5000,
          max_object_properties: 50,
        };

      default:
        return baseConfig;
    }
  }

  /**
   * Detect current environment
   */
  private detectEnvironment(): SecurityEnvironment {
    const nodeEnv = process.env.NODE_ENV?.toLowerCase();
    const cortexEnv = process.env.CORTEX_ENV?.toLowerCase();

    if (_cortexEnv) {
      switch (_cortexEnv) {
        case 'dev':
        case 'development':
          return SecurityEnvironment.DEVELOPMENT;
        case 'test':
        case 'testing':
          return SecurityEnvironment.TESTING;
        case 'stage':
        case 'staging':
          return SecurityEnvironment.STAGING;
        case 'prod':
        case 'production':
          return SecurityEnvironment.PRODUCTION;
      }
    }

    if (_nodeEnv) {
      switch (_nodeEnv) {
        case 'development':
          return SecurityEnvironment.DEVELOPMENT;
        case 'test':
          return SecurityEnvironment.TESTING;
        case 'production':
          return SecurityEnvironment.PRODUCTION;
      }
    }

    return SecurityEnvironment.DEVELOPMENT;
  }

  /**
   * Initialize validation schemas
   */
  private initializeValidationSchemas(): void {
    // Runtime config schema
    this.validationSchemas.set('runtime', {
      type: 'object',
      required: ['enabled'],
      properties: {
        enabled: { type: 'boolean' },
        strict_mode: { type: 'boolean' },
        fail_closed: { type: 'boolean' },
        max_input_size: { type: 'number', minimum: 1000, maximum: 10000000 },
        validation_timeout_ms: { type: 'number', minimum: 100, maximum: 30000 },
      },
    });

    // Access control config schema
    this.validationSchemas.set('accessControl', {
      type: 'object',
      required: ['enabled'],
      properties: {
        enabled: { type: 'boolean' },
        rbac_enabled: { type: 'boolean' },
        abac_enabled: { type: 'boolean' },
        cache_ttl_seconds: { type: 'number', minimum: 60, maximum: 3600 },
      },
    });
  }

  /**
   * Load configuration from sources
   */
  private async loadConfiguration(): Promise<void> {
    try {
      this.config = await this.loadConfigurationFromSources();
      this.logger.info('Security configuration loaded', {
        environment: this.config.environment,
        version: this.config.version,
      });
    } catch (error) {
      this.logger.error('Failed to load security configuration, using defaults', {
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }

  /**
   * Load configuration from various sources
   */
  private async loadConfigurationFromSources(): Promise<CompleteSecurityConfig> {
    const config = { ...this.config };

    // Load from environment variables
    await this.loadFromEnvironment(config);

    // Load from config files
    await this.loadFromFiles(config);

    // Load from database if available
    await this.loadFromDatabase(config);

    // Load from vault if available
    await this.loadFromVault(config);

    return config;
  }

  /**
   * Load configuration from environment variables
   */
  private async loadFromEnvironment(config: CompleteSecurityConfig): Promise<void> {
    // Runtime config
    if (process.env.SECURITY_ENABLED !== undefined) {
      config.runtime.enabled = process.env.SECURITY_ENABLED === 'true';
    }

    if (process.env.SECURITY_STRICT_MODE !== undefined) {
      config.runtime.strict_mode = process.env.SECURITY_STRICT_MODE === 'true';
    }

    if (process.env.SECURITY_FAIL_CLOSED !== undefined) {
      config.runtime.fail_closed = process.env.SECURITY_FAIL_CLOSED === 'true';
    }

    // Access control config
    if (process.env.RBAC_ENABLED !== undefined) {
      config.accessControl.rbac_enabled = process.env.RBAC_ENABLED === 'true';
    }

    if (process.env.MFA_REQUIRED !== undefined) {
      config.accessControl.multi_factor_auth = process.env.MFA_REQUIRED === 'true';
    }

    // Data security config
    if (process.env.PII_DETECTION_ENABLED !== undefined) {
      config.dataSecurity.pii_detection_enabled = process.env.PII_DETECTION_ENABLED === 'true';
    }

    if (process.env.ENCRYPTION_AT_REST !== undefined) {
      config.dataSecurity.encryption_at_rest_enabled = process.env.ENCRYPTION_AT_REST === 'true';
    }
  }

  /**
   * Load configuration from files
   */
  private async loadFromFiles(config: CompleteSecurityConfig): Promise<void> {
    // This would load from config files like security.json, security.prod.json, etc.
    // For now, we'll use the defaults
  }

  /**
   * Load configuration from database
   */
  private async loadFromDatabase(config: CompleteSecurityConfig): Promise<void> {
    // This would load configuration from a database
    // For now, we'll use the defaults
  }

  /**
   * Load configuration from vault
   */
  private async loadFromVault(config: CompleteSecurityConfig): Promise<void> {
    // This would load secrets and sensitive config from a vault
    // For now, we'll use the defaults
  }

  /**
   * Validate complete configuration
   */
  private async validateCompleteConfig(
    config: CompleteSecurityConfig
  ): Promise<ConfigValidationResult> {
    const errors: Array<{ path: string; message: string; severity: 'error' | 'warning' }> = [];
    const warnings: Array<{ path: string; message: string; recommendation?: string }> = [];

    // Validate each service configuration
    for (const [serviceName,  schema] of this.validationSchemas) {
      const serviceConfig = config[serviceName as keyof CompleteSecurityConfig];
      if (_serviceConfig) {
        const validation = this.validateWithSchema(serviceConfig, schema, serviceName);
        errors.push(...validation.errors);
        warnings.push(...validation.warnings);
      }
    }

    // Cross-service validation
    this.validateCrossServiceDependencies(config, errors, warnings);

    return {
      valid: errors.length === 0,
      errors,
      warnings,
    };
  }

  /**
   * Validate configuration with JSON schema
   */
  private validateWithSchema(
    config: unknown, 
    _schema: unknown, 
    serviceName: string
  ): { errors: unknown[]; warnings: unknown[] } {
    const errors: unknown[] = [];
    const warnings: unknown[] = [];

    // Simple validation implementation
    // In production, use a proper JSON schema validator
    if (schema.required) {
      for (const required of schema.required) {
        if (!(required in config)) {
          errors.push({
            path: `${serviceName}.${required}`,
            message: `Required property missing: ${required}`,
            severity: 'error',
          });
        }
      }
    }

    if (schema.properties) {
      // Define interface for property schema
      interface PropertySchema {
        type?: string;
        minimum?: number;
        maximum?: number;
        minLength?: number;
        maxLength?: number;
        enum?: unknown[];
        pattern?: string;
        required?: boolean;
        [key: string]: unknown;
      }

      for (const [prop, propSchema] of Object.entries(
        schema.properties as Record<string, PropertySchema>
      )) {
        const schema = propSchema;
        if (prop in config) {
          const value = config[prop];
          const propType = typeof value;
          const schemaType = schema.type;

          if (schemaType && schemaType !== propType) {
            errors.push({
              path: `${serviceName}.${prop}`,
              message: `Invalid type for ${prop}: expected ${schemaType}, got ${propType}`,
              severity: 'error',
            });
          }

          // Validate constraints
          if (schema.minimum && typeof value === 'number' && value < schema.minimum) {
            errors.push({
              path: `${serviceName}.${prop}`,
              message: `Value ${value} is below minimum ${schema.minimum}`,
              severity: 'error',
            });
          }

          if (schema.maximum && typeof value === 'number' && value > schema.maximum) {
            errors.push({
              path: `${serviceName}.${prop}`,
              message: `Value ${value} is above maximum ${schema.maximum}`,
              severity: 'error',
            });
          }
        }
      }
    }

    return { errors, warnings };
  }

  /**
   * Validate cross-service dependencies
   */
  private validateCrossServiceDependencies(
    config: CompleteSecurityConfig, 
    _errors: unknown[], 
    _warnings: unknown[]
  ): void {
    // If strict mode is enabled, security must be enabled
    if (config.runtime.strict_mode && !config.runtime.enabled) {
      errors.push({
        path: 'runtime.strict_mode',
        message: 'Strict mode requires security to be enabled',
        severity: 'error',
      });
    }

    // If MFA is required, session validation must be enabled
    if (config.accessControl.multi_factor_auth && !config.accessControl.session_validation) {
      errors.push({
        path: 'accessControl.multi_factor_auth',
        message: 'MFA requires session validation to be enabled',
        severity: 'error',
      });
    }

    // Warning: automated response without monitoring
    if (config.monitoring.automated_response && !config.monitoring.enabled) {
      warnings.push({
        path: 'monitoring.automated_response',
        message: 'Automated response enabled but monitoring is disabled',
        recommendation: 'Enable monitoring or disable automated response',
      });
    }
  }

  /**
   * Validate config change
   */
  private async validateConfigChange(
    path: string,
    value: unknown
  ): Promise<ConfigValidationResult> {
    const tempConfig = { ...this.config };
    this.setNestedProperty(tempConfig, path, value);
    return await this.validateCompleteConfig(tempConfig);
  }

  /**
   * Apply configuration change
   */
  private async applyConfigChange(path: string, value: unknown): Promise<void> {
    this.setNestedProperty(this.config, path, value);
    this.config.lastUpdated = new Date();
  }

  /**
   * Set nested property
   */
  private setNestedProperty(_obj: unknown,  _path: string,  _value: unknown): void {
    const parts = path.split('.');
    let current = obj;

    for (let i = 0; i < parts.length - 1; i++) {
      const part = parts[i];
      if (!(part in current) || typeof current[part] !== 'object') {
        current[part] = {};
      }
      current = current[part];
    }

    current[parts[parts.length - 1]] = value;
  }

  /**
   * Sanitize configuration for export
   */
  private sanitizeForExport(config: unknown): void {
    // Remove sensitive values
    if (config.runtime) {
      delete config.runtime.encryption_keys;
      delete config.runtime.secrets;
    }

    if (config.accessControl) {
      delete config.accessControl.jwt_secrets;
      delete config.accessControl.api_keys;
    }

    if (config.dataSecurity) {
      delete config.dataSecurity.encryption_keys;
      delete config.dataSecurity.master_keys;
    }
  }

  /**
   * Notify configuration watchers
   */
  private notifyConfigWatchers(_path: string,  _change: ConfigChangeEvent): void {
    // Notify exact path watchers
    const exactWatchers = this.configWatchers.get(path);
    if (_exactWatchers) {
      exactWatchers.forEach((callback) => {
        try {
          callback(change);
        } catch (error) {
          this.logger.error('Config watcher error', {
            path,
            error: error instanceof Error ? error.message : String(error),
          });
        }
      });
    }

    // Notify parent path watchers
    const pathParts = path.split('.');
    for (let i = pathParts.length - 1; i > 0; i--) {
      const parentPath = pathParts.slice(0, i).join('.');
      const parentWatchers = this.configWatchers.get(parentPath);
      if (_parentWatchers) {
        parentWatchers.forEach((callback) => {
          try {
            callback(change);
          } catch (error) {
            this.logger.error('Parent config watcher error', {
              parentPath,
              error: error instanceof Error ? error.message : String(error),
            });
          }
        });
      }
    }
  }

  /**
   * Notify all configuration watchers
   */
  private notifyAllConfigWatchers(): void {
    const change: ConfigChangeEvent = {
      service: 'all',
      property: 'reload',
      oldValue: null,
      newValue: this.config,
      source: ConfigSource.FILE,
      timestamp: new Date(),
      reason: 'Configuration reloaded',
    };

    for (const [path,  watchers] of this.configWatchers) {
      watchers.forEach((callback) => {
        try {
          callback(change);
        } catch (error) {
          this.logger.error('Config watcher error during reload', {
            path,
            error: error instanceof Error ? error.message : String(error),
          });
        }
      });
    }
  }

  /**
   * Start configuration watching
   */
  private startConfigWatching(): void {
    // This would watch for file changes, database changes, etc.
    // For now, we'll just log that watching has started
    this.logger.debug('Security configuration watching started');
  }
}

// Re-export imported types for external use
export type {
  SecurityRuntimeConfig,
  AccessControlConfig,
  DataSecurityConfig,
  SecurityMonitoringConfig,
  JSONSchemaValidationConfig,
};

// Export locally defined types
// CompleteSecurityConfig is already exported above
