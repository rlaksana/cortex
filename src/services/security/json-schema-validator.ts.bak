/**
 * JSON Schema Validation Service
 *
 * Advanced JSON schema validation for security runtime checks
 * Provides comprehensive validation with custom security rules and constraints
 *
 * @author Cortex Security Team
 * @version 1.0.0
 * @since 2025-11-08
 */

import { z } from 'zod';
import { Injectable } from '../../di/decorators.js';
import { ServiceLifetime, ServicePriority } from '../../di/enhanced-di-container.js';
import type { ILoggerService } from '../../di/service-interfaces.js';
import { SecurityViolation } from './security-types.js';

/**
 * JSON Schema validation configuration
 */
export interface JSONSchemaValidationConfig {
  enabled: boolean;
  strict_mode: boolean;
  validation_timeout_ms: number;
  max_schema_depth: number;
  max_array_length: number;
  max_string_length: number;
  max_object_properties: number;
  custom_validators_enabled: boolean;
  security_constraints_enabled: boolean;
}

/**
 * Schema validation result
 */
export interface SchemaValidationResult {
  valid: boolean;
  errors: Array<{
    path: string;
    message: string;
    code: string;
    severity: 'error' | 'warning';
  }>;
  sanitized?: unknown;
  metadata?: Record<string, unknown>;
}

/**
 * Custom security constraints
 */
export interface SecurityConstraint {
  name: string;
  description: string;
  validator: (value: unknown, path: string) => SecurityViolation | null;
  enabled: boolean;
  priority: number;
}

/**
 * JSON Schema Validator Service
 */
@Injectable({
  lifetime: ServiceLifetime.SINGLETON,
  priority: ServicePriority.HIGH,
  tags: ['security', 'validation', 'schema', 'json'],
})
export class JSONSchemaValidatorService {
  private readonly logger: ILoggerService;
  private readonly config: JSONSchemaValidationConfig;
  private readonly schemas: Map<string, z.ZodSchema> = new Map();
  private readonly securityConstraints: Map<string, SecurityConstraint> = new Map();

  constructor(_logger: ILoggerService,  config: JSONSchemaValidationConfig) {
    this.logger = logger;
    this.config = config;
    this.initializeDefaultSchemas();
    this.initializeSecurityConstraints();
  }

  /**
   * Validate data against JSON schema with security constraints
   */
  async validate(
    data: unknown,
    schemaName: string,
    context: Record<string, unknown> = {}
  ): Promise<SchemaValidationResult> {
    if (!this.config.enabled) {
      return {
        valid: true,
        errors: [],
        metadata: { validation_disabled: true },
      };
    }

    const startTime = Date.now();
    const errors: Array<{
      path: string;
      message: string;
      code: string;
      severity: 'error' | 'warning';
    }> = [];

    try {
      // Get schema
      const schema = this.schemas.get(schemaName);
      if (!schema) {
        return {
          valid: !this.config.strict_mode,
          errors: [
            {
              path: 'schema',
              message: `Schema '${schemaName}' not found`,
              code: 'SCHEMA_NOT_FOUND',
              severity: 'error',
            },
          ],
          metadata: { schema_name: schemaName },
        };
      }

      // Validate schema structure first
      const structureValidation = this.validateStructure(data, schemaName);
      if (!structureValidation.valid) {
        errors.push(...structureValidation.errors);
      }

      // Zod validation
      const zodResult = schema.safeParse(data);
      if (!zodResult.success) {
        for (const issue of zodResult.error.issues) {
          errors.push({
            path: issue.path.join('.'),
            message: issue.message,
            code: issue.code,
            severity: 'error',
          });
        }
      } else {
        data = zodResult.data;
      }

      // Apply security constraints
      if (this.config.security_constraints_enabled) {
        const constraintViolations = await this.applySecurityConstraints(data, context);
        for (const violation of constraintViolations) {
          errors.push({
            path: violation.evidence?.path || 'unknown',
            message: violation.description,
            code: violation.type,
            severity:
              violation.severity === 'critical' || violation.severity === 'high'
                ? 'error'
                : 'warning',
          });
        }
      }

      // Sanitize data if validation passed
      let sanitized = data;
      if (errors.length === 0) {
        sanitized = await this.sanitizeData(data, schemaName);
      }

      return {
        valid: errors.length === 0 || !this.config.strict_mode,
        errors,
        sanitized: errors.length === 0 ? sanitized : undefined,
        metadata: {
          schema_name: schemaName,
          processing_time_ms: Date.now() - startTime,
          constraints_applied: this.config.security_constraints_enabled,
          custom_validators: this.config.custom_validators_enabled,
        },
      };
    } catch (error) {
      this.logger.error('JSON schema validation failed', {
        schemaName,
        error: error instanceof Error ? error.message : String(error),
        processing_time_ms: Date.now() - startTime,
      });

      return {
        valid: !this.config.strict_mode,
        errors: [
          {
            path: 'system',
            message: 'Validation system error',
            code: 'SYSTEM_ERROR',
            severity: 'error',
          },
        ],
        metadata: {
          error: error instanceof Error ? error.message : String(error),
          processing_time_ms: Date.now() - startTime,
        },
      };
    }
  }

  /**
   * Register a new schema
   */
  registerSchema(_name: string,  _schema: z.ZodSchema): void {
    this.schemas.set(name, schema);
    this.logger.debug('Schema registered', { name });
  }

  /**
   * Register a security constraint
   */
  registerSecurityConstraint(_constraint: SecurityConstraint): void {
    this.securityConstraints.set(constraint.name, constraint);
    this.logger.debug('Security constraint registered', { name: constraint.name });
  }

  /**
   * Validate data structure for security
   */
  private validateStructure(data: unknown,  _schemaName: string): SchemaValidationResult {
    const errors: Array<{
      path: string;
      message: string;
      code: string;
      severity: 'error' | 'warning';
    }> = [];

    // Check maximum depth
    const depth = this.calculateDepth(data);
    if (depth > this.config.max_schema_depth) {
      errors.push({
        path: 'root',
        message: `Data depth ${depth} exceeds maximum ${this.config.max_schema_depth}`,
        code: 'MAX_DEPTH_EXCEEDED',
        severity: 'error',
      });
    }

    // Check array lengths
    const arrayCheck = this.checkArrayLengths(data);
    errors.push(...arrayCheck);

    // Check string lengths
    const stringCheck = this.checkStringLengths(data);
    errors.push(...stringCheck);

    // Check object property counts
    const objectCheck = this.checkObjectProperties(data);
    errors.push(...objectCheck);

    // Check for circular references
    if (this.hasCircularReference(data)) {
      errors.push({
        path: 'root',
        message: 'Circular reference detected',
        code: 'CIRCULAR_REFERENCE',
        severity: 'error',
      });
    }

    return {
      valid: errors.length === 0,
      errors,
      metadata: {
        depth,
        schema_name: schemaName,
      },
    };
  }

  /**
   * Apply security constraints to data
   */
  private async applySecurityConstraints(
    data: unknown,
    context: Record<string, unknown>
  ): Promise<SecurityViolation[]> {
    const violations: SecurityViolation[] = [];

    for (const constraint of this.securityConstraints.values()) {
      if (!constraint.enabled) continue;

      try {
        const violation = await this.applyConstraint(data, constraint, context);
        if (_violation) {
          violations.push(violation);
        }
      } catch (error) {
        this.logger.error('Security constraint failed', {
          constraint: constraint.name,
          error: error instanceof Error ? error.message : String(error),
        });
      }
    }

    // Sort by priority
    return violations.sort((a,  _b) => {
      const aPriority = a.evidence?.priority || 0;
      const bPriority = b.evidence?.priority || 0;
      return bPriority - aPriority;
    });
  }

  /**
   * Apply individual security constraint
   */
  private async applyConstraint(
    data: unknown,
    constraint: SecurityConstraint,
    context: Record<string, unknown>
  ): Promise<SecurityViolation | null> {
    const startTime = Date.now();

    // Timeout handling
    const timeoutPromise = new Promise<SecurityViolation>((_, reject) => {
      setTimeout(
        () => { reject(new Error('Constraint validation timeout')); },
        this.config.validation_timeout_ms
      );
    });

    const validationPromise = Promise.resolve(constraint.validator(data, ''));

    try {
      const violation = await Promise.race([validationPromise, timeoutPromise]);
      return violation;
    } catch (error) {
      this.logger.warn('Constraint validation failed', {
        constraint: constraint.name,
        error: error instanceof Error ? error.message : String(error),
        duration_ms: Date.now() - startTime,
      });
      return null;
    }
  }

  /**
   * Sanitize data according to security rules
   */
  private async sanitizeData(data: unknown, schemaName: string): Promise<unknown> {
    // Deep clone to avoid mutating original
    const sanitized = JSON.parse(JSON.stringify(data));

    // Remove potential security issues
    return this.removeSecurityIssues(sanitized);
  }

  /**
   * Remove security issues from data
   */
  private removeSecurityIssues(_obj: unknown,  path: string = ''): unknown {
    if (typeof obj === 'string') {
      // Remove script tags and dangerous content
      let sanitized = obj
        .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '[SCRIPT_REMOVED]')
        .replace(/javascript:/gi, 'javascript_removed:')
        .replace(/on\w+\s*=/gi, 'on_event_removed=');

      // Limit string length
      if (sanitized.length > this.config.max_string_length) {
        sanitized = sanitized.substring(0, this.config.max_string_length) + '...[TRUNCATED]';
      }

      return sanitized;
    }

    if (Array.isArray(obj)) {
      // Limit array length
      if (obj.length > this.config.max_array_length) {
        return obj.slice(0, this.config.max_array_length);
      }

      return obj.map((item,  _index) => this.removeSecurityIssues(item, `${path}[${index}]`));
    }

    if (typeof obj === 'object' && obj !== null) {
      // Limit object properties
      const keys = Object.keys(obj);
      if (keys.length > this.config.max_object_properties) {
        const sanitized: unknown = {};
        for (let i = 0; i < this.config.max_object_properties; i++) {
          const key = keys[i];
          sanitized[key] = this.removeSecurityIssues(obj[key], `${path}.${key}`);
        }
        return sanitized;
      }

      const sanitized: unknown = {};
      for (const key of keys) {
        // Remove dangerous property names
        if (!this.isDangerousPropertyName(key)) {
          sanitized[key] = this.removeSecurityIssues(obj[key], `${path}.${key}`);
        }
      }
      return sanitized;
    }

    return obj;
  }

  /**
   * Check if property name is dangerous
   */
  private isDangerousPropertyName(_name: string): boolean {
    const dangerousNames = [
      '__proto__',
      'constructor',
      'prototype',
      'eval',
      'Function',
      'process',
      'require',
      'global',
    ];

    return dangerousNames.includes(name);
  }

  /**
   * Calculate data depth
   */
  private calculateDepth(_obj: unknown,  currentDepth: number = 0): number {
    if (typeof obj !== 'object' || obj === null) {
      return currentDepth;
    }

    let maxDepth = currentDepth;
    for (const value of Object.values(obj)) {
      if (typeof value === 'object' && value !== null) {
        const depth = this.calculateDepth(value, currentDepth + 1);
        maxDepth = Math.max(maxDepth, depth);
      }
    }

    return maxDepth;
  }

  /**
   * Check array lengths
   */
  private checkArrayLengths(
    _obj: unknown, 
    path: string = ''
  ): Array<{ path: string; message: string; code: string; severity: 'error' | 'warning' }> {
    const errors: Array<{
      path: string;
      message: string;
      code: string;
      severity: 'error' | 'warning';
    }> = [];

    if (Array.isArray(obj)) {
      if (obj.length > this.config.max_array_length) {
        errors.push({
          path,
          message: `Array length ${String(obj?.length ?? 0)} exceeds maximum ${this.config.max_array_length}`,
          code: 'ARRAY_TOO_LONG',
          severity: 'error',
        });
      }

      for (let i = 0; i < obj.length; i++) {
        errors.push(...this.checkArrayLengths(obj[i], `${path}[${i}]`));
      }
    } else if (typeof obj === 'object' && obj !== null) {
      for (const [key, value] of Object.entries(obj)) {
        errors.push(...this.checkArrayLengths(value, `${path}.${key}`));
      }
    }

    return errors;
  }

  /**
   * Check string lengths
   */
  private checkStringLengths(
    _obj: unknown, 
    path: string = ''
  ): Array<{ path: string; message: string; code: string; severity: 'error' | 'warning' }> {
    const errors: Array<{
      path: string;
      message: string;
      code: string;
      severity: 'error' | 'warning';
    }> = [];

    if (typeof obj === 'string') {
      if (obj.length > this.config.max_string_length) {
        errors.push({
          path,
          message: `String length ${String(obj?.length ?? 0)} exceeds maximum ${this.config.max_string_length}`,
          code: 'STRING_TOO_LONG',
          severity: 'error',
        });
      }
    } else if (typeof obj === 'object' && obj !== null) {
      for (const [key, value] of Object.entries(obj)) {
        errors.push(...this.checkStringLengths(value, `${path}.${key}`));
      }
    }

    return errors;
  }

  /**
   * Check object property counts
   */
  private checkObjectProperties(
    _obj: unknown, 
    path: string = ''
  ): Array<{ path: string; message: string; code: string; severity: 'error' | 'warning' }> {
    const errors: Array<{
      path: string;
      message: string;
      code: string;
      severity: 'error' | 'warning';
    }> = [];

    if (typeof obj === 'object' && obj !== null && !Array.isArray(obj)) {
      const keys = Object.keys(obj);
      if (keys.length > this.config.max_object_properties) {
        errors.push({
          path,
          message: `Object has ${String(keys?.length ?? 0)} properties, maximum ${this.config.max_object_properties}`,
          code: 'TOO_MANY_PROPERTIES',
          severity: 'error',
        });
      }

      for (const [key, value] of Object.entries(obj)) {
        errors.push(...this.checkObjectProperties(value, `${path}.${key}`));
      }
    }

    return errors;
  }

  /**
   * Check for circular references
   */
  private hasCircularReference(obj: unknown, seen: Set<unknown> = new Set()): boolean {
    if (typeof obj !== 'object' || obj === null) {
      return false;
    }

    if (seen.has(obj)) {
      return true;
    }

    seen.add(obj);

    for (const value of Object.values(obj)) {
      if (this.hasCircularReference(value, seen)) {
        return true;
      }
    }

    return false;
  }

  /**
   * Initialize default schemas
   */
  private initializeDefaultSchemas(): void {
    // Memory store schema
    this.schemas.set(
      'memory_store',
      z.object({
        items: z.array(z.any()).optional(),
        content: z.string().min(1).max(1000000),
        kind: z.enum([
          'entity',
          'relation',
          'observation',
          'section',
          'runbook',
          'change',
          'issue',
          'decision',
          'todo',
          'release_note',
          'ddl',
          'pr_context',
          'incident',
          'release',
          'risk',
          'assumption',
        ]),
        scope: z
          .object({
            project: z.string().optional(),
            branch: z.string().optional(),
            organization: z.string().optional(),
            tenant: z.string().optional(),
          })
          .optional(),
      })
    );

    // Memory find schema
    this.schemas.set(
      'memory_find',
      z.object({
        query: z.string().min(1).max(1000),
        limit: z.number().min(1).max(1000).optional(),
        offset: z.number().min(0).max(10000).optional(),
        scope: z
          .object({
            project: z.string().optional(),
            branch: z.string().optional(),
            organization: z.string().optional(),
            tenant: z.string().optional(),
          })
          .optional(),
        types: z.array(z.string()).optional(),
      })
    );

    // Generic request schema
    this.schemas.set(
      'generic_request',
      z.object({
        operation: z.string().optional(),
        parameters: z.record(z.any()).optional(),
        metadata: z.record(z.any()).optional(),
      })
    );
  }

  /**
   * Initialize security constraints
   */
  private initializeSecurityConstraints(): void {
    // No SQL injection constraint
    this.registerSecurityConstraint({
      name: 'no_sql_injection', 
      _description: 'Prevent SQL injection attempts', 
      _validator: (value,  _path) => {
        const sqlPatterns = [
          /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION)\b)/gi,
          /(--|;|\/\*|\*\/|xp_|sp_)/gi,
        ];

        if (typeof value === 'string') {
          for (const pattern of sqlPatterns) {
            if (pattern.test(value)) {
              return {
                type: 'sql_injection',
                severity: 'high',
                description: `SQL injection pattern detected at ${path}`,
                recommendation: 'Remove SQL keywords and special characters',
                evidence: { path, pattern: pattern.source },
              };
            }
          }
        }
        return null;
      },
      enabled: true,
      priority: 10,
    });

    // No XSS constraint
    this.registerSecurityConstraint({
      name: 'no_xss', 
      _description: 'Prevent XSS attacks', 
      _validator: (value,  _path) => {
        const xssPatterns = [
          /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
          /javascript:/gi,
          /on\w+\s*=/gi,
        ];

        if (typeof value === 'string') {
          for (const pattern of xssPatterns) {
            if (pattern.test(value)) {
              return {
                type: 'xss_attempt',
                severity: 'high',
                description: `XSS pattern detected at ${path}`,
                recommendation: 'Remove HTML/JavaScript content',
                evidence: { path, pattern: pattern.source },
              };
            }
          }
        }
        return null;
      },
      enabled: true,
      priority: 10,
    });

    // No path traversal constraint
    this.registerSecurityConstraint({
      name: 'no_path_traversal', 
      _description: 'Prevent path traversal attacks', 
      _validator: (value,  _path) => {
        const pathTraversalPatterns = [/\.\.[\/\\]/g, /[\/\\]\.\.[\/\\]/g];

        if (typeof value === 'string') {
          for (const pattern of pathTraversalPatterns) {
            if (pattern.test(value)) {
              return {
                type: 'path_traversal',
                severity: 'high',
                description: `Path traversal pattern detected at ${path}`,
                recommendation: 'Remove directory traversal patterns',
                evidence: { path, pattern: pattern.source },
              };
            }
          }
        }
        return null;
      },
      enabled: true,
      priority: 10,
    });
  }
}
