/**
 * Data Security Service
 *
 * Comprehensive data protection with PII detection, masking, and secret detection
 * Ensures sensitive data is properly handled and protected throughout the system
 *
 * @author Cortex Security Team
 * @version 1.0.0
 * @since 2025-11-08
 */

import { Injectable, Inject } from '../../di/decorators.js';
import { ServiceLifetime, ServicePriority } from '../../di/enhanced-di-container.js';
import type { ILoggerService } from '../../di/service-interfaces.js';
import {
  SecurityContext,
  SecurityViolation,
  PIIDetection,
  SecretDetection,
} from './security-types.js';

/**
 * Data security configuration
 */
export interface DataSecurityConfig {
  enabled: boolean;
  pii_detection_enabled: boolean;
  pii_masking_enabled: boolean;
  secret_detection_enabled: boolean;
  data_classification_enabled: boolean;
  encryption_at_rest_enabled: boolean;
  audit_data_access: boolean;
  quarantine_sensitive_data: boolean;
  data_retention_enabled: boolean;
  gdpr_compliance_enabled: boolean;
  hipaa_compliance_enabled: boolean;
  pci_compliance_enabled: boolean;
}

/**
 * PII pattern configuration
 */
export interface PIIPattern {
  name: string;
  pattern: RegExp;
  confidence: number;
  category: 'personal' | 'financial' | 'health' | 'contact' | 'government';
  gdpr_relevant: boolean;
  masking_required: boolean;
  retention_policy?: {
    days: number;
    auto_delete: boolean;
  };
}

/**
 * Secret pattern configuration
 */
export interface SecretPattern {
  name: string;
  pattern: RegExp;
  confidence: number;
  category: 'api_key' | 'password' | 'certificate' | 'token' | 'private_key';
  revocation_required: boolean;
  quarantine: boolean;
  description: string;
}

/**
 * Data classification levels
 */
export enum DataClassificationLevel {
  PUBLIC = 'public',
  INTERNAL = 'internal',
  CONFIDENTIAL = 'confidential',
  RESTRICTED = 'restricted',
}

/**
 * Data security result
 */
export interface DataSecurityResult {
  safe: boolean;
  classification: DataClassificationLevel;
  pii_detections: PIIDetection[];
  secret_detections: SecretDetection[];
  masked_data?: unknown;
  violations: SecurityViolation[];
  recommendations: string[];
  metadata: {
    scan_duration_ms: number;
    data_size_bytes: number;
    patterns_matched: number;
    quarantine_required: boolean;
  };
}

/**
 * Data masking options
 */
export interface DataMaskingOptions {
  method: 'full' | 'partial' | 'hash' | 'tokenize' | 'encrypt';
  preserve_length: boolean;
  preserve_format: boolean;
  masking_char?: string;
  visible_chars?: number;
  hash_algorithm?: string;
  encryption_key?: string;
}

/**
 * Data Security Service
 */
@Injectable({
  lifetime: ServiceLifetime.SINGLETON,
  priority: ServicePriority.HIGH,
  tags: ['security', 'data-protection', 'pii', 'masking', 'secrets'],
})
export class DataSecurityService {
  private readonly piiPatterns: Map<string, PIIPattern> = new Map();
  private readonly secretPatterns: Map<string, SecretPattern> = new Map();
  private readonly quarantineStore: Map<string, unknown> = new Map();

  constructor(
    @Inject('LOGGER_SERVICE') private readonly logger: ILoggerService,
    private readonly config: DataSecurityConfig
  ) {
    this.initializePIIPatterns();
    this.initializeSecretPatterns();
  }

  /**
   * Scan data for security issues
   */
 scanData(
    data: unknown,
    context: SecurityContext,
    options: {
      enablePII?: boolean;
      enableSecrets?: boolean;
      enableClassification?: boolean;
    } = {}
  ): Promise<DataSecurityResult> {
    if (!this.config.enabled) {
      return {
        safe: true,
        classification: DataClassificationLevel.PUBLIC,
        pii_detections: [],
        secret_detections: [],
        violations: [],
        recommendations: [],
        metadata: {
          scan_duration_ms: 0,
          data_size_bytes: 0,
          patterns_matched: 0,
          quarantine_required: false,
        },
      };
    }

    const startTime = Date.now();
    const violations: SecurityViolation[] = [];
    const recommendations: string[] = [];

    const enablePII = options.enablePII ?? this.config.pii_detection_enabled;
    const enableSecrets = options.enableSecrets ?? this.config.secret_detection_enabled;
    const enableClassification =
      options.enableClassification ?? this.config.data_classification_enabled;

    try {
      // Prepare data for scanning
      const dataString = this.prepareDataForScanning(data);
      const data_size_bytes = dataString.length;

      // PII Detection
      const pii_detections: PIIDetection[] = [];
      if (_enablePII) {
        const piiResults = await this.detectPII(dataString, context);
        pii_detections.push(...piiResults);
      }

      // Secret Detection
      const secret_detections: SecretDetection[] = [];
      if (_enableSecrets) {
        const secretResults = await this.detectSecrets(dataString, context);
        secret_detections.push(...secretResults);
      }

      // Data Classification
      let classification = DataClassificationLevel.PUBLIC;
      if (_enableClassification) {
        classification = await this.classifyData(data, pii_detections, secret_detections);
      }

      // Generate violations and recommendations
      this.analyzeDetections(pii_detections, secret_detections, violations, recommendations);

      // Determine if data is safe
      const safe = this.isDataSafe(pii_detections, secret_detections, classification);

      // Apply masking if enabled and needed
      let masked_data: unknown;
      if (this.config.pii_masking_enabled && !safe && pii_detections.length > 0) {
        masked_data = await this.maskData(data, pii_detections);
      }

      // Quarantine if necessary
      let quarantine_required = false;
      if (this.config.quarantine_sensitive_data && !safe) {
        await this.quarantineData(data, context, {
          reason: 'Sensitive data detected',
          pii_count: pii_detections.length,
          secret_count: secret_detections.length,
          classification,
        });
        quarantine_required = true;
      }

      // Log security event
      await this.logDataSecurityEvent({
        type: 'data_scan',
        context,
        result: {
          safe,
          classification,
          pii_count: pii_detections.length,
          secret_count: secret_detections.length,
          violations: violations.length,
        },
        metadata: {
          data_size_bytes,
          scan_duration_ms: Date.now() - startTime,
        },
      });

      return {
        safe,
        classification,
        pii_detections,
        secret_detections,
        masked_data,
        violations,
        recommendations,
        metadata: {
          scan_duration_ms: Date.now() - startTime,
          data_size_bytes,
          patterns_matched: pii_detections.length + secret_detections.length,
          quarantine_required,
        },
      };
    } catch (error) {
      this.logger.error('Data security scan failed', {
        error: error instanceof Error ? error.message : String(error),
        context_id: context.id,
      });

      return {
        safe: false,
        classification: DataClassificationLevel.RESTRICTED,
        pii_detections: [],
        secret_detections: [],
        violations: [
          {
            type: 'scan_error',
            severity: 'medium',
            description: 'Data security scan failed',
            recommendation: 'Review data and retry scan',
          },
        ],
        recommendations: ['Retry scan', 'Contact security team'],
        metadata: {
          scan_duration_ms: Date.now() - startTime,
          data_size_bytes: 0,
          patterns_matched: 0,
          quarantine_required: false,
        },
      };
    }
  }

  /**
   * Detect PII in data
   */
 detectPII(data: string, context: SecurityContext): Promise<PIIDetection[]> {
    const detections: PIIDetection[] = [];

    for (const [patternName,  pattern] of this.piiPatterns) {
      const matches = data.match(pattern.pattern);
      if (_matches) {
        for (const match of matches) {
          detections.push({
            type: pattern.name,
            pattern: pattern.pattern,
            confidence: pattern.confidence,
            location: this.findLocation(data, match),
            value: this.shouldLogValue(pattern) ? match : undefined,
            masked: false,
          });
        }
      }
    }

    // Sort by confidence
    return detections.sort((a,  _b) => b.confidence - a.confidence);
  }

  /**
   * Detect secrets in data
   */
 detectSecrets(data: string, context: SecurityContext): Promise<SecretDetection[]> {
    const detections: SecretDetection[] = [];

    for (const [patternName,  pattern] of this.secretPatterns) {
      const matches = data.match(pattern.pattern);
      if (_matches) {
        for (const match of matches) {
          detections.push({
            type: pattern.name,
            pattern: pattern.pattern,
            confidence: pattern.confidence,
            location: this.findLocation(data, match),
            severity: this.getSecretSeverity(pattern.category),
            revoked: false,
          });
        }
      }
    }

    // Sort by severity and confidence
    return detections.sort((a,  _b) => {
      const severityOrder = { critical: 3, high: 2, medium: 1, low: 0 };
      const aSeverity = severityOrder[a.severity as keyof typeof severityOrder] || 0;
      const bSeverity = severityOrder[b.severity as keyof typeof severityOrder] || 0;

      if (aSeverity !== bSeverity) {
        return bSeverity - aSeverity;
      }

      return b.confidence - a.confidence;
    });
  }

  /**
   * Classify data based on content
   */
 classifyData(
    data: unknown,
    piiDetections: PIIDetection[],
    secretDetections: SecretDetection[]
  ): Promise<DataClassificationLevel> {
    // Check for secrets first (highest classification)
    if (secretDetections.length > 0) {
      const hasCriticalSecrets = secretDetections.some((s) => s.severity === 'critical');
      return hasCriticalSecrets
        ? DataClassificationLevel.RESTRICTED
        : DataClassificationLevel.CONFIDENTIAL;
    }

    // Check PII classifications
    if (piiDetections.length > 0) {
      const hasFinancialPII = piiDetections.some((p) => p.category === 'financial');
      const hasHealthPII = piiDetections.some((p) => p.category === 'health');
      const hasGovernmentPII = piiDetections.some((p) => p.category === 'government');
      const hasGDPRPII = piiDetections.some((p) => p.gdpr_relevant);

      if (hasFinancialPII || hasHealthPII || hasGovernmentPII) {
        return DataClassificationLevel.RESTRICTED;
      }

      if (_hasGDPRPII) {
        return DataClassificationLevel.CONFIDENTIAL;
      }

      return DataClassificationLevel.INTERNAL;
    }

    // Check for internal indicators
    const dataString = JSON.stringify(data).toLowerCase();
    const internalIndicators = [
      'internal',
      'confidential',
      'proprietary',
      'secret',
      'employee_only',
      'company_only',
      'not_for_public',
    ];

    if (internalIndicators.some((indicator) => dataString.includes(indicator))) {
      return DataClassificationLevel.INTERNAL;
    }

    return DataClassificationLevel.PUBLIC;
  }

  /**
   * Mask sensitive data
   */
 maskData(
    data: unknown,
    piiDetections: PIIDetection[],
    options: DataMaskingOptions = {
      method: 'partial',
      preserve_length: true,
      preserve_format: false,
      masking_char: '*',
      visible_chars: 4,
    }
  ): Promise<unknown> {
    const masked = JSON.parse(JSON.stringify(data)); // Deep clone

    for (const detection of piiDetections) {
      this.maskPIIInObject(masked, detection, options);
    }

    return masked;
  }

  /**
   * Quarantine sensitive data
   */
 quarantineData(
    data: unknown,
    context: SecurityContext,
    metadata: unknown
  ): Promise<string> {
    const quarantineId = this.generateQuarantineId();

    const quarantineRecord = {
      id: quarantineId,
      data: this.encryptData(data),
      metadata: {
        ...metadata,
        context_id: context.id,
        user_id: context.userId,
        timestamp: new Date().toISOString(),
        ip_address: context.ipAddress,
      },
      status: 'quarantined',
      created_at: new Date(),
      expires_at: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days
    };

    this.quarantineStore.set(quarantineId, quarantineRecord);

    this.logger.warn('Data quarantined', {
      quarantine_id: quarantineId,
      context_id: context.id,
      reason: metadata.reason,
      pii_count: metadata.pii_count,
      secret_count: metadata.secret_count,
    });

    return quarantineId;
  }

  /**
   * Release quarantined data (admin only)
   */
 releaseQuarantinedData(
    quarantineId: string,
    requesterContext: SecurityContext
  ): Promise<unknown> {
    const record = this.quarantineStore.get(quarantineId);
    if (!record) {
      throw new Error('Quarantine record not found');
    }

    // Verify requester has admin privileges
    // This would integrate with the access control service

    const data = this.decryptData(record.data);
    this.quarantineStore.delete(quarantineId);

    this.logger.info('Quarantined data released', {
      quarantine_id: quarantineId,
      requester_id: requesterContext.userId,
      original_context_id: record.metadata.context_id,
    });

    return data;
  }

  /**
   * Get data security statistics
   */
  getSecurityStats(): {
    total_scans: number;
    pii_detections: number;
    secret_detections: number;
    quarantined_items: number;
    classification_breakdown: Record<string, number>;
  } {
    // This would typically read from a persistent store
    return {
      total_scans: 0,
      pii_detections: 0,
      secret_detections: 0,
      quarantined_items: this.quarantineStore.size,
      classification_breakdown: {
        public: 0,
        internal: 0,
        confidential: 0,
        restricted: 0,
      },
    };
  }

  // Private helper methods

  private initializePIIPatterns(): void {
    // Email addresses
    this.piiPatterns.set('email', {
      name: 'email',
      pattern: /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g,
      confidence: 0.95,
      category: 'contact',
      gdpr_relevant: true,
      masking_required: true,
      retention_policy: { days: 365, auto_delete: false },
    });

    // Phone numbers (US format)
    this.piiPatterns.set('phone_us', {
      name: 'phone_us',
      pattern: /\b\d{3}[-.]?\d{3}[-.]?\d{4}\b/g,
      confidence: 0.9,
      category: 'contact',
      gdpr_relevant: true,
      masking_required: true,
      retention_policy: { days: 365, auto_delete: false },
    });

    // Social Security Numbers
    this.piiPatterns.set('ssn', {
      name: 'ssn',
      pattern: /\b\d{3}-\d{2}-\d{4}\b/g,
      confidence: 0.98,
      category: 'government',
      gdpr_relevant: true,
      masking_required: true,
      retention_policy: { days: 2555, auto_delete: true }, // 7 years
    });

    // Credit card numbers
    this.piiPatterns.set('credit_card', {
      name: 'credit_card',
      pattern: /\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b/g,
      confidence: 0.9,
      category: 'financial',
      gdpr_relevant: true,
      masking_required: true,
      retention_policy: { days: 2555, auto_delete: true }, // 7 years
    });

    // Passport numbers
    this.piiPatterns.set('passport', {
      name: 'passport',
      pattern: /\b[A-Za-z]{1,2}\d{6,9}\b/g,
      confidence: 0.7,
      category: 'government',
      gdpr_relevant: true,
      masking_required: true,
      retention_policy: { days: 2555, auto_delete: true },
    });

    // IP addresses
    this.piiPatterns.set('ip_address',  {
      name: 'ip_address', 
      pattern: /\b(?:\d{1, 3}\.){3}\d{1,3}\b/g,
      confidence: 0.8,
      category: 'personal',
      gdpr_relevant: true,
      masking_required: true,
      retention_policy: { days: 90, auto_delete: true },
    });

    // URLs with potential PII
    this.piiPatterns.set('url_with_id', {
      name: 'url_with_id',
      pattern: /https?:\/\/[^\s]+\/(user|profile|account)\/[\w-]+/gi,
      confidence: 0.6,
      category: 'personal',
      gdpr_relevant: true,
      masking_required: true,
    });

    // Medical record numbers
    this.piiPatterns.set('medical_record', {
      name: 'medical_record',
      pattern: /\b(MR|MED|PAT)\d{6,10}\b/gi,
      confidence: 0.8,
      category: 'health',
      gdpr_relevant: true,
      masking_required: true,
      retention_policy: { days: 2555, auto_delete: false },
    });

    // Bank account numbers
    this.piiPatterns.set('bank_account', {
      name: 'bank_account',
      pattern: /\b\d{8,17}\b/g,
      confidence: 0.4,
      category: 'financial',
      gdpr_relevant: true,
      masking_required: true,
      retention_policy: { days: 2555, auto_delete: true },
    });

    // Driver's license numbers
    this.piiPatterns.set('drivers_license', {
      name: 'drivers_license',
      pattern: /\b[A-Za-z]{1,2}\d{5,8}\b/g,
      confidence: 0.6,
      category: 'government',
      gdpr_relevant: true,
      masking_required: true,
      retention_policy: { days: 2555, auto_delete: true },
    });
  }

  private initializeSecretPatterns(): void {
    // API Keys
    this.secretPatterns.set('api_key_generic', {
      name: 'api_key_generic',
      pattern: /\b[A-Za-z0-9]{20,}\b/g,
      confidence: 0.4,
      category: 'api_key',
      revocation_required: true,
      quarantine: true,
      description: 'Generic API key pattern',
    });

    // JWT Tokens
    this.secretPatterns.set('jwt_token', {
      name: 'jwt_token',
      pattern: /\bey[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+\b/g,
      confidence: 0.95,
      category: 'token',
      revocation_required: true,
      quarantine: true,
      description: 'JSON Web Token',
    });

    // AWS Access Keys
    this.secretPatterns.set('aws_access_key', {
      name: 'aws_access_key',
      pattern: /\bAKIA[0-9A-Z]{16}\b/g,
      confidence: 0.98,
      category: 'api_key',
      revocation_required: true,
      quarantine: true,
      description: 'AWS Access Key ID',
    });

    // GitHub Personal Access Tokens
    this.secretPatterns.set('github_token', {
      name: 'github_token',
      pattern: /\bghp_[a-zA-Z0-9]{36}\b/g,
      confidence: 0.98,
      category: 'token',
      revocation_required: true,
      quarantine: true,
      description: 'GitHub Personal Access Token',
    });

    // Private Keys
    this.secretPatterns.set('private_key', {
      name: 'private_key',
      pattern: /-----BEGIN (RSA |OPENSSH |DSA |EC |PGP )?PRIVATE KEY-----/g,
      confidence: 0.99,
      category: 'private_key',
      revocation_required: true,
      quarantine: true,
      description: 'Private key header',
    });

    // Database connection strings
    this.secretPatterns.set('database_connection',  {
      name: 'database_connection', 
      _pattern: /(?:mongodb|mysql|postgresql):\/\/[^\s:]+:[^\s@]+@[^\s\/]+/gi,
      confidence: 0.9,
      category: 'password',
      revocation_required: true,
      quarantine: true,
      description: 'Database connection string with credentials',
    });

    // Passwords in common formats
    this.secretPatterns.set('password_field', {
      name: 'password_field',
      pattern: /["']?password["']?\s*[:=]\s*["'][^"']{8,}["']/gi,
      confidence: 0.7,
      category: 'password',
      revocation_required: true,
      quarantine: true,
      description: 'Password field assignment',
    });
  }

  private prepareDataForScanning(data: unknown): string {
    // Convert data to string for pattern matching
    return JSON.stringify(data, null, 2);
  }

  private findLocation(data: string,  _match: string): string {
    const index = data.indexOf(match);
    if (index === -1) return 'unknown';

    // Find line number and column
    const lines = data.substring(0, index).split('\n');
    const lineNumber = lines.length;
    const columnNumber = lines[lines.length - 1].length + 1;

    return `line ${lineNumber}, column ${columnNumber}`;
  }

  private shouldLogValue(_pattern: PIIPattern): boolean {
    // Don't log full values for highly sensitive PII
    const sensitiveCategories = ['government', 'financial', 'health'];
    return !sensitiveCategories.includes(pattern.category) && pattern.confidence < 0.9;
  }

  private getSecretSeverity(category: string): string {
    const severityMap: Record<string, string> = {
      api_key: 'high',
      password: 'critical',
      certificate: 'critical',
      token: 'high',
      private_key: 'critical',
    };

    return severityMap[category] || 'medium';
  }

  private analyzeDetections(
    _piiDetections: PIIDetection[], 
    _secretDetections: SecretDetection[], 
    _violations: SecurityViolation[], 
    _recommendations: string[]
  ): void {
    // Analyze PII detections
    if (piiDetections.length > 0) {
      const gdprPII = piiDetections.filter((p) => p.gdpr_relevant);
      if (gdprPII.length > 0) {
        violations.push({
          type: 'gdpr_pii_detected', 
          severity: 'high', 
          description: `GDPR-relevant PII detected: ${gdprPII.map((p) => p.type).join(', ')}`,
          recommendation: 'Apply GDPR compliance measures and obtain consent',
        });
        recommendations.push('Review GDPR compliance requirements');
      }

      const highConfidencePII = piiDetections.filter((p) => p.confidence > 0.9);
      if (highConfidencePII.length > 0) {
        violations.push({
          type: 'high_confidence_pii', 
          severity: 'medium', 
          description: `High-confidence PII detected: ${highConfidencePII.map((p) => p.type).join(', ')}`,
          recommendation: 'Apply data masking and access controls',
        });
      }
    }

    // Analyze secret detections
    if (secretDetections.length > 0) {
      const criticalSecrets = secretDetections.filter((s) => s.severity === 'critical');
      if (criticalSecrets.length > 0) {
        violations.push({
          type: 'critical_secrets_detected', 
          severity: 'critical', 
          description: `Critical secrets detected: ${criticalSecrets.map((s) => s.type).join(', ')}`,
          recommendation: 'Immediately revoke and rotate detected secrets',
        });
        recommendations.push('Immediately revoke detected secrets');
      }

      const apiKeys = secretDetections.filter((s) => s.category === 'api_key');
      if (apiKeys.length > 0) {
        violations.push({
          type: 'api_keys_detected', 
          severity: 'high', 
          description: `API keys detected: ${apiKeys.map((s) => s.type).join(', ')}`,
          recommendation: 'Revoke and regenerate API keys',
        });
        recommendations.push('Review API key management practices');
      }
    }
  }

  private isDataSafe(
    _piiDetections: PIIDetection[], 
    _secretDetections: SecretDetection[], 
    _classification: DataClassificationLevel
  ): boolean {
    // Data is not safe if there are any secrets
    if (secretDetections.length > 0) {
      return false;
    }

    // Data is not safe if there are high-confidence PII detections
    const highConfidencePII = piiDetections.filter((p) => p.confidence > 0.9);
    if (highConfidencePII.length > 0) {
      return false;
    }

    // Data is not safe if classification is restricted
    if (classification === DataClassificationLevel.RESTRICTED) {
      return false;
    }

    return true;
  }

  private maskPIIInObject(
    _obj: unknown, 
    _detection: PIIDetection, 
    _options: DataMaskingOptions
  ): string | void {
    if (typeof obj === 'string' && detection.pattern.test(obj)) {
      // Mask the string
      const masked = this.maskString(obj, detection, options);
      return masked;
    }

    if (typeof obj === 'object' && obj !== null) {
      for (const [key, value] of Object.entries(obj)) {
        if (typeof value === 'string' && detection.pattern.test(value)) {
          obj[key] = this.maskString(value, detection, options);
        } else if (typeof value === 'object') {
          this.maskPIIInObject(value, detection, options);
        }
      }
    }
  }

  private maskString(_str: string,  _detection: PIIDetection,  _options: DataMaskingOptions): string {
    switch (options.method) {
      case 'full':
        return options.masking_char?.repeat(str.length) || '*'.repeat(str.length);

      case 'partial':
        if (options.preserve_length) {
          const visible = Math.min(options.visible_chars || 4, str.length);
          const masked = str.length - visible;
          return str.substring(0, visible) + (options.masking_char || '*').repeat(masked);
        }
        return str.substring(0, 2) + (options.masking_char || '*').repeat(str.length - 2);

      case 'hash':
        // Simple hash implementation - in production use proper crypto
        return '#'.repeat(str.length);

      case 'tokenize':
        return `[TOKENIZED:${detection.type}]`;

      default:
        return '***';
    }
  }

  private generateQuarantineId(): string {
    return `quarantine_${Date.now()}_${String(Math.random().toString(36).substr(2, 9))}`;
  }

  private encryptData(data: unknown): string {
    // Placeholder for encryption - in production use proper encryption
    return Buffer.from(JSON.stringify(data)).toString('base64');
  }

  private decryptData(_encryptedData: string): unknown {
    // Placeholder for decryption - in production use proper decryption
    return JSON.parse(Buffer.from(encryptedData, 'base64').toString());
  }

  private async logDataSecurityEvent(event: unknown): Promise<void> {
    this.logger.info('Data security event', {
      type: event.type,
      context_id: event.context.id,
      result: event.result,
      metadata: event.metadata,
    });
  }
}
