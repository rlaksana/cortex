/**
 * Security Monitoring Service
 *
 * Real-time security monitoring with anomaly detection, threat pattern recognition,
 * and automated incident response capabilities
 *
 * @author Cortex Security Team
 * @version 1.0.0
 * @since 2025-11-08
 */

import { Injectable } from '../../di/decorators.js';
import { ServiceLifetime, ServicePriority } from '../../di/enhanced-di-container.js';
import type { ILoggerService } from '../../di/service-interfaces.js';
import type { IAuditService } from '../../di/service-interfaces.js';
import {
  SecurityContext,
  SecurityEvent,
  SecurityViolation,
  SecurityIncident,
  UserBehaviorProfile,
  ThreatLevel,
  SecurityAlert,
} from './security-types.js';

/**
 * Security monitoring configuration
 */
export interface SecurityMonitoringConfig {
  enabled: boolean;
  anomaly_detection: boolean;
  behavior_analysis: boolean;
  threat_intelligence: boolean;
  real_time_alerts: boolean;
  automated_response: boolean;
  learning_enabled: boolean;
  retention_days: number;
  alert_thresholds: {
    violation_count_per_minute: number;
    failed_auth_per_minute: number;
    data_access_anomaly_score: number;
    behavioral_anomaly_score: number;
  };
  response_actions: {
    auto_block_ip: boolean;
    auto_block_user: boolean;
    auto_quarantine_session: boolean;
    require_mfa: boolean;
    escalate_to_admin: boolean;
  };
}

/**
 * User behavior metrics
 */
export interface UserBehaviorMetrics {
  userId: string;
  timestamp: Date;
  requestCount: number;
  uniqueOperations: string[];
  dataAccessPatterns: Array<{
    resource: string;
    count: number;
    avgDataSize: number;
  }>;
  timePatterns: {
    hourOfDay: number;
    dayOfWeek: number;
    timezone: string;
  };
  locationPatterns: {
    ipAddresses: string[];
    countries: string[];
    userAgents: string[];
  };
  errorPatterns: {
    errorTypes: string[];
    errorCount: number;
    lastError: Date;
  };
  performanceMetrics: {
    avgResponseTime: number;
    requestFrequency: number;
    dataVolume: number;
  };
}

/**
 * Anomaly detection result
 */
export interface AnomalyResult {
  detected: boolean;
  score: number;
  threshold: number;
  type: string;
  description: string;
  confidence: number;
  indicators: string[];
  recommendations: string[];
  riskLevel: ThreatLevel;
}

/**
 * Threat intelligence data
 */
export interface ThreatIntelligence {
  indicators: Array<{
    type: 'ip' | 'domain' | 'hash' | 'pattern' | 'signature';
    value: string;
    severity: 'low' | 'medium' | 'high' | 'critical';
    source: string;
    description: string;
    lastSeen: Date;
    confidence: number;
  }>;
  campaigns: Array<{
    id: string;
    name: string;
    description: string;
    indicators: string[];
    tactics: string[];
    techniques: string[];
    active: boolean;
  }>;
  patterns: Array<{
    name: string;
    pattern: RegExp;
    category: string;
    severity: string;
    description: string;
  }>;
}

/**
 * Security Monitoring Service
 */
@Injectable({
  lifetime: ServiceLifetime.SINGLETON,
  priority: ServicePriority.HIGH,
  tags: ['security', 'monitoring', 'anomaly-detection', 'threat-intelligence'],
})
export class SecurityMonitoringService {
  private readonly logger: ILoggerService;
  private readonly auditService: IAuditService;
  private readonly config: SecurityMonitoringConfig;
  private readonly userProfiles: Map<string, UserBehaviorProfile> = new Map();
  private readonly activeAlerts: Map<string, SecurityAlert> = new Map();
  private readonly activeIncidents: Map<string, SecurityIncident> = new Map();
  private readonly threatIntelligence: ThreatIntelligence;
  private readonly metricsBuffer: Map<string, UserBehaviorMetrics[]> = new Map();
  private readonly anomalyDetectors: Map<string, AnomalyDetector> = new Map();

  constructor(
    _logger: ILoggerService, 
    _auditService: IAuditService, 
    config: SecurityMonitoringConfig
  ) {
    this.logger = logger;
    this.auditService = auditService;
    this.config = config;
    this.threatIntelligence = this.initializeThreatIntelligence();
    this.initializeAnomalyDetectors();
    this.startMonitoringTasks();
  }

  /**
   * Process security event for monitoring
   */
  async processSecurityEvent(event: SecurityEvent): Promise<AnomalyResult[]> {
    if (!this.config.enabled) {
      return [];
    }

    const anomalies: AnomalyResult[] = [];
    const startTime = Date.now();

    try {
      // Update user behavior profile
      if (this.config.behavior_analysis && event.context.userId) {
        await this.updateUserBehaviorProfile(event);
      }

      // Anomaly detection
      if (this.config.anomaly_detection) {
        const detectionResults = await this.detectAnomalies(event);
        anomalies.push(...detectionResults);
      }

      // Threat intelligence check
      if (this.config.threat_intelligence) {
        const threatResults = await this.checkThreatIntelligence(event);
        anomalies.push(...threatResults);
      }

      // Create alerts for significant anomalies
      if (anomalies.length > 0) {
        await this.createAlerts(event, anomalies);
      }

      // Automated response
      if (this.config.automated_response) {
        await this.executeAutomatedResponse(event, anomalies);
      }

      // Log monitoring results
      this.logger.debug('Security event processed', {
        event_type: event.type,
        anomalies_detected: anomalies.length,
        processing_time_ms: Date.now() - startTime,
        context_id: event.context.id,
      });

      return anomalies;
    } catch (error) {
      this.logger.error('Security monitoring failed', {
        error: error instanceof Error ? error.message : String(error),
        context_id: event.context.id,
      });
      return [];
    }
  }

  /**
   * Detect anomalies in security event
   */
  async detectAnomalies(event: SecurityEvent): Promise<AnomalyResult[]> {
    const anomalies: AnomalyResult[] = [];

    // Frequency anomalies
    const frequencyAnomaly = await this.detectFrequencyAnomaly(event);
    if (frequencyAnomaly.detected) {
      anomalies.push(frequencyAnomaly);
    }

    // Behavioral anomalies
    if (event.context.userId) {
      const behavioralAnomaly = await this.detectBehavioralAnomaly(event);
      if (behavioralAnomaly.detected) {
        anomalies.push(behavioralAnomaly);
      }
    }

    // Data access anomalies
    const dataAccessAnomaly = await this.detectDataAccessAnomaly(event);
    if (dataAccessAnomaly.detected) {
      anomalies.push(dataAccessAnomaly);
    }

    // Time-based anomalies
    const timeAnomaly = await this.detectTimeBasedAnomaly(event);
    if (timeAnomaly.detected) {
      anomalies.push(timeAnomaly);
    }

    // Location anomalies
    const locationAnomaly = await this.detectLocationAnomaly(event);
    if (locationAnomaly.detected) {
      anomalies.push(locationAnomaly);
    }

    // Error pattern anomalies
    const errorAnomaly = await this.detectErrorPatternAnomaly(event);
    if (errorAnomaly.detected) {
      anomalies.push(errorAnomaly);
    }

    // Sort by risk level
    return anomalies.sort((a,  _b) => {
      const riskOrder = { critical: 4, high: 3, medium: 2, low: 1, unknown: 0 };
      const aRisk = riskOrder[a.riskLevel as keyof typeof riskOrder] || 0;
      const bRisk = riskOrder[b.riskLevel as keyof typeof riskOrder] || 0;
      return bRisk - aRisk;
    });
  }

  /**
   * Check against threat intelligence
   */
 checkThreatIntelligence(event: SecurityEvent): Promise<AnomalyResult[]> {
    const anomalies: AnomalyResult[] = [];

    // Check IP addresses against threat intel
    if (event.context.ipAddress) {
      const ipIndicator = this.threatIntelligence.indicators.find(
        (indicator) => indicator.type === 'ip' && indicator.value === event.context.ipAddress
      );

      if (_ipIndicator) {
        anomalies.push({
          detected: true,
          score: ipIndicator.confidence,
          threshold: 0.7,
          type: 'threat_intelligence_ip',
          description: `IP address ${event.context.ipAddress} found in threat intelligence`,
          confidence: ipIndicator.confidence,
          indicators: [`Malicious IP: ${ipIndicator.description}`],
          recommendations: [
            'Block IP address',
            'Investigate user activity',
            'Check for compromise',
          ],
          riskLevel: this.getThreatLevelFromSeverity(ipIndicator.severity),
        });
      }
    }

    // Check request patterns against known threats
    const requestString = JSON.stringify(event.request).toLowerCase();
    for (const pattern of this.threatIntelligence.patterns) {
      if (pattern.pattern.test(requestString)) {
        anomalies.push({
          detected: true,
          score: 0.8,
          threshold: 0.7,
          type: 'threat_intelligence_pattern',
          description: `Known threat pattern detected: ${pattern.name}`,
          confidence: 0.8,
          indicators: [`Pattern: ${pattern.description}`],
          recommendations: ['Investigate request intent', 'Check for attack patterns'],
          riskLevel: this.getThreatLevelFromSeverity(pattern.severity),
        });
      }
    }

    return anomalies;
  }

  /**
   * Get user behavior profile
   */
  getUserBehaviorProfile(_userId: string): UserBehaviorProfile | null {
    return this.userProfiles.get(userId) || null;
  }

  /**
   * Get active alerts
   */
  getActiveAlerts(): SecurityAlert[] {
    return Array.from(this.activeAlerts.values());
  }

  /**
   * Get active incidents
   */
  getActiveIncidents(): SecurityIncident[] {
    return Array.from(this.activeIncidents.values());
  }

  /**
   * Create security alert
   */
  async createAlert(
    type: string,
    severity: string,
    title: string,
    description: string,
    context: SecurityContext,
    violations: SecurityViolation[] = []
  ): Promise<SecurityAlert> {
    const alert: SecurityAlert = {
      id: this.generateAlertId(),
      type,
      severity,
      title,
      description,
      context,
      violations,
      actions: this.determineAlertActions(severity, violations),
      status: 'open',
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    this.activeAlerts.set(alert.id, alert);

    // Send real-time notification if enabled
    if (this.config.real_time_alerts) {
      await this.sendAlertNotification(alert);
    }

    this.logger.warn('Security alert created', {
      alert_id: alert.id,
      type,
      severity,
      title,
      context_id: context.id,
    });

    return alert;
  }

  /**
   * Create security incident
   */
  async createIncident(
    type: string,
    severity: string,
    title: string,
    description: string,
    context: SecurityContext,
    initialEvent: SecurityEvent
  ): Promise<SecurityIncident> {
    const incident: SecurityIncident = {
      id: this.generateIncidentId(),
      type,
      severity,
      title,
      description,
      context,
      timeline: [
        {
          timestamp: new Date(),
          event: 'incident_created',
          details: {
            initial_event_type: initialEvent.type,
            initial_violations: initialEvent.result.violations.length,
            creator: 'system',
          },
        },
      ],
      impact: {
        usersAffected: 1,
        dataExposed: false,
        systemsAffected: ['security_monitoring'],
        estimatedDamage: 'unknown',
      },
      status: 'open',
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    this.activeIncidents.set(incident.id, incident);

    // Escalate to admin if configured
    if (this.config.response_actions.escalate_to_admin) {
      await this.escalateIncident(incident);
    }

    this.logger.error('Security incident created', {
      incident_id: incident.id,
      type,
      severity,
      title,
      context_id: context.id,
    });

    return incident;
  }

  /**
   * Update user behavior profile
   */
  private async updateUserBehaviorProfile(event: SecurityEvent): Promise<void> {
    const userId = event.context.userId;
    if (!userId) return;

    let profile = this.userProfiles.get(userId);
    if (!profile) {
      profile = this.createUserBehaviorProfile(userId);
      this.userProfiles.set(userId, profile);
    }

    // Update metrics
    const metrics = this.extractMetricsFromEvent(event);
    this.updateProfileMetrics(profile, metrics);

    // Update last activity
    profile.lastUpdated = new Date();

    // Check for behavioral changes
    if (profile.riskScore > 0.8) {
      this.logger.warn('High user risk score detected', {
        userId,
        riskScore: profile.riskScore,
        lastUpdated: profile.lastUpdated,
      });
    }
  }

  /**
   * Detect frequency anomalies
   */
  private async detectFrequencyAnomaly(event: SecurityEvent): Promise<AnomalyResult> {
    const key = `${event.context.userId || 'anonymous'}:${event.type}`;
    const now = Date.now();
    const windowMs = 60000; // 1 minute

    // Count events in the last minute
    const recentEvents = await this.getRecentEvents(key, windowMs);
    const eventCount = recentEvents.length;

    const threshold = this.config.alert_thresholds.violation_count_per_minute;
    const detected = eventCount > threshold;

    return {
      detected,
      score: detected ? Math.min(eventCount / threshold, 2.0) : 0,
      threshold,
      type: 'frequency_anomaly',
      description: detected
        ? `High frequency of ${event.type} events: ${eventCount} per minute`
        : `Normal frequency: ${eventCount} per minute`,
      confidence: detected ? 0.9 : 0.1,
      indicators: detected ? [`Event count: ${eventCount}`, `Threshold: ${threshold}`] : [],
      recommendations: detected
        ? ['Implement rate limiting', 'Investigate automated behavior', 'Consider blocking']
        : [],
      riskLevel: detected ? ThreatLevel.HIGH : ThreatLevel.LOW,
    };
  }

  /**
   * Detect behavioral anomalies
   */
  private async detectBehavioralAnomaly(event: SecurityEvent): Promise<AnomalyResult> {
    const profile = this.userProfiles.get(event.context.userId!);
    if (!profile) {
      return {
        detected: false,
        score: 0,
        threshold: 0.7,
        type: 'behavioral_anomaly',
        description: 'No baseline behavior established',
        confidence: 0,
        indicators: [],
        recommendations: ['Establish behavioral baseline'],
        riskLevel: ThreatLevel.LOW,
      };
    }

    const anomalies: string[] = [];
    let score = 0;

    // Check operation patterns
    const operation = event.context.operation;
    if (operation && !profile.baselineMetrics.commonOperations.includes(operation)) {
      anomalies.push(`Unusual operation: ${operation}`);
      score += 0.3;
    }

    // Check time patterns
    const currentHour = new Date().getHours();
    const typicalHours = profile.baselineMetrics.typicalTimeRanges;
    if (typicalHours.length > 0 && !typicalHours.includes(currentHour.toString())) {
      anomalies.push(`Unusual time: ${currentHour}:00`);
      score += 0.2;
    }

    // Check IP patterns
    const currentIP = event.context.ipAddress;
    if (currentIP && !profile.baselineMetrics.commonIPAddresses.includes(currentIP)) {
      anomalies.push(`Unusual IP: ${currentIP}`);
      score += 0.4;
    }

    const detected = score > this.config.alert_thresholds.behavioral_anomaly_score;

    return {
      detected,
      score,
      threshold: this.config.alert_thresholds.behavioral_anomaly_score,
      type: 'behavioral_anomaly',
      description: detected
        ? `Behavioral anomalies detected: ${anomalies.join(', ')}`
        : 'Normal behavior pattern',
      confidence: Math.min(score, 1.0),
      indicators: anomalies,
      recommendations: detected
        ? ['Verify user identity', 'Check for account compromise', 'Consider MFA challenge']
        : [],
      riskLevel: detected ? ThreatLevel.MEDIUM : ThreatLevel.LOW,
    };
  }

  /**
   * Detect data access anomalies
   */
  private async detectDataAccessAnomaly(event: SecurityEvent): Promise<AnomalyResult> {
    // Check for unusual data access patterns
    const dataAccessScore =
      event.result.violations.filter((v) => v.type.includes('pii') || v.type.includes('secret'))
        .length * 0.3;

    const detected = dataAccessScore > this.config.alert_thresholds.data_access_anomaly_score;

    return {
      detected,
      score: dataAccessScore,
      threshold: this.config.alert_thresholds.data_access_anomaly_score,
      type: 'data_access_anomaly',
      description: detected
        ? `Unusual data access pattern detected (score: ${dataAccessScore})`
        : 'Normal data access pattern',
      confidence: Math.min(dataAccessScore, 1.0),
      indicators: detected
        ? [
            `PII violations: ${event.result.violations.filter((v) => v.type.includes('pii')).length}`,
          ]
        : [],
      recommendations: detected
        ? ['Review data access permissions', 'Audit data access logs', 'Investigate data usage']
        : [],
      riskLevel: detected ? ThreatLevel.HIGH : ThreatLevel.LOW,
    };
  }

  /**
   * Detect time-based anomalies
   */
  private async detectTimeBasedAnomaly(event: SecurityEvent): Promise<AnomalyResult> {
    const hour = new Date().getHours();
    const dayOfWeek = new Date().getDay();

    // Define unusual hours (e.g., 2 AM - 5 AM)
    const unusualHours = [2, 3, 4, 5];
    const isUnusualHour = unusualHours.includes(hour);

    // Define unusual days (e.g., weekends for business operations)
    const isUnusualDay = dayOfWeek === 0 || dayOfWeek === 6; // Sunday or Saturday

    let score = 0;
    const indicators: string[] = [];

    if (_isUnusualHour) {
      score += 0.3;
      indicators.push(`Unusual hour: ${hour}:00`);
    }

    if (_isUnusualDay) {
      score += 0.2;
      indicators.push(
        `Unusual day: ${['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek]}`
      );
    }

    const detected = score > 0.4;

    return {
      detected,
      score,
      threshold: 0.4,
      type: 'time_based_anomaly',
      description: detected
        ? `Unusual time access detected: ${indicators.join(', ')}`
        : 'Normal time access pattern',
      confidence: score,
      indicators,
      recommendations: detected
        ? ['Verify user identity', 'Check for automated activity', 'Review access policies']
        : [],
      riskLevel: detected ? ThreatLevel.LOW : ThreatLevel.LOW,
    };
  }

  /**
   * Detect location anomalies
   */
  private async detectLocationAnomaly(event: SecurityEvent): Promise<AnomalyResult> {
    if (!event.context.ipAddress) {
      return {
        detected: false,
        score: 0,
        threshold: 0.7,
        type: 'location_anomaly',
        description: 'No location information available',
        confidence: 0,
        indicators: [],
        recommendations: [],
        riskLevel: ThreatLevel.LOW,
      };
    }

    const currentIP = event.context.ipAddress;
    const profile = this.userProfiles.get(event.context.userId!);

    if (!profile) {
      return {
        detected: false,
        score: 0,
        threshold: 0.7,
        type: 'location_anomaly',
        description: 'No location baseline established',
        confidence: 0,
        indicators: [],
        recommendations: ['Establish location baseline'],
        riskLevel: ThreatLevel.LOW,
      };
    }

    const isKnownLocation = profile.baselineMetrics.commonIPAddresses.includes(currentIP);
    const detected = !isKnownLocation;

    return {
      detected,
      score: detected ? 0.8 : 0,
      threshold: 0.7,
      type: 'location_anomaly',
      description: detected
        ? `Access from unknown location: ${currentIP}`
        : 'Access from known location',
      confidence: detected ? 0.9 : 0.8,
      indicators: detected ? [`Unknown IP: ${currentIP}`] : [`Known IP: ${currentIP}`],
      recommendations: detected
        ? [
            'Verify user identity',
            'Check for account takeover',
            'Consider location-based restrictions',
          ]
        : [],
      riskLevel: detected ? ThreatLevel.MEDIUM : ThreatLevel.LOW,
    };
  }

  /**
   * Detect error pattern anomalies
   */
  private async detectErrorPatternAnomaly(event: SecurityEvent): Promise<AnomalyResult> {
    const errorViolations = event.result.violations.filter(
      (v) => v.type.includes('error') || v.type.includes('failed')
    );

    const errorCount = errorViolations.length;
    const detected = errorCount > 3; // More than 3 errors is suspicious

    return {
      detected,
      score: detected ? Math.min(errorCount * 0.2, 1.0) : 0,
      threshold: 0.6,
      type: 'error_pattern_anomaly',
      description: detected
        ? `High error rate detected: ${errorCount} errors`
        : 'Normal error rate',
      confidence: Math.min(errorCount * 0.3, 1.0),
      indicators: detected ? errorViolations.map((v) => v.type) : [],
      recommendations: detected
        ? ['Investigate error causes', 'Check for targeted attacks', 'Review system health']
        : [],
      riskLevel: detected ? ThreatLevel.MEDIUM : ThreatLevel.LOW,
    };
  }

  /**
   * Create alerts from anomalies
   */
  private async createAlerts(event: SecurityEvent, anomalies: AnomalyResult[]): Promise<void> {
    for (const anomaly of anomalies) {
      if (anomaly.riskLevel === ThreatLevel.HIGH || anomaly.riskLevel === ThreatLevel.CRITICAL) {
        await this.createAlert(
          anomaly.type,
          anomaly.riskLevel,
          `Security Anomaly: ${anomaly.type}`,
          anomaly.description,
          event.context,
          event.result.violations
        );
      }
    }
  }

  /**
   * Execute automated response
   */
  private async executeAutomatedResponse(
    event: SecurityEvent,
    anomalies: AnomalyResult[]
  ): Promise<void> {
    const hasCriticalAnomalies = anomalies.some((a) => a.riskLevel === ThreatLevel.CRITICAL);
    const hasHighAnomalies = anomalies.some((a) => a.riskLevel === ThreatLevel.HIGH);

    if (hasCriticalAnomalies && this.config.response_actions.auto_block_user) {
      await this.blockUser(event.context.userId!);
    }

    if (hasHighAnomalies && this.config.response_actions.auto_block_ip) {
      await this.blockIP(event.context.ipAddress!);
    }

    if (anomalies.length > 0 && this.config.response_actions.auto_quarantine_session) {
      await this.quarantineSession(event.context.sessionId!);
    }

    if (hasCriticalAnomalies || hasHighAnomalies) {
      await this.createIncident(
        'automated_response', 
        hasCriticalAnomalies ? 'critical' : 'high', 
        `Automated Response Triggered: ${String(anomalies[0].type)}`, 
        `Security anomalies detected: ${anomalies.map((a) => a.type).join(', ')}`,
        event.context,
        event
      );
    }
  }

  // Helper methods

  private initializeThreatIntelligence(): ThreatIntelligence {
    return {
      indicators: [
        {
          type: 'ip',
          value: '192.168.1.100',
          severity: 'high',
          source: 'internal_threat_feed',
          description: 'Known malicious IP',
          lastSeen: new Date(),
          confidence: 0.9,
        },
      ],
      campaigns: [],
      patterns: [
        {
          name: 'sql_injection_attempt',
          pattern: /(\bunion\b.*\bselect\b)/gi,
          category: 'injection',
          severity: 'high',
          description: 'SQL injection attack pattern',
        },
        {
          name: 'xss_attempt',
          pattern: /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
          category: 'xss',
          severity: 'high',
          description: 'Cross-site scripting attack pattern',
        },
      ],
    };
  }

  private initializeAnomalyDetectors(): void {
    this.anomalyDetectors.set('frequency', new FrequencyAnomalyDetector());
    this.anomalyDetectors.set('behavioral', new BehavioralAnomalyDetector());
    this.anomalyDetectors.set('data_access', new DataAccessAnomalyDetector());
  }

  private startMonitoringTasks(): void {
    // Periodic cleanup of old data
    setInterval(
      () => {
        this.cleanupOldData();
      },
      60 * 60 * 1000
    ); // Every hour

    // Periodic profile updates
    setInterval(
      () => {
        this.updateUserProfiles();
      },
      5 * 60 * 1000
    ); // Every 5 minutes
  }

  private createUserBehaviorProfile(_userId: string): UserBehaviorProfile {
    return {
      userId,
      baselineMetrics: {
        averageRequestsPerHour: 0,
        averageDataSize: 0,
        commonOperations: [],
        typicalTimeRanges: [],
        commonIPAddresses: [],
      },
      riskScore: 0,
      lastUpdated: new Date(),
      anomalies: [],
    };
  }

  private extractMetricsFromEvent(_event: SecurityEvent): unknown {
    return {
      timestamp: event.timestamp,
      operation: event.context.operation,
      dataVolume: JSON.stringify(event.request).length,
      ipAddress: event.context.ipAddress,
      userAgent: event.context.userAgent,
      violations: event.result.violations.length,
    };
  }

  private updateProfileMetrics(_profile: UserBehaviorProfile,  _metrics: unknown): void {
    // Update baseline metrics
    if (
      metrics.operation &&
      !profile.baselineMetrics.commonOperations.includes(metrics.operation)
    ) {
      profile.baselineMetrics.commonOperations.push(metrics.operation);
    }

    if (
      metrics.ipAddress &&
      !profile.baselineMetrics.commonIPAddresses.includes(metrics.ipAddress)
    ) {
      profile.baselineMetrics.commonIPAddresses.push(metrics.ipAddress);
    }

    const hour = new Date().getHours();
    if (!profile.baselineMetrics.typicalTimeRanges.includes(hour.toString())) {
      profile.baselineMetrics.typicalTimeRanges.push(hour.toString());
    }

    // Update risk score
    const anomalyScore = metrics.violations * 0.1;
    profile.riskScore = Math.min(profile.riskScore + anomalyScore, 1.0);
  }

  private async getRecentEvents(key: string, windowMs: number): Promise<unknown[]> {
    // This would query a time-series database or event store
    // For now, return empty array
    return [];
  }

  private determineAlertActions(severity: string,  _violations: SecurityViolation[]): string[] {
    const actions: string[] = ['log'];

    if (severity === 'critical' || severity === 'high') {
      actions.push('notify_admin', 'investigate');
    }

    if (violations.some((v) => v.type.includes('secret'))) {
      actions.push('rotate_secrets', 'scan_system');
    }

    if (violations.some((v) => v.type.includes('pii'))) {
      actions.push('review_permissions', 'audit_access');
    }

    return actions;
  }

  private async sendAlertNotification(alert: SecurityAlert): Promise<void> {
    // This would integrate with notification systems
    this.logger.warn('Security alert notification', {
      alert_id: alert.id,
      type: alert.type,
      severity: alert.severity,
      title: alert.title,
    });
  }

  private async escalateIncident(incident: SecurityIncident): Promise<void> {
    // This would escalate to security administrators
    this.logger.error('Security incident escalated', {
      incident_id: incident.id,
      type: incident.type,
      severity: incident.severity,
    });
  }

  private generateAlertId(): string {
    return `alert_${Date.now()}_${String(Math.random().toString(36).substr(2, 9))}`;
  }

  private generateIncidentId(): string {
    return `incident_${Date.now()}_${String(Math.random().toString(36).substr(2, 9))}`;
  }

  private getThreatLevelFromSeverity(severity: string): ThreatLevel {
    const mapping: Record<string, ThreatLevel> = {
      low: ThreatLevel.LOW,
      medium: ThreatLevel.MEDIUM,
      high: ThreatLevel.HIGH,
      critical: ThreatLevel.CRITICAL,
    };

    return mapping[severity] || ThreatLevel.UNKNOWN;
  }

  private async blockUser(userId: string): Promise<void> {
    this.logger.warn('User blocked by automated response', { userId });
  }

  private async blockIP(ip: string): Promise<void> {
    this.logger.warn('IP blocked by automated response', { ip });
  }

  private async quarantineSession(sessionId: string): Promise<void> {
    this.logger.warn('Session quarantined by automated response', { sessionId });
  }

  private cleanupOldData(): void {
    const cutoffDate = new Date(Date.now() - this.config.retention_days * 24 * 60 * 60 * 1000);

    // Clean up old alerts
    for (const [id,  alert] of this.activeAlerts) {
      if (alert.createdAt < cutoffDate) {
        this.activeAlerts.delete(id);
      }
    }

    // Clean up old incidents
    for (const [id,  incident] of this.activeIncidents) {
      if (incident.createdAt < cutoffDate && incident.status === 'resolved') {
        this.activeIncidents.delete(id);
      }
    }
  }

  private updateUserProfiles(): void {
    // Periodic updates to user behavior profiles
    for (const [userId,  profile] of this.userProfiles) {
      // Decay risk score over time
      profile.riskScore = Math.max(0, profile.riskScore * 0.95);
    }
  }
}

/**
 * Anomaly detector interface
 */
interface AnomalyDetector {
  detect(_metrics: unknown,  _baseline: unknown): AnomalyResult;
}

/**
 * Frequency anomaly detector
 */
class FrequencyAnomalyDetector implements AnomalyDetector {
  detect(_metrics: unknown,  _baseline: unknown): AnomalyResult {
    // Implementation for frequency-based anomaly detection
    return {
      detected: false,
      score: 0,
      threshold: 0.7,
      type: 'frequency',
      description: 'Frequency analysis',
      confidence: 0,
      indicators: [],
      recommendations: [],
      riskLevel: ThreatLevel.LOW,
    };
  }
}

/**
 * Behavioral anomaly detector
 */
class BehavioralAnomalyDetector implements AnomalyDetector {
  detect(_metrics: unknown,  _baseline: unknown): AnomalyResult {
    // Implementation for behavioral anomaly detection
    return {
      detected: false,
      score: 0,
      threshold: 0.7,
      type: 'behavioral',
      description: 'Behavioral analysis',
      confidence: 0,
      indicators: [],
      recommendations: [],
      riskLevel: ThreatLevel.LOW,
    };
  }
}

/**
 * Data access anomaly detector
 */
class DataAccessAnomalyDetector implements AnomalyDetector {
  detect(_metrics: unknown,  _baseline: unknown): AnomalyResult {
    // Implementation for data access anomaly detection
    return {
      detected: false,
      score: 0,
      threshold: 0.7,
      type: 'data_access',
      description: 'Data access analysis',
      confidence: 0,
      indicators: [],
      recommendations: [],
      riskLevel: ThreatLevel.LOW,
    };
  }
}
