/**
 * TTL Safety Service
 *
 * Comprehensive safety mechanisms for TTL operations to prevent data loss,
 * ensure proper validation, and provide audit logging.
 *
 * Features:
 * - Data loss prevention mechanisms
 * - Comprehensive TTL validation
 * - Safe override controls
 * - Audit logging for all TTL operations
 * - Rollback capabilities for critical operations
 * - Graceful error handling and recovery
 *
 * @author Cortex Team
 * @version 1.0.0
 * @since 2025
 */

import type { KnowledgeItem } from '../../types/core-interfaces.js';
import type { TTLCalculationResult } from './ttl-policy-service.js';
import { logger } from '@/utils/logger.js';

/**
 * Safety validation result interface
 */
export interface SafetyValidationResult {
  isSafe: boolean;
  severity: 'low' | 'medium' | 'high' | 'critical';
  warnings: string[];
  errors: string[];
  error?: string;
  recommendations: string[];
  blockedOperations: string[];
  requiresConfirmation: boolean;
  checkpointId?: string;
  rollbackData?: unknown;
  estimatedDataLoss?: {
    itemCount: number;
    sizeEstimate: number;
    criticalTypes: string[];
  };
}

/**
 * Safety policy configuration interface
 */
export interface SafetyPolicyConfig {
  /** Enable data loss prevention */
  enableDataLossPrevention: boolean;
  /** Require confirmation for destructive operations */
  requireConfirmation: boolean;
  /** Maximum percentage of items that can be expired in batch */
  maxBatchExpiryPercentage: number;
  /** Require backup before mass expiry operations */
  requireBackupForMassExpiry: boolean;
  /** Critical knowledge types that need special protection */
  protectedKnowledgeTypes: string[];
  /** Maximum allowed TTL reduction percentage */
  maxTTLReductionPercentage: number;
  /** Enable dry run by default for operations */
  enableDryRunByDefault: boolean;
  /** Require approval for permanent TTL changes */
  requireApprovalForPermanentChanges: boolean;
  /** Minimum grace period before expiry (in hours) */
  minimumGracePeriodHours: number;
  /** Enable rollback capability */
  enableRollback: boolean;
}

/**
 * Operation context interface for safety checks
 */
export interface OperationContext {
  operationType:
    | 'apply_policy'
    | 'update_ttl'
    | 'cleanup_expired'
    | 'bulk_operation'
    | 'config_update';
  itemCount: number;
  affectedScopes: string[];
  operationDetails: unknown;
  userId?: string;
  sessionId?: string;
  requestId?: string;
}

/**
 * TTL Safety Service
 *
 * Provides comprehensive safety mechanisms for all TTL operations.
 */
export class TTLSafetyService {
  private safetyConfig: SafetyPolicyConfig;
  private auditLog: Array<{
    timestamp: string;
    operation: string;
    context: OperationContext;
    validation: SafetyValidationResult;
    action: string;
    result?: unknown;
  }> = [];
  private rollbackStack: Array<{
    timestamp: string;
    operation: string;
    context: OperationContext;
    rollbackData: unknown;
  }> = [];

  constructor(config: Partial<SafetyPolicyConfig> = {}) {
    this.safetyConfig = this.getDefaultSafetyConfig();
    Object.assign(this.safetyConfig, config);
    logger.info('TTL Safety Service initialized', { config: this.safetyConfig });
  }

  /**
   * Validate TTL operation for safety
   */
  async validateTTLOperation(
    items: KnowledgeItem[],
    context: OperationContext,
    calculationResults?: TTLCalculationResult[]
  ): Promise<SafetyValidationResult> {
    const result: SafetyValidationResult = {
      isSafe: true,
      severity: 'low',
      warnings: [],
      errors: [],
      recommendations: [],
      blockedOperations: [],
      requiresConfirmation: false,
      estimatedDataLoss: {
        itemCount: 0,
        sizeEstimate: 0,
        criticalTypes: [],
      },
    };

    try {
      logger.info('Starting TTL operation safety validation', {
        operationType: context.operationType,
        itemCount: items.length,
        context,
      });

      // Validation 1: Data Loss Prevention
      await this.validateDataLossPrevention(items, context, result);

      // Validation 2: Critical Knowledge Types Protection
      await this.validateProtectedKnowledgeTypes(items, result);

      // Validation 3: TTL Policy Compliance
      if (_calculationResults) {
        await this.validateTTLPolicyCompliance(calculationResults, result);
      }

      // Validation 4: Batch Operation Safety
      await this.validateBatchOperationSafety(items, context, result);

      // Validation 5: Scope Impact Assessment
      await this.validateScopeImpact(items, context, result);

      // Validation 6: Grace Period Compliance
      if (_calculationResults) {
        await this.validateGracePeriodCompliance(calculationResults, result);
      }

      // Validation 7: Permanent TTL Protection
      if (_calculationResults) {
        await this.validatePermanentTTLProtection(items, calculationResults, result);
      }

      // Validation 8: Rate Limiting and Abuse Prevention
      await this.validateRateLimiting(context, result);

      // Determine overall safety level
      this.determineOverallSafety(result);

      // Log validation result
      this.logValidationResult(context, result);
    } catch (error) {
      result.isSafe = false;
      result.severity = 'critical';
      result.errors.push(
        `Safety validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
      logger.error('TTL operation safety validation failed', { error, context });
    }

    return result;
  }

  /**
   * Create safety checkpoint before operation
   */
 createSafetyCheckpoint(
    operation: string,
    context: OperationContext,
    items: KnowledgeItem[]
  ): Promise<string> {
    const checkpointId = `checkpoint_${Date.now()}_${String(Math.random().toString(36).substring(2, 9))}`;

    try {
      const checkpointData = {
        id: checkpointId,
        timestamp: new Date().toISOString(),
        operation,
        context,
        items: items.map((item) => ({
          id: item.id,
          kind: item.kind,
          scope: item.scope,
          currentExpiry: item.expiry_at || item.data?.expiry_at,
          data: item.data,
        })),
      };

      // Add to rollback stack if enabled
      if (this.safetyConfig.enableRollback) {
        this.rollbackStack.push({
          timestamp: checkpointData.timestamp,
          operation,
          context,
          rollbackData: checkpointData,
        });

        // Keep rollback stack size manageable
        if (this.rollbackStack.length > 100) {
          this.rollbackStack = this.rollbackStack.slice(-100);
        }
      }

      logger.info('Safety checkpoint created', {
        checkpointId,
        operation,
        itemCount: items.length,
      });

      return checkpointId;
    } catch (error) {
      logger.error('Failed to create safety checkpoint', { error, operation, context });
      throw new Error(
        `Safety checkpoint creation failed: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
  }

  /**
   * Rollback operation from checkpoint
   */
 rollbackFromCheckpoint(checkpointId: string): Promise<boolean> {
    try {
      if (!this.safetyConfig.enableRollback) {
        throw new Error('Rollback is not enabled in safety configuration');
      }

      const checkpoint = this.rollbackStack.find((cp) => cp.rollbackData.id === checkpointId);
      if (!checkpoint) {
        throw new Error(`Checkpoint not found: ${checkpointId}`);
      }

      logger.info('Starting rollback operation', {
        checkpointId,
        operation: checkpoint.operation,
        itemCount: checkpoint.rollbackData.items.length,
      });

      // Implement rollback logic here
      // This would involve restoring items to their previous state
      // For now, we'll just log the rollback operation

      this.addToAuditLog('rollback_operation', checkpoint.context, {
        isSafe: true,
        severity: 'low',
        warnings: [],
        errors: [],
        recommendations: [],
        blockedOperations: [],
        requiresConfirmation: false,
        checkpointId,
        rollbackData: checkpoint.rollbackData,
      });

      logger.info('Rollback operation completed', { checkpointId });
      return true;
    } catch (error) {
      logger.error('Rollback operation failed', { error, checkpointId });
      this.addToAuditLog('rollback_operation', {} as OperationContext, {
        isSafe: false,
        severity: 'high',
        warnings: [],
        errors: [error instanceof Error ? error.message : 'Unknown error'],
        recommendations: ['Review rollback operation and retry'],
        blockedOperations: [],
        requiresConfirmation: false,
        checkpointId,
      });
      return false;
    }
  }

  /**
   * Get safety statistics
   */
  getSafetyStatistics(): {
    totalValidations: number;
    blockedOperations: number;
    warningsIssued: number;
    errorsBlocked: number;
    confirmationsRequired: number;
    rollbacksPerformed: number;
    safetyConfig: SafetyPolicyConfig;
  } {
    const stats = {
      totalValidations: this.auditLog.length,
      blockedOperations: 0,
      warningsIssued: 0,
      errorsBlocked: 0,
      confirmationsRequired: 0,
      rollbacksPerformed: this.rollbackStack.length,
      safetyConfig: this.safetyConfig,
    };

    // Calculate statistics from audit log
    for (const entry of this.auditLog) {
      if (!entry.validation.isSafe) {
        stats.blockedOperations++;
      }
      stats.warningsIssued += entry.validation.warnings.length;
      stats.errorsBlocked += entry.validation.errors.length;
      if (entry.validation.requiresConfirmation) {
        stats.confirmationsRequired++;
      }
    }

    return stats;
  }

  /**
   * Update safety configuration
   */
  updateSafetyConfig(newConfig: Partial<SafetyPolicyConfig>): void {
    // Validate new configuration
    const validation = this.validateSafetyConfig({ ...this.safetyConfig, ...newConfig });
    if (!validation.isValid) {
      throw new Error(`Invalid safety configuration: ${validation.errors.join(', ')}`);
    }

    const oldConfig = { ...this.safetyConfig };
    Object.assign(this.safetyConfig, newConfig);

    logger.info('Safety configuration updated', {
      oldConfig,
      newConfig: this.safetyConfig,
    });

    this.addToAuditLog(
      'config_update',
      {
        operationType: 'config_update',
        itemCount: 0,
        affectedScopes: [],
        operationDetails: { oldConfig, newConfig },
      },
      {
        isSafe: true,
        severity: 'low',
        warnings: [],
        errors: [],
        recommendations: [],
        blockedOperations: [],
        requiresConfirmation: false,
      }
    );
  }

  /**
   * Clear audit log
   */
  clearAuditLog(): void {
    this.auditLog = [];
    logger.info('TTL safety audit log cleared');
  }

  /**
   * Get audit log
   */
  getAuditLog(limit?: number): Array<{
    timestamp: string;
    operation: string;
    context: OperationContext;
    validation: SafetyValidationResult;
    action: string;
    result?: unknown;
  }> {
    const log = [...this.auditLog].reverse(); // Most recent first
    return limit ? log.slice(0, limit) : log;
  }

  /**
   * Validate data loss prevention
   */
  private async validateDataLossPrevention(
    items: KnowledgeItem[],
    context: OperationContext,
    result: SafetyValidationResult
  ): Promise<void> {
    if (!this.safetyConfig.enableDataLossPrevention) {
      return;
    }

    const now = new Date();
    const imminentCutoff = new Date(now.getTime() + 24 * 60 * 60 * 1000); // 24 hours

    let imminentExpiryCount = 0;
    let immediateExpiryCount = 0;
    const criticalTypesAffected = new Set<string>();

    for (const item of items) {
      const expiryTime = item.expiry_at || item.data?.expiry_at;
      if (expiryTime && expiryTime !== '9999-12-31T23:59:59.999Z') {
        const expiryDate = new Date(expiryTime);

        if (expiryDate <= now) {
          immediateExpiryCount++;
        } else if (expiryDate <= imminentCutoff) {
          imminentExpiryCount++;
        }

        if (this.safetyConfig.protectedKnowledgeTypes.includes(item.kind)) {
          criticalTypesAffected.add(item.kind);
        }
      }
    }

    if (immediateExpiryCount > 0) {
      result.isSafe = false;
      result.severity = 'critical';
      result.errors.push(`${immediateExpiryCount} items will expire immediately`);
      result.blockedOperations.push('apply_policy', 'update_ttl');
    }

    if (imminentExpiryCount > items.length * 0.1) {
      // More than 10%
      result.warnings.push(`${imminentExpiryCount} items will expire within 24 hours`);
      result.requiresConfirmation = true;
    }

    if (criticalTypesAffected.size > 0) {
      result.warnings.push(
        `Critical knowledge types affected: ${Array.from(criticalTypesAffected).join(', ')}`
      );
      result.requiresConfirmation = true;
    }

    result.estimatedDataLoss = {
      itemCount: immediateExpiryCount + imminentExpiryCount,
      sizeEstimate: (immediateExpiryCount + imminentExpiryCount) * 1024, // Rough estimate
      criticalTypes: Array.from(criticalTypesAffected),
    };
  }

  /**
   * Validate protected knowledge types
   */
  private async validateProtectedKnowledgeTypes(
    items: KnowledgeItem[],
    result: SafetyValidationResult
  ): Promise<void> {
    const protectedItems = items.filter((item) =>
      this.safetyConfig.protectedKnowledgeTypes.includes(item.kind)
    );

    if (protectedItems.length === 0) {
      return;
    }

    for (const item of protectedItems) {
      const expiryTime = item.expiry_at || item.data?.expiry_at;
      const isCurrentlyPermanent = expiryTime === '9999-12-31T23:59:59.999Z';

      if (_isCurrentlyPermanent) {
        result.warnings.push(
          `Protected item ${item.id} (${item.kind}) currently has permanent TTL`
        );
        result.requiresConfirmation = true;
      }
    }
  }

  /**
   * Validate TTL policy compliance
   */
  private async validateTTLPolicyCompliance(
    calculationResults: TTLCalculationResult[],
    result: SafetyValidationResult
  ): Promise<void> {
    if (!calculationResults) {
      return;
    }

    const policyViolations = calculationResults.filter((calc) => calc.validationErrors.length > 0);

    if (policyViolations.length > 0) {
      result.isSafe = false;
      result.severity = 'high';
      result.errors.push(`${String(policyViolations?.length ?? 0)} TTL policy violations detected`);
      result.blockedOperations.push('apply_policy', 'update_ttl');
    }

    const warnings = calculationResults.filter((calc) => calc.warnings.length > 0);
    if (warnings.length > 0) {
      result.warnings.push(`${String(warnings?.length ?? 0)} TTL policy warnings detected`);
    }
  }

  /**
   * Validate batch operation safety
   */
  private async validateBatchOperationSafety(
    items: KnowledgeItem[],
    context: OperationContext,
    result: SafetyValidationResult
  ): Promise<void> {
    if (items.length === 0) {
      return;
    }

    // Check batch size limits
    const batchExpiryPercentage = 100; // All items in this batch
    if (batchExpiryPercentage > this.safetyConfig.maxBatchExpiryPercentage) {
      result.errors.push(
        `Batch operation affects ${batchExpiryPercentage}% of items, exceeds limit of ${this.safetyConfig.maxBatchExpiryPercentage}%`
      );
      result.isSafe = false;
      result.severity = 'high';
      result.blockedOperations.push('bulk_operation');
    }

    // Require confirmation for large batches
    if (items.length > 1000) {
      result.warnings.push(`Large batch operation: ${String(items?.length ?? 0)} items`);
      result.requiresConfirmation = true;
    }

    // Require backup for mass expiry operations
    if (this.safetyConfig.requireBackupForMassExpiry && items.length > 100) {
      result.recommendations.push('Create backup before performing mass expiry operation');
      result.requiresConfirmation = true;
    }
  }

  /**
   * Validate scope impact assessment
   */
  private async validateScopeImpact(
    items: KnowledgeItem[],
    context: OperationContext,
    result: SafetyValidationResult
  ): Promise<void> {
    const affectedScopes = new Set<string>();
    const orgScopes = new Set<string>();

    for (const item of items) {
      if (item.scope?.project) affectedScopes.add(item.scope.project);
      if (item.scope?.org) orgScopes.add(item.scope.org);
      if (item.scope?.branch) affectedScopes.add(item.scope.branch);
    }

    // Warn if affecting multiple organization scopes
    if (orgScopes.size > 1) {
      result.warnings.push(`Operation affects ${orgScopes.size} organization scopes`);
      result.requiresConfirmation = true;
    }

    // Warn if affecting many project scopes
    if (affectedScopes.size > 10) {
      result.warnings.push(`Operation affects ${affectedScopes.size} project scopes`);
      result.requiresConfirmation = true;
    }
  }

  /**
   * Validate grace period compliance
   */
  private async validateGracePeriodCompliance(
    calculationResults: TTLCalculationResult[],
    result: SafetyValidationResult
  ): Promise<void> {
    if (!calculationResults) {
      return;
    }

    const minimumGracePeriodMs = this.safetyConfig.minimumGracePeriodHours * 60 * 60 * 1000;
    const now = Date.now();

    for (const calc of calculationResults) {
      if (calc.isPermanent) {
        continue; // Skip permanent items
      }

      const expiryDate = new Date(calc.expiryAt);
      const timeToExpiry = expiryDate.getTime() - now;

      if (timeToExpiry < minimumGracePeriodMs) {
        result.warnings.push(`Item expiry ${calc.expiryAt} is within minimum grace period`);
        result.requiresConfirmation = true;
      }
    }
  }

  /**
   * Validate permanent TTL protection
   */
  private async validatePermanentTTLProtection(
    items: KnowledgeItem[],
    calculationResults: TTLCalculationResult[],
    result: SafetyValidationResult
  ): Promise<void> {
    if (!this.safetyConfig.requireApprovalForPermanentChanges) {
      return;
    }

    const itemsChangingFromPermanent = items.filter((item) => {
      const currentExpiry = item.expiry_at || item.data?.expiry_at;
      return currentExpiry === '9999-12-31T23:59:59.999Z';
    });

    const itemsChangingToPermanent = calculationResults?.filter((calc) => calc.isPermanent) || [];

    if (itemsChangingFromPermanent.length > 0 || itemsChangingToPermanent.length > 0) {
      result.warnings.push(
        `Operation changes permanent TTL status for ${itemsChangingFromPermanent.length + itemsChangingToPermanent.length} items`
      );
      result.requiresConfirmation = true;
      result.recommendations.push('Review permanent TTL changes carefully');
    }
  }

  /**
   * Validate rate limiting and abuse prevention
   */
  private async validateRateLimiting(
    context: OperationContext,
    result: SafetyValidationResult
  ): Promise<void> {
    // Check for rapid successive operations
    const recentOperations = this.auditLog.filter(
      (entry) =>
        entry.context.sessionId === context.sessionId &&
        new Date(entry.timestamp).getTime() > Date.now() - 60000 // Last minute
    );

    if (recentOperations.length > 10) {
      result.warnings.push('High frequency operations detected');
      result.requiresConfirmation = true;
    }

    // Check for large operations by user/session
    const largeOperations = recentOperations.filter((entry) => entry.context.itemCount > 1000);

    if (largeOperations.length > 2) {
      result.errors.push('Too many large operations in short time period');
      result.isSafe = false;
      result.severity = 'medium';
      result.blockedOperations.push('bulk_operation');
    }
  }

  /**
   * Determine overall safety level
   */
  private determineOverallSafety(result: SafetyValidationResult): void {
    if (result.errors.length > 0) {
      result.isSafe = false;
      result.severity = result.errors.some(
        (error) =>
          error.toLowerCase().includes('critical') || error.toLowerCase().includes('data loss')
      )
        ? 'critical'
        : 'high';
    } else if (result.warnings.length > 5) {
      result.severity = 'medium';
    } else if (result.warnings.length > 0) {
      result.severity = 'low';
    }

    // Default to dry run for potentially unsafe operations
    if (result.severity !== 'low' && this.safetyConfig.enableDryRunByDefault) {
      result.recommendations.push('Consider running with dryRun=true first');
    }
  }

  /**
   * Log validation result
   */
  private logValidationResult(context: OperationContext,  result: SafetyValidationResult): void {
    this.addToAuditLog('safety_validation', context, result);
  }

  /**
   * Add entry to audit log
   */
  private addToAuditLog(
    _operation: string, 
    context: OperationContext, 
    _validation: SafetyValidationResult
  ): void {
    this.auditLog.push({
      timestamp: new Date().toISOString(),
      operation,
      context,
      validation,
      action: validation.isSafe ? 'allowed' : 'blocked',
    });

    // Keep audit log size manageable
    if (this.auditLog.length > 1000) {
      this.auditLog = this.auditLog.slice(-1000);
    }
  }

  /**
   * Get default safety configuration
   */
  private getDefaultSafetyConfig(): SafetyPolicyConfig {
    return {
      enableDataLossPrevention: true,
      requireConfirmation: true,
      maxBatchExpiryPercentage: 50,
      requireBackupForMassExpiry: true,
      protectedKnowledgeTypes: ['incident', 'risk', 'decision', 'ddl'],
      maxTTLReductionPercentage: 80,
      enableDryRunByDefault: true,
      requireApprovalForPermanentChanges: true,
      minimumGracePeriodHours: 24,
      enableRollback: true,
    };
  }

  /**
   * Validate safety configuration
   */
  private validateSafetyConfig(config: SafetyPolicyConfig): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    if (config.maxBatchExpiryPercentage < 1 || config.maxBatchExpiryPercentage > 100) {
      errors.push('maxBatchExpiryPercentage must be between 1 and 100');
    }

    if (config.maxTTLReductionPercentage < 0 || config.maxTTLReductionPercentage > 100) {
      errors.push('maxTTLReductionPercentage must be between 0 and 100');
    }

    if (config.minimumGracePeriodHours < 0 || config.minimumGracePeriodHours > 168) {
      // 1 week max
      errors.push('minimumGracePeriodHours must be between 0 and 168');
    }

    return { isValid: errors.length === 0, errors };
  }
}

// Export singleton instance
export const ttlSafetyService = new TTLSafetyService();
