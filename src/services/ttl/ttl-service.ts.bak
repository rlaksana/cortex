/**
 * TTL (Time-To-Live) Service - High-Performance TTL Enforcement
 *
 * Provides comprehensive TTL policies per knowledge type with scheduled cleanup:
 * - Configurable TTL policies per knowledge type
 * - Scheduled cleanup worker with performance optimization
 * - Metrics and monitoring for cleanup operations
 * - Performance targets: <1s for 10k records cleanup
 *
 * @author Cortex Team
 * @version 2.0.1
 * @since 2025
 */

import { logger } from '../../utils/logger.js';
import { PerformanceMonitor } from '../core/performance-monitor.js';

/**
 * Knowledge types with their default TTL policies
 */
export type KnowledgeType =
  | 'entity'
  | 'relation'
  | 'observation'
  | 'section'
  | 'runbook'
  | 'change'
  | 'issue'
  | 'decision'
  | 'todo'
  | 'release_note'
  | 'ddl'
  | 'pr_context'
  | 'incident'
  | 'release'
  | 'risk'
  | 'assumption';

/**
 * TTL policy configuration
 */
export interface TTLPolicy {
  /** Knowledge type this policy applies to */
  type: KnowledgeType;

  /** TTL in milliseconds */
  ttlMs: number;

  /** Whether this policy is enabled */
  enabled: boolean;

  /** Custom criteria for TTL evaluation */
  criteria?: {
    /** Field-based criteria */
    fieldCriteria?: Record<string, unknown>;
    /** Scope-based criteria */
    scopeCriteria?: {
      project?: string[];
      org?: string[];
      branch?: string[];
    };
    /** Custom evaluation function */
    customEvaluator?: (item: unknown) => boolean;
  };

  /** Action to take when TTL expires */
  expirationAction: 'delete' | 'archive' | 'flag' | 'notify';

  /** Grace period before expiration (ms) */
  gracePeriodMs: number;

  /** Maximum number of items to clean per batch */
  batchSize: number;

  /** Priority for cleanup (higher = cleaned first) */
  priority: number;
}

/**
 * TTL configuration
 */
export interface TTLConfig {
  /** Global enable/disable for TTL enforcement */
  enabled: boolean;

  /** Default TTL for items without specific policies */
  defaultTtlMs: number;

  /** Cleanup worker configuration */
  cleanupWorker: {
    /** Enable scheduled cleanup */
    enabled: boolean;
    /** Cleanup interval in milliseconds */
    intervalMs: number;
    /** Maximum items to process per cleanup run */
    maxItemsPerRun: number;
    /** Enable parallel processing */
    enableParallel: boolean;
    /** Number of parallel workers */
    parallelWorkers: number;
    /** Dry run mode */
    dryRun: boolean;
  };

  /** Per-type TTL policies */
  policies: Record<KnowledgeType, TTLPolicy>;

  /** Monitoring and metrics */
  monitoring: {
    /** Enable detailed metrics */
    enabled: boolean;
    /** Metrics retention period in ms */
    retentionMs: number;
    /** Alert thresholds */
    alertThresholds: {
      /** Alert if cleanup takes longer than this (ms) */
      cleanupTimeThreshold: number;
      /** Alert if more than this items are expired */
      expiredCountThreshold: number;
      /** Alert if error rate exceeds this (0-1) */
      errorRateThreshold: number;
    };
  };
}

/**
 * TTL evaluation result
 */
export interface TTLEvaluationResult {
  /** Item being evaluated */
  item: unknown;

  /** Whether item has expired */
  isExpired: boolean;

  /** Time until expiration (ms) */
  timeToExpiration: number;

  /** Applied policy */
  policy: TTLPolicy;

  /** Expiration timestamp */
  expirationTime?: Date;

  /** Reason for expiration */
  expirationReason?: string;

  /** Recommended action */
  recommendedAction: 'delete' | 'archive' | 'flag' | 'notify' | 'keep';
}

/**
 * Cleanup operation result
 */
export interface CleanupResult {
  /** Operation identifier */
  operationId: string;

  /** Timestamp when operation started */
  startTime: Date;

  /** Timestamp when operation completed */
  endTime: Date;

  /** Total duration in ms */
  duration: number;

  /** Items processed */
  itemsProcessed: number;

  /** Items cleaned up */
  itemsCleaned: number;

  /** Items failed to clean */
  itemsFailed: number;

  /** Cleanup actions taken */
  actions: {
    deleted: number;
    archived: number;
    flagged: number;
    notified: number;
  };

  /** Errors encountered */
  errors: Array<{
    itemId: string;
    error: string;
    timestamp: Date;
  }>;

  /** Performance metrics */
  performance: {
    /** Items processed per second */
    processingRate: number;
    /** Average time per item (ms) */
    averageTimePerItem: number;
    /** Memory usage (MB) */
    memoryUsage: number;
  };

  /** Policies applied */
  policiesApplied: Array<{
    type: KnowledgeType;
    itemsProcessed: number;
    itemsCleaned: number;
  }>;
}

/**
 * TTL service metrics
 */
export interface TTLMetrics {
  /** Total items evaluated */
  totalItemsEvaluated: number;

  /** Total items expired */
  totalItemsExpired: number;

  /** Total items cleaned */
  totalItemsCleaned: number;

  /** Average cleanup time (ms) */
  averageCleanupTime: number;

  /** Success rate (0-1) */
  successRate: number;

  /** Policy-specific metrics */
  policyMetrics: Record<
    KnowledgeType,
    {
      itemsEvaluated: number;
      itemsExpired: number;
      itemsCleaned: number;
      averageTimeToCleanup: number;
    }
  >;

  /** Last cleanup timestamp */
  lastCleanupTime?: Date;

  /** Next scheduled cleanup */
  nextScheduledCleanup?: Date;
}

/**
 * Default TTL policies for different knowledge types
 */
export const DEFAULT_TTL_POLICIES: Record<KnowledgeType, TTLPolicy> = {
  // High-frequency, temporary items
  todo: {
    type: 'todo',
    ttlMs: 30 * 24 * 60 * 60 * 1000, // 30 days
    enabled: true,
    expirationAction: 'delete',
    gracePeriodMs: 7 * 24 * 60 * 60 * 1000, // 7 days
    batchSize: 1000,
    priority: 10,
  },

  // Medium-term items
  issue: {
    type: 'issue',
    ttlMs: 90 * 24 * 60 * 60 * 1000, // 90 days
    enabled: true,
    expirationAction: 'archive',
    gracePeriodMs: 14 * 24 * 60 * 60 * 1000, // 14 days
    batchSize: 500,
    priority: 8,
  },

  incident: {
    type: 'incident',
    ttlMs: 180 * 24 * 60 * 60 * 1000, // 180 days
    enabled: true,
    expirationAction: 'archive',
    gracePeriodMs: 30 * 24 * 60 * 60 * 1000, // 30 days
    batchSize: 200,
    priority: 9,
  },

  // Long-term reference items
  decision: {
    type: 'decision',
    ttlMs: 365 * 24 * 60 * 60 * 1000, // 1 year
    enabled: true,
    expirationAction: 'archive',
    gracePeriodMs: 60 * 24 * 60 * 60 * 1000, // 60 days
    batchSize: 100,
    priority: 5,
  },

  runbook: {
    type: 'runbook',
    ttlMs: 730 * 24 * 60 * 60 * 1000, // 2 years
    enabled: true,
    expirationAction: 'archive',
    gracePeriodMs: 90 * 24 * 60 * 60 * 1000, // 90 days
    batchSize: 50,
    priority: 4,
  },

  // Permanent items (very long TTL)
  entity: {
    type: 'entity',
    ttlMs: 5 * 365 * 24 * 60 * 60 * 1000, // 5 years
    enabled: true,
    expirationAction: 'flag',
    gracePeriodMs: 180 * 24 * 60 * 60 * 1000, // 180 days
    batchSize: 200,
    priority: 2,
  },

  relation: {
    type: 'relation',
    ttlMs: 5 * 365 * 24 * 60 * 60 * 1000, // 5 years
    enabled: true,
    expirationAction: 'flag',
    gracePeriodMs: 180 * 24 * 60 * 60 * 1000, // 180 days
    batchSize: 500,
    priority: 3,
  },

  observation: {
    type: 'observation',
    ttlMs: 2 * 365 * 24 * 60 * 60 * 1000, // 2 years
    enabled: true,
    expirationAction: 'archive',
    gracePeriodMs: 120 * 24 * 60 * 60 * 1000, // 120 days
    batchSize: 300,
    priority: 6,
  },

  // Specialized items
  pr_context: {
    type: 'pr_context',
    ttlMs: 60 * 24 * 60 * 60 * 1000, // 60 days
    enabled: true,
    expirationAction: 'archive',
    gracePeriodMs: 7 * 24 * 60 * 60 * 1000, // 7 days
    batchSize: 1000,
    priority: 7,
  },

  ddl: {
    type: 'ddl',
    ttlMs: 3 * 365 * 24 * 60 * 60 * 1000, // 3 years
    enabled: true,
    expirationAction: 'archive',
    gracePeriodMs: 90 * 24 * 60 * 60 * 1000, // 90 days
    batchSize: 100,
    priority: 5,
  },

  release_note: {
    type: 'release_note',
    ttlMs: 2 * 365 * 24 * 60 * 60 * 1000, // 2 years
    enabled: true,
    expirationAction: 'archive',
    gracePeriodMs: 60 * 24 * 60 * 60 * 1000, // 60 days
    batchSize: 200,
    priority: 6,
  },

  change: {
    type: 'change',
    ttlMs: 365 * 24 * 60 * 60 * 1000, // 1 year
    enabled: true,
    expirationAction: 'archive',
    gracePeriodMs: 30 * 24 * 60 * 60 * 1000, // 30 days
    batchSize: 300,
    priority: 6,
  },

  release: {
    type: 'release',
    ttlMs: 3 * 365 * 24 * 60 * 60 * 1000, // 3 years
    enabled: true,
    expirationAction: 'archive',
    gracePeriodMs: 90 * 24 * 60 * 60 * 1000, // 90 days
    batchSize: 50,
    priority: 4,
  },

  risk: {
    type: 'risk',
    ttlMs: 365 * 24 * 60 * 60 * 1000, // 1 year
    enabled: true,
    expirationAction: 'flag',
    gracePeriodMs: 60 * 24 * 60 * 60 * 1000, // 60 days
    batchSize: 100,
    priority: 5,
  },

  assumption: {
    type: 'assumption',
    ttlMs: 180 * 24 * 60 * 60 * 1000, // 180 days
    enabled: true,
    expirationAction: 'archive',
    gracePeriodMs: 30 * 24 * 60 * 60 * 1000, // 30 days
    batchSize: 200,
    priority: 7,
  },

  section: {
    type: 'section',
    ttlMs: 2 * 365 * 24 * 60 * 60 * 1000, // 2 years
    enabled: true,
    expirationAction: 'archive',
    gracePeriodMs: 90 * 24 * 60 * 60 * 1000, // 90 days
    batchSize: 100,
    priority: 5,
  },
};

/**
 * Default TTL configuration
 */
export const DEFAULT_TTL_CONFIG: TTLConfig = {
  enabled: true,
  defaultTtlMs: 365 * 24 * 60 * 60 * 1000, // 1 year
  cleanupWorker: {
    enabled: true,
    intervalMs: 60 * 60 * 1000, // 1 hour
    maxItemsPerRun: 10000,
    enableParallel: true,
    parallelWorkers: 4,
    dryRun: false,
  },
  policies: DEFAULT_TTL_POLICIES,
  monitoring: {
    enabled: true,
    retentionMs: 30 * 24 * 60 * 60 * 1000, // 30 days
    alertThresholds: {
      cleanupTimeThreshold: 1000, // 1 second
      expiredCountThreshold: 1000,
      errorRateThreshold: 0.05, // 5%
    },
  },
};

/**
 * TTL Service - High-Performance TTL Enforcement
 */
export class TTLService {
  private static instance: TTLService;
  private performanceMonitor: PerformanceMonitor;
  private config: TTLConfig;
  private isInitialized = false;
  private cleanupInterval: NodeJS.Timeout | null = null;
  private _metrics: TTLMetrics;
  private isCleanupRunning = false;

  private constructor() {
    this.performanceMonitor = PerformanceMonitor.getInstance();
    this.config = { ...DEFAULT_TTL_CONFIG };
    this.metrics = this.initializeMetrics();
  }

  public static getInstance(): TTLService {
    if (!TTLService.instance) {
      TTLService.instance = new TTLService();
    }
    return TTLService.instance;
  }

  /**
   * Initialize the TTL service
   */
  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    try {
      logger.info('Initializing TTL Service...');

      // Load configuration from environment if available
      this.loadConfigurationFromEnvironment();

      // Start cleanup worker if enabled
      if (this.config.cleanupWorker.enabled) {
        this.startCleanupWorker();
      }

      this.isInitialized = true;
      logger.info('TTL Service initialized successfully', {
        enabled: this.config.enabled,
        cleanupWorkerEnabled: this.config.cleanupWorker.enabled,
        policiesEnabled: Object.values(this.config.policies).filter((p) => p.enabled).length,
      });
    } catch (error) {
      logger.error('Failed to initialize TTL Service:', error);
      throw error;
    }
  }

  /**
   * Evaluate TTL for a single item
   */
  public async evaluateTTL(item: unknown): Promise<TTLEvaluationResult> {
    try {
      if (!this.config.enabled) {
        return this.createNonExpiredResult(item, this.getDefaultPolicy());
      }

      const policy = this.getPolicyForItem(item);
      if (!policy.enabled) {
        return this.createNonExpiredResult(item, policy);
      }

      const now = new Date();
      const itemTime = this.getItemTimestamp(item);
      const expirationTime = new Date(itemTime.getTime() + policy.ttlMs);
      const timeToExpiration = expirationTime.getTime() - now.getTime();

      // Check custom criteria if defined
      let customCriteriaMet = true;
      if (policy.criteria) {
        customCriteriaMet = await this.evaluateCustomCriteria(item, policy.criteria);
      }

      const isExpired = timeToExpiration <= 0 && customCriteriaMet;
      const isInGracePeriod = timeToExpiration > 0 && timeToExpiration <= policy.gracePeriodMs;

      let recommendedAction: TTLEvaluationResult['recommendedAction'] = 'keep';
      if (_isExpired) {
        recommendedAction = policy.expirationAction;
      } else if (_isInGracePeriod) {
        recommendedAction = 'notify';
      }

      return {
        item,
        isExpired: isExpired || isInGracePeriod,
        timeToExpiration,
        policy,
        expirationTime: isExpired || isInGracePeriod ? expirationTime : undefined,
        expirationReason: this.getExpirationReason(item, policy, isExpired, isInGracePeriod),
        recommendedAction,
      };
    } catch (error) {
      logger.error('TTL evaluation failed:', error);
      return this.createErrorResult(item);
    }
  }

  /**
   * Run cleanup operation
   */
  public async runCleanup(maxItems?: number): Promise<CleanupResult> {
    const startTime = new Date();
    const operationId = `cleanup_${startTime.getTime()}`;

    if (this.isCleanupRunning) {
      logger.warn('Cleanup operation already in progress, skipping');
      throw new Error('Cleanup operation already in progress');
    }

    this.isCleanupRunning = true;

    try {
      logger.info(`Starting cleanup operation ${operationId}`);

      const maxItemsToProcess = maxItems || this.config.cleanupWorker.maxItemsPerRun;
      const startMemory = process.memoryUsage().heapUsed;

      const result: CleanupResult = {
        operationId,
        startTime,
        endTime: new Date(),
        duration: 0,
        itemsProcessed: 0,
        itemsCleaned: 0,
        itemsFailed: 0,
        actions: {
          deleted: 0,
          archived: 0,
          flagged: 0,
          notified: 0,
        },
        errors: [],
        performance: {
          processingRate: 0,
          averageTimePerItem: 0,
          memoryUsage: 0,
        },
        policiesApplied: [],
      };

      // Get items to evaluate, sorted by priority
      const itemsToEvaluate = await this.getItemsForCleanup(maxItemsToProcess);
      result.itemsProcessed = itemsToEvaluate.length;

      if (this.config.cleanupWorker.enableParallel && itemsToEvaluate.length > 100) {
        // Process in parallel
        await this.processItemsInParallel(itemsToEvaluate, result);
      } else {
        // Process sequentially
        await this.processItemsSequentially(itemsToEvaluate, result);
      }

      // Calculate performance metrics
      const endTime = new Date();
      const endMemory = process.memoryUsage().heapUsed;
      result.endTime = endTime;
      result.duration = endTime.getTime() - startTime.getTime();
      result.performance.processingRate = (result.itemsProcessed / result.duration) * 1000;
      result.performance.averageTimePerItem = result.duration / result.itemsProcessed;
      result.performance.memoryUsage = (endMemory - startMemory) / (1024 * 1024); // MB

      // Update metrics
      this.updateMetrics(result);

      // Check performance targets
      if (result.duration > 1000) {
        logger.warn(`Cleanup performance target exceeded: ${result.duration}ms > 1000ms`);
      }

      // Check alert thresholds
      this.checkAlertThresholds(result);

      // Record performance metrics
      this.performanceMonitor.recordOperation('ttl_cleanup', {
        operationId,
        itemsProcessed: result.itemsProcessed,
        itemsCleaned: result.itemsCleaned,
        duration: result.duration,
        memoryUsage: result.performance.memoryUsage,
      });

      logger.info(`Cleanup operation ${operationId} completed`, {
        duration: result.duration,
        itemsProcessed: result.itemsProcessed,
        itemsCleaned: result.itemsCleaned,
        successRate: (result.itemsCleaned / result.itemsProcessed) * 100,
      });

      return result;
    } catch (error) {
      logger.error(`Cleanup operation ${operationId} failed:`, error);
      throw error;
    } finally {
      this.isCleanupRunning = false;
    }
  }

  /**
   * Get current metrics
   */
  public getMetrics(): TTLMetrics {
    return { ...this.metrics };
  }

  /**
   * Update configuration
   */
  public updateConfig(newConfig: Partial<TTLConfig>): void {
    this.config = { ...this.config, ...newConfig };

    // Restart cleanup worker if configuration changed
    if (newConfig.cleanupWorker && this.cleanupInterval) {
      this.stopCleanupWorker();
      if (this.config.cleanupWorker.enabled) {
        this.startCleanupWorker();
      }
    }

    logger.info('TTL configuration updated', {
      enabled: this.config.enabled,
      cleanupWorkerEnabled: this.config.cleanupWorker.enabled,
    });
  }

  /**
   * Get current configuration
   */
  public getConfig(): TTLConfig {
    return { ...this.config };
  }

  /**
   * Shutdown the TTL service
   */
  public async shutdown(): Promise<void> {
    try {
      logger.info('Shutting down TTL Service...');

      // Stop cleanup worker
      this.stopCleanupWorker();

      this.isInitialized = false;
      logger.info('TTL Service shutdown completed');
    } catch (error) {
      logger.error('Error during TTL Service shutdown:', error);
      throw error;
    }
  }

  // Private methods

  private initializeMetrics(): TTLMetrics {
    const policyMetrics: Record<KnowledgeType, unknown> = {} as unknown;
    for (const type of Object.keys(DEFAULT_TTL_POLICIES) as KnowledgeType[]) {
      policyMetrics[type] = {
        itemsEvaluated: 0,
        itemsExpired: 0,
        itemsCleaned: 0,
        averageTimeToCleanup: 0,
      };
    }

    return {
      totalItemsEvaluated: 0,
      totalItemsExpired: 0,
      totalItemsCleaned: 0,
      averageCleanupTime: 0,
      successRate: 1.0,
      policyMetrics,
      nextScheduledCleanup: new Date(Date.now() + this.config.cleanupWorker.intervalMs),
    };
  }

  private loadConfigurationFromEnvironment(): void {
    // Load configuration from environment variables
    if (process.env.TTL_ENABLED !== undefined) {
      this.config.enabled = process.env.TTL_ENABLED === 'true';
    }

    if (process.env.TTL_CLEANUP_INTERVAL_MS) {
      this.config.cleanupWorker.intervalMs = parseInt(process.env.TTL_CLEANUP_INTERVAL_MS, 10);
    }

    if (process.env.TTL_DRY_RUN !== undefined) {
      this.config.cleanupWorker.dryRun = process.env.TTL_DRY_RUN === 'true';
    }

    if (process.env.TTL_MAX_ITEMS_PER_RUN) {
      this.config.cleanupWorker.maxItemsPerRun = parseInt(process.env.TTL_MAX_ITEMS_PER_RUN, 10);
    }
  }

  private startCleanupWorker(): void {
    if (this.cleanupInterval) {
      return; // Already running
    }

    logger.info('Starting TTL cleanup worker', {
      interval: this.config.cleanupWorker.intervalMs,
      maxItemsPerRun: this.config.cleanupWorker.maxItemsPerRun,
    });

    this.cleanupInterval = setInterval(async () => {
      try {
        if (!this.isCleanupRunning) {
          await this.runCleanup();
        }
      } catch (error) {
        logger.error('Scheduled cleanup failed:', error);
      }
    }, this.config.cleanupWorker.intervalMs);

    // Update next scheduled cleanup time
    this.metrics.nextScheduledCleanup = new Date(Date.now() + this.config.cleanupWorker.intervalMs);
  }

  private stopCleanupWorker(): void {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
      logger.info('TTL cleanup worker stopped');
    }
  }

  private getPolicyForItem(_item: unknown): TTLPolicy {
    const type = item.kind as KnowledgeType;
    return this.config.policies[type] || this.getDefaultPolicy();
  }

  private getDefaultPolicy(): TTLPolicy {
    return {
      type: 'entity',
      ttlMs: this.config.defaultTtlMs,
      enabled: true,
      expirationAction: 'archive',
      gracePeriodMs: 30 * 24 * 60 * 60 * 1000, // 30 days
      batchSize: 100,
      priority: 1,
    };
  }

  private getItemTimestamp(_item: unknown): Date {
    // Try multiple timestamp fields
    const timestampFields = ['created_at', 'timestamp', 'createdAt', 'created'];
    for (const field of timestampFields) {
      if (item[field]) {
        return new Date(item[field]);
      }
    }

    // Fallback to current time (item will be considered new)
    return new Date();
  }

  private async evaluateCustomCriteria(item: unknown, _criteria: unknown): Promise<boolean> {
    // Evaluate field-based criteria
    if (criteria.fieldCriteria) {
      for (const [field, expectedValue] of Object.entries(criteria.fieldCriteria)) {
        const itemValue = this.getNestedValue(item, field);
        if (itemValue !== expectedValue) {
          return false;
        }
      }
    }

    // Evaluate scope-based criteria
    if (criteria.scopeCriteria) {
      const scope = item.scope || {};
      if (
        criteria.scopeCriteria.project &&
        !criteria.scopeCriteria.project.includes(scope.project)
      ) {
        return false;
      }
      if (criteria.scopeCriteria.org && !criteria.scopeCriteria.org.includes(scope.org)) {
        return false;
      }
      if (criteria.scopeCriteria.branch && !criteria.scopeCriteria.branch.includes(scope.branch)) {
        return false;
      }
    }

    // Evaluate custom function
    if (criteria.customEvaluator) {
      return criteria.customEvaluator(item);
    }

    return true;
  }

  private getNestedValue(_obj: unknown,  _path: string): unknown {
    return path.split('.').reduce((current,  _key) => current?.[key], obj);
  }

  private createNonExpiredResult(_item: unknown,  _policy: TTLPolicy): TTLEvaluationResult {
    const itemTime = this.getItemTimestamp(item);
    const expirationTime = new Date(itemTime.getTime() + policy.ttlMs);
    const timeToExpiration = expirationTime.getTime() - Date.now();

    return {
      item,
      isExpired: false,
      timeToExpiration,
      policy,
      recommendedAction: 'keep',
    };
  }

  private createErrorResult(_item: unknown): TTLEvaluationResult {
    return {
      item,
      isExpired: false,
      timeToExpiration: Infinity,
      policy: this.getDefaultPolicy(),
      expirationReason: 'Error during evaluation',
      recommendedAction: 'keep',
    };
  }

  private getExpirationReason(
    _item: unknown, 
    _policy: TTLPolicy, 
    _isExpired: boolean, 
    _isInGracePeriod: boolean
  ): string {
    if (_isExpired) {
      return `TTL of ${policy.ttlMs}ms expired for ${policy.type}`;
    }
    if (_isInGracePeriod) {
      return `In grace period for ${policy.type}`;
    }
    return 'Not expired';
  }

  private async getItemsForCleanup(maxItems: number): Promise<unknown[]> {
    // This would typically query the database for items to evaluate
    // For now, return empty array as placeholder
    logger.debug(`Getting items for cleanup (max: ${maxItems})`);
    return [];
  }

  private async processItemsSequentially(items: unknown[], result: CleanupResult): Promise<void> {
    for (const item of items) {
      try {
        const evaluation = await this.evaluateTTL(item);
        await this.processItemBasedOnEvaluation(item, evaluation, result);
      } catch (error) {
        result.itemsFailed++;
        result.errors.push({
          itemId: item.id || 'unknown',
          error: error instanceof Error ? error.message : 'Unknown error',
          timestamp: new Date(),
        });
      }
    }
  }

  private async processItemsInParallel(items: unknown[], result: CleanupResult): Promise<void> {
    const batchSize = Math.ceil(items.length / this.config.cleanupWorker.parallelWorkers);
    const batches: unknown[][] = [];

    for (let i = 0; i < items.length; i += batchSize) {
      batches.push(items.slice(i, i + batchSize));
    }

    const batchPromises = batches.map(async (batch,  _batchIndex) => {
      const batchResult: CleanupResult = {
        ...result,
        operationId: `${result.operationId}_batch_${batchIndex}`,
        itemsProcessed: 0,
        itemsCleaned: 0,
        itemsFailed: 0,
        actions: { deleted: 0, archived: 0, flagged: 0, notified: 0 },
        errors: [],
        performance: { processingRate: 0, averageTimePerItem: 0, memoryUsage: 0 },
        policiesApplied: [],
      };

      for (const item of batch) {
        try {
          const evaluation = await this.evaluateTTL(item);
          await this.processItemBasedOnEvaluation(item, evaluation, batchResult);
        } catch (error) {
          batchResult.itemsFailed++;
          batchResult.errors.push({
            itemId: item.id || 'unknown',
            error: error instanceof Error ? error.message : 'Unknown error',
            timestamp: new Date(),
          });
        }
      }

      return batchResult;
    });

    const batchResults = await Promise.all(batchPromises);

    // Aggregate batch results
    for (const batchResult of batchResults) {
      result.itemsProcessed += batchResult.itemsProcessed;
      result.itemsCleaned += batchResult.itemsCleaned;
      result.itemsFailed += batchResult.itemsFailed;
      result.actions.deleted += batchResult.actions.deleted;
      result.actions.archived += batchResult.actions.archived;
      result.actions.flagged += batchResult.actions.flagged;
      result.actions.notified += batchResult.actions.notified;
      result.errors.push(...batchResult.errors);
    }
  }

  private async processItemBasedOnEvaluation(
    item: unknown,
    evaluation: TTLEvaluationResult,
    result: CleanupResult
  ): Promise<void> {
    const policy = evaluation.policy;

    // Update policy metrics
    let policyMetric = result.policiesApplied.find((p) => p.type === policy.type);
    if (!policyMetric) {
      policyMetric = { type: policy.type, itemsProcessed: 0, itemsCleaned: 0 };
      result.policiesApplied.push(policyMetric);
    }
    policyMetric.itemsProcessed++;

    if (evaluation.isExpired && evaluation.recommendedAction !== 'keep') {
      if (this.config.cleanupWorker.dryRun) {
        logger.debug(`Dry run: would ${evaluation.recommendedAction} item ${item.id}`);
        result.itemsCleaned++;
        policyMetric.itemsCleaned++;
        result.actions[evaluation.recommendedAction as keyof typeof result.actions]++;
        return;
      }

      try {
        await this.executeCleanupAction(item, evaluation.recommendedAction);
        result.itemsCleaned++;
        policyMetric.itemsCleaned++;
        result.actions[evaluation.recommendedAction as keyof typeof result.actions]++;
      } catch (error) {
        throw new Error(`Failed to ${evaluation.recommendedAction} item ${item.id}: ${error}`);
      }
    }
  }

  private async executeCleanupAction(item: unknown, action: string): Promise<void> {
    // This would typically perform the actual cleanup action
    // For now, just log the action
    logger.debug(`Executing cleanup action: ${action} for item ${item.id}`);

    switch (_action) {
      case 'delete':
        // Delete the item
        break;
      case 'archive':
        // Archive the item
        break;
      case 'flag':
        // Flag the item for review
        break;
      case 'notify':
        // Send notification about expiration
        break;
    }
  }

  private updateMetrics(result: CleanupResult): void {
    this.metrics.totalItemsEvaluated += result.itemsProcessed;
    this.metrics.totalItemsExpired += result.itemsCleaned;
    this.metrics.totalItemsCleaned += result.itemsCleaned;
    this.metrics.averageCleanupTime = (this.metrics.averageCleanupTime + result.duration) / 2;
    this.metrics.successRate =
      result.itemsProcessed > 0
        ? result.itemsCleaned / result.itemsProcessed
        : this.metrics.successRate;
    this.metrics.lastCleanupTime = result.endTime;

    // Update policy-specific metrics
    for (const policyResult of result.policiesApplied) {
      const policyMetric = this.metrics.policyMetrics[policyResult.type];
      policyMetric.itemsEvaluated += policyResult.itemsProcessed;
      policyMetric.itemsExpired += policyResult.itemsCleaned;
      policyMetric.itemsCleaned += policyResult.itemsCleaned;
    }
  }

  private checkAlertThresholds(result: CleanupResult): void {
    const thresholds = this.config.monitoring.alertThresholds;

    if (result.duration > thresholds.cleanupTimeThreshold) {
      logger.warn(
        `Cleanup performance alert: ${result.duration}ms > ${thresholds.cleanupTimeThreshold}ms`
      );
    }

    if (result.itemsCleaned > thresholds.expiredCountThreshold) {
      logger.warn(
        `High expired items alert: ${result.itemsCleaned} > ${thresholds.expiredCountThreshold}`
      );
    }

    const errorRate = result.itemsProcessed > 0 ? result.itemsFailed / result.itemsProcessed : 0;
    if (errorRate > thresholds.errorRateThreshold) {
      logger.warn(`High error rate alert: ${errorRate} > ${thresholds.errorRateThreshold}`);
    }
  }
}

// Export singleton instance
export const ttlService = TTLService.getInstance();
