/**
 * Memory Find Service - P0-CRITICAL Implementation
 *
 * Service layer implementation for memory search operations.
 * Provides business logic for finding knowledge items.
 *
 * @author Cortex Team
 * @version 2.0.1
 * @since 2025
 */

import { getQdrantRepository } from '../../db/qdrant-client.js';
import type { SearchResult } from '../../types/core-interfaces.js';
import type {
  IQdrantTypedRepository,
  KnowledgeEntity,
  KnowledgeObservation,
} from '../../types/cortex-repository-interfaces.js';
import { logger } from '../../utils/logger.js';
import type { ServiceRequestContext, ServiceResponse } from '../core/service-layer-router.js';
import { MemoryManager } from './memory-manager.js';

// Extended SearchResult interface with additional properties
interface EnhancedSearchResult extends SearchResult {
  relevanceScore?: number;
  excerpt?: string;
  accessLevel?: 'public' | 'internal' | 'restricted';
  timestamp?: string;
}

/**
 * Search strategy interface
 */
interface SearchStrategy {
  name: string;
  execute: (
    query: string,
    options: {
      scope?: Record<string, unknown>;
      types?: string[];
      limit?: number;
      user?: { id: string };
    }
  ) => Promise<SearchResult[]>;
}

/**
 * Memory find service implementation
 */
export class MemoryFindService {
  private static instance: MemoryFindService;
  private memoryManager: MemoryManager;
  private searchStrategies: Map<string, SearchStrategy> = new Map();
  private isInitialized = false;

  private constructor() {
    this.memoryManager = MemoryManager.getInstance();
  }

  public static getInstance(): MemoryFindService {
    if (!MemoryFindService.instance) {
      MemoryFindService.instance = new MemoryFindService();
    }
    return MemoryFindService.instance;
  }

  /**
   * Initialize memory find service
   */
  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    try {
      logger.info('Initializing Memory Find Service...');

      // Memory manager will be initialized when first accessed

      // Register search strategies
      this.registerSearchStrategies();

      this.isInitialized = true;
      logger.info('Memory Find Service initialized successfully');
    } catch (error) {
      logger.error('Failed to initialize Memory Find Service:', error);
      throw error;
    }
  }

  /**
   * Find knowledge items
   */
  public async find(context: ServiceRequestContext): Promise<ServiceResponse> {
    try {
      const {
        query,
        scope,
        types,
        limit = 10,
      } = context.parameters as {
        query: string;
        scope?: Record<string, unknown>;
        types?: string[];
        limit?: number;
      };

      if (!query || typeof query !== 'string') {
        return {
          success: false,
          error: {
            code: 'INVALID_PARAMETERS',
            message: 'Query is required and must be a string',
          },
        };
      }

      logger.info(`Searching memory with query: "${String(query.substring(0, 100))}..."`, {
        requestId: context.id,
        user: context.user?.id,
        limit,
        types,
        scope,
      });

      const repository = await getQdrantRepository();

      // Execute search using best strategy
      const strategy = this.selectSearchStrategy(query, types);
      let _results: SearchResult[] = [];

      if (_strategy) {
        results = await strategy.execute(query, {
          scope: scope || {},
          types: types || [],
          limit,
          user: context.user,
        });
      } else {
        // Default search
        results = await this.performDefaultSearch(repository, query, {
          scope: scope || {},
        });
      }

      // Process and enhance results
      const processedResults = await this.processResults(results, {
        query,
        user: context.user,
        limit,
      });

      return {
        success: true,
        data: {
          _results: processedResults,
          totalFound: results.length,
          query,
          metadata: {
            strategy: strategy?.name || 'default',
            limit,
            types: types || [],
            scope: scope || {},
            executionTime: Date.now(),
          },
        },
      };
    } catch (error) {
      logger.error('Memory find operation failed:', error);
      return {
        success: false,
        error: {
          code: 'FIND_OPERATION_FAILED',
          message: error instanceof Error ? error.message : 'Unknown error',
        },
      };
    }
  }

  /**
   * Get search strategies
   */
  public getSearchStrategies(): string[] {
    return Array.from(this.searchStrategies.keys());
  }

  /**
   * Add custom search strategy
   */
  public addSearchStrategy(_name: string,  _strategy: SearchStrategy): void {
    this.searchStrategies.set(name, strategy);
    logger.info(`Search strategy registered: ${name}`);
  }

  /**
   * Get service health status
   */
  public getHealthStatus(): Promise<{
    status: 'healthy' | 'degraded' | 'unhealthy';
    details: unknown;
  }> {
    try {
      const memoryStats = {
        utilization: 0.5, // Mock value for now
        used: 0,
        available: 1024 * 1024 * 1024, // 1GB
        poolStats: {},
      };
      const repository = await getQdrantRepository();

      // Test search functionality
      const searchTest = await repository.searchEntities('health-check-test');

      let status: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';

      if (memoryStats.utilization > 0.9) {
        status = 'unhealthy';
      } else if (memoryStats.utilization > 0.7) {
        status = 'degraded';
      }

      // searchTest is just an array, so the test passes if we get here
      // (if there was an error, it would have been caught above)

      return {
        status,
        details: {
          memory: memoryStats,
          searchTest: true, // Success if we got here
          strategies: this.searchStrategies.size,
          timestamp: new Date().toISOString(),
        },
      };
    } catch (error) {
      return {
        status: 'unhealthy',
        details: {
          error: error instanceof Error ? error.message : 'Unknown error',
          timestamp: new Date().toISOString(),
        },
      };
    }
  }

  /**
   * Shutdown service
   */
  public async shutdown(): Promise<void> {
    try {
      // Memory manager cleanup handled automatically
      this.searchStrategies.clear();
      this.isInitialized = false;
      logger.info('Memory Find Service shutdown completed');
    } catch (error) {
      logger.error('Error during Memory Find Service shutdown:', error);
      throw error;
    }
  }

  // Private methods

  private registerSearchStrategies(): void {
    // Exact match strategy
    this.searchStrategies.set('exact-match',  {
      name: 'exact-match', 
      _execute: async (query: string,  _options) => {
        const repository: IQdrantTypedRepository = await getQdrantRepository();
        try {
          const entities = await repository.searchEntities(`"${query}"`, {
            scope: options.scope,
          });
          return this.convertToSearchResults(entities);
        } catch (error) {
          logger.warn('Entity search failed, trying fallback:', error);
          return [];
        }
      },
    });

    // Fuzzy match strategy
    this.searchStrategies.set('fuzzy-match',  {
      name: 'fuzzy-match', 
      _execute: async (query: string,  _options) => {
        const repository: IQdrantTypedRepository = await getQdrantRepository();
        try {
          const entities = await repository.searchEntities(query, {
            scope: options.scope,
          });
          return this.convertToSearchResults(entities);
        } catch (error) {
          logger.warn('Entity search failed, trying fallback:', error);
          return [];
        }
      },
    });

    // Semantic search strategy (fallback to entity search for now)
    this.searchStrategies.set('semantic-search',  {
      name: 'semantic-search', 
      _execute: async (query: string,  _options) => {
        const repository: IQdrantTypedRepository = await getQdrantRepository();
        try {
          const entities = await repository.searchEntities(query, {
            scope: options.scope,
          });
          return this.convertToSearchResults(entities);
        } catch (error) {
          logger.warn('Entity search failed:', error);
          return [];
        }
      },
    });

    logger.info(`Registered ${this.searchStrategies.size} search strategies`);
  }

  private selectSearchStrategy(_query: string,  types?: string[]): SearchStrategy | null {
    // Simple strategy selection logic
    const queryLength = query.trim().length;

    // Use exact match for short queries or quoted phrases
    if (queryLength < 5 || (query.startsWith('"') && query.endsWith('"'))) {
      return this.searchStrategies.get('exact-match') || null;
    }

    // Use semantic search for longer queries
    if (queryLength > 20) {
      return this.searchStrategies.get('semantic-search') || null;
    }

    // Default to fuzzy match
    return this.searchStrategies.get('fuzzy-match') || null;
  }

  private async performDefaultSearch(
    repository: IQdrantTypedRepository,
    query: string,
    options: { scope?: Record<string, unknown> }
  ): Promise<SearchResult[]> {
    try {
      const entities = await repository.searchEntities(query, {
        scope: options.scope,
      });
      return this.convertToSearchResults(entities);
    } catch (error) {
      logger.warn('Default search failed, returning empty results:', error);
      return [];
    }
  }

  private async processResults(
    _results: SearchResult[],
    options: {
      query: string;
      user?: { id: string };
      limit: number;
    }
  ): Promise<SearchResult[]> {
    const processedResults: EnhancedSearchResult[] = [];

    for (const result of results.slice(0, options.limit)) {
      try {
        // Calculate relevance score
        const relevanceScore = this.calculateRelevanceScore(result, options.query);

        // Enhance result with metadata
        const enhancedResult: EnhancedSearchResult = {
          ...result,
          relevanceScore,
          excerpt: this.generateExcerpt(result, options.query),
          accessLevel: this.determineAccessLevel(result, options.user),
          timestamp: result.created_at || new Date().toISOString(),
        };

        processedResults.push(enhancedResult);
      } catch (error) {
        logger.warn('Failed to process search result:', error);
        // Include original result even if processing fails
        processedResults.push(result);
      }
    }

    // Sort by relevance score (descending)
    return processedResults.sort((a,  _b) => (b.relevanceScore || 0) - (a.relevanceScore || 0));
  }

  private calculateRelevanceScore(result: SearchResult,  _query: string): number {
    let score = 0;

    const resultText = JSON.stringify(result).toLowerCase();
    const queryTerms = query.toLowerCase().split(/\s+/);

    // Score based on term frequency
    for (const term of queryTerms) {
      const frequency = (resultText.match(new RegExp(term, 'g')) || []).length;
      score += frequency * 0.1;
    }

    // Score based on exact phrase match
    if (resultText.includes(query.toLowerCase())) {
      score += 1.0;
    }

    // Score based on title/name match
    const title = (result.data?.title as string) || (result.data?.name as string) || '';
    if (title.toLowerCase().includes(query.toLowerCase())) {
      score += 0.5;
    }

    // Score based on recency (newer items get higher score)
    if (result.created_at) {
      const age = Date.now() - new Date(result.created_at).getTime();
      const ageInDays = age / (1000 * 60 * 60 * 24);
      score += Math.max(0, 1 - ageInDays / 365) * 0.2; // Decay over 1 year
    }

    return Math.round(score * 100) / 100; // Round to 2 decimal places
  }

  private generateExcerpt(result: SearchResult,  _query: string): string {
    const text =
      (result.data?.content as string) ||
      (result.data?.description as string) ||
      JSON.stringify(result.data);
    const queryLower = query.toLowerCase();

    // Find the best matching excerpt
    const index = text.toLowerCase().indexOf(queryLower);
    if (index === -1) {
      // Return first part of content if no direct match
      return text.substring(0, 200) + (text.length > 200 ? '...' : '');
    }

    // Generate excerpt around the match
    const start = Math.max(0, index - 50);
    const end = Math.min(text.length, index + query.length + 50);

    let excerpt = text.substring(start, end);
    if (start > 0) excerpt = '...' + excerpt;
    if (end < text.length) excerpt = excerpt + '...';

    return excerpt;
  }

  private determineAccessLevel(
    result: SearchResult, 
    user?: { id: string }
  ): 'public' | 'internal' | 'restricted' {
    // Simple access level determination
    if (result.scope?.org) {
      return 'restricted';
    }

    if (result.scope?.project && !user) {
      return 'internal';
    }

    return 'public';
  }

  private convertToSearchResults(
    entities: (KnowledgeEntity | KnowledgeObservation)[]
  ): SearchResult[] {
    return entities.map((entity) => ({
      id: entity.id,
      kind: entity.type,
      scope: entity.scope,
      data: {
        ...entity.metadata,
        name: entity.type === 'entity' ? entity.name : undefined,
        description: entity.type === 'entity' ? entity.description : undefined,
        content: entity.type === 'observation' ? entity.content : undefined,
        entityType: entity.type === 'observation' ? entity.entityType : undefined,
        entityId: entity.type === 'observation' ? entity.entityId : undefined,
        confidence: entity.type === 'observation' ? entity.confidence : undefined,
      },
      created_at: entity.createdAt.toISOString(),
      confidence_score: 0.8, // Default confidence for repository results
      match_type: 'semantic' as const,
    }));
  }
}

// Export singleton instance
export const memoryFindService = MemoryFindService.getInstance();
