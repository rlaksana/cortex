/**
 * Memory Manager - P0-CRITICAL Implementation
 *
 * Centralized memory management with LRU/TTL enforcement and metrics.
 * Prevents memory leaks and enforces proper cache limits across the application.
 *
 * @author Cortex Team
 * @version 2.0.1
 * @since 2025
 */

import { logger } from '../../utils/logger.js';
import type { CacheStats } from '../../utils/lru-cache.js';
import { LRUCache } from '../../utils/lru-cache.js';

/**
 * Memory pool configuration
 */
export interface MemoryPoolConfig {
  name: string;
  maxMemoryMB: number;
  maxItems: number;
  defaultTTLMinutes: number;
  cleanupIntervalMinutes: number;
  priority: 'low' | 'medium' | 'high' | 'critical';
}

/**
 * Global memory limits
 */
export interface GlobalMemoryLimits {
  maxTotalMemoryMB: number;
  warningThresholdPercent: number;
  criticalThresholdPercent: number;
  emergencyCleanupPercent: number;
  monitoringIntervalSeconds: number;
}

/**
 * Memory pool metrics
 */
export interface MemoryPoolMetrics {
  name: string;
  currentMemoryMB: number;
  maxMemoryMB: number;
  itemCount: number;
  maxItems: number;
  hitRate: number;
  evictions: number;
  expirations: number;
  priority: string;
  lastCleanup: Date;
  memoryUtilizationPercent: number;
}

/**
 * Memory manager metrics
 */
export interface MemoryManagerMetrics {
  totalMemoryUsedMB: number;
  totalMemoryLimitMB: number;
  globalUtilizationPercent: number;
  poolCount: number;
  totalItems: number;
  totalEvictions: number;
  totalExpirations: number;
  averageHitRate: number;
  pools: MemoryPoolMetrics[];
  lastEmergencyCleanup?: Date;
  memoryPressureLevel: 'normal' | 'warning' | 'critical' | 'emergency';
}

/**
 * Memory-aware cache pool
 */
export class MemoryPool {
  private cache: LRUCache<string, unknown>;
  private lastCleanup = new Date();
  private _metrics: CacheStats;

  constructor(private config: MemoryPoolConfig) {
    this.cache = this.createCache();
    this.metrics = this.cache.getStats();
  }

  private createCache(): LRUCache<string, unknown> {
    return new LRUCache<string, unknown>({
      maxSize: this.config.maxItems,
      maxMemoryBytes: this.config.maxMemoryMB * 1024 * 1024,
      ttlMs: this.config.defaultTTLMinutes * 60 * 1000,
      cleanupIntervalMs: this.config.cleanupIntervalMinutes * 60 * 1000,
      sizeEstimator: this.estimateSize.bind(this),
    });
  }

  private estimateSize(_value: unknown): number {
    if (value === null || value === undefined) return 0;
    if (typeof value === 'string') return value.length * 2;
    if (typeof value === 'number') return 8;
    if (typeof value === 'boolean') return 4;
    if (Array.isArray(value)) return value.length * 64; // Estimate 64 bytes per array item
    if (typeof value === 'object') {
      try {
        return JSON.stringify(value).length * 2;
      } catch {
        return 1024; // Fallback for circular references
      }
    }
    return 64; // Default estimate
  }

  get(_key: string): unknown {
    return this.cache.get(key);
  }

  set(_key: string,  _value: unknown,  ttlMinutes?: number): void {
    const ttlMs = ttlMinutes ? ttlMinutes * 60 * 1000 : undefined;
    this.cache.set(key, value, ttlMs);
    this.updateMetrics();
  }

  has(_key: string): boolean {
    return this.cache.has(key);
  }

  delete(_key: string): boolean {
    const deleted = this.cache.delete(key);
    this.updateMetrics();
    return deleted;
  }

  clear(): void {
    this.cache.clear();
    this.updateMetrics();
  }

  cleanup(): number {
    const cleaned = this.cache.cleanupExpired();
    this.lastCleanup = new Date();
    this.updateMetrics();
    return cleaned;
  }

  getMetrics(): MemoryPoolMetrics {
    this.updateMetrics();
    const stats = this.cache.getStats();

    return {
      name: this.config.name,
      currentMemoryMB: Math.round((stats.memoryUsageBytes / 1024 / 1024) * 100) / 100,
      maxMemoryMB: this.config.maxMemoryMB,
      itemCount: stats.itemCount,
      maxItems: this.config.maxItems,
      hitRate: Math.round(stats.hitRate * 100) / 100,
      evictions: stats.evictedItems,
      expirations: stats.expiredItems,
      priority: this.config.priority,
      lastCleanup: this.lastCleanup,
      memoryUtilizationPercent:
        Math.round((stats.memoryUsageBytes / (this.config.maxMemoryMB * 1024 * 1024)) * 10000) /
        100,
    };
  }

  private updateMetrics(): void {
    this.metrics = this.cache.getStats();
  }

  getPriority(): string {
    return this.config.priority;
  }

  getMaxMemoryMB(): number {
    return this.config.maxMemoryMB;
  }

  forceEvict(_count: number): number {
    let evicted = 0;
    const keys = this.cache.keys().slice(-count); // Get least recently used items

    for (const key of keys) {
      if (this.cache.delete(key)) {
        evicted++;
      }
    }

    return evicted;
  }

  destroy(): void {
    this.cache.destroy();
  }
}

/**
 * Centralized Memory Manager
 */
export class MemoryManager {
  private static instance: MemoryManager;
  private pools = new Map<string, MemoryPool>();
  private monitoringTimer: NodeJS.Timeout | null = null;
  private globalLimits: GlobalMemoryLimits;

  // Default memory limits (can be overridden by environment)
  private defaultLimits: GlobalMemoryLimits = {
    maxTotalMemoryMB: 512, // 512MB total cache memory
    warningThresholdPercent: 70,
    criticalThresholdPercent: 85,
    emergencyCleanupPercent: 90,
    monitoringIntervalSeconds: 30,
  };

  private constructor() {
    this.globalLimits = this.loadGlobalLimits();
    this.startMonitoring();
  }

  static getInstance(): MemoryManager {
    if (!MemoryManager.instance) {
      MemoryManager.instance = new MemoryManager();
    }
    return MemoryManager.instance;
  }

  private loadGlobalLimits(): GlobalMemoryLimits {
    return {
      maxTotalMemoryMB: parseInt(process.env.MEMORY_MANAGER_MAX_MB || '512', 10),
      warningThresholdPercent: parseInt(process.env.MEMORY_WARNING_PERCENT || '70', 10),
      criticalThresholdPercent: parseInt(process.env.MEMORY_CRITICAL_PERCENT || '85', 10),
      emergencyCleanupPercent: parseInt(process.env.MEMORY_EMERGENCY_PERCENT || '90', 10),
      monitoringIntervalSeconds: parseInt(process.env.MEMORY_MONITOR_INTERVAL_SECONDS || '30', 10),
    };
  }

  /**
   * Create or get a memory pool
   */
  getOrCreatePool(config: MemoryPoolConfig): MemoryPool {
    if (this.pools.has(config.name)) {
      return this.pools.get(config.name)!;
    }

    // Enforce global memory limits
    const currentUsage = this.getTotalMemoryUsageMB();
    const newPoolMemory = config.maxMemoryMB;

    if (currentUsage + newPoolMemory > this.globalLimits.maxTotalMemoryMB) {
      logger.warn(`Memory pool ${config.name} would exceed global memory limits`, {
        requestedMB: newPoolMemory,
        currentUsageMB: currentUsage,
        limitMB: this.globalLimits.maxTotalMemoryMB,
      });

      // Try to free up memory first
      this.emergencyCleanup();

      if (this.getTotalMemoryUsageMB() + newPoolMemory > this.globalLimits.maxTotalMemoryMB) {
        throw new Error(
          `Insufficient memory for pool ${config.name}. Requested: ${newPoolMemory}MB, Available: ${this.globalLimits.maxTotalMemoryMB - this.getTotalMemoryUsageMB()}MB`
        );
      }
    }

    const pool = new MemoryPool(config);
    this.pools.set(config.name, pool);

    logger.info(`Created memory pool: ${config.name}`, {
      maxMemoryMB: config.maxMemoryMB,
      maxItems: config.maxItems,
      priority: config.priority,
    });

    return pool;
  }

  /**
   * Get existing memory pool
   */
  getPool(_name: string): MemoryPool | undefined {
    return this.pools.get(name);
  }

  /**
   * Remove a memory pool
   */
  removePool(_name: string): boolean {
    const pool = this.pools.get(name);
    if (_pool) {
      pool.destroy();
      this.pools.delete(name);
      logger.info(`Removed memory pool: ${name}`);
      return true;
    }
    return false;
  }

  /**
   * Get comprehensive memory metrics
   */
  getMetrics(): MemoryManagerMetrics {
    const poolMetrics = Array.from(this.pools.values()).map((pool) => pool.getMetrics());
    const totalMemoryUsed = poolMetrics.reduce((sum,  _pool) => sum + pool.currentMemoryMB, 0);
    const totalItems = poolMetrics.reduce((sum,  _pool) => sum + pool.itemCount, 0);
    const totalEvictions = poolMetrics.reduce((sum,  _pool) => sum + pool.evictions, 0);
    const totalExpirations = poolMetrics.reduce((sum,  _pool) => sum + pool.expirations, 0);
    const averageHitRate =
      poolMetrics.length > 0
        ? poolMetrics.reduce((sum,  _pool) => sum + pool.hitRate, 0) / poolMetrics.length
        : 0;

    const utilizationPercent = (totalMemoryUsed / this.globalLimits.maxTotalMemoryMB) * 100;
    let memoryPressureLevel: 'normal' | 'warning' | 'critical' | 'emergency' = 'normal';

    if (utilizationPercent >= this.globalLimits.emergencyCleanupPercent) {
      memoryPressureLevel = 'emergency';
    } else if (utilizationPercent >= this.globalLimits.criticalThresholdPercent) {
      memoryPressureLevel = 'critical';
    } else if (utilizationPercent >= this.globalLimits.warningThresholdPercent) {
      memoryPressureLevel = 'warning';
    }

    return {
      totalMemoryUsedMB: Math.round(totalMemoryUsed * 100) / 100,
      totalMemoryLimitMB: this.globalLimits.maxTotalMemoryMB,
      globalUtilizationPercent: Math.round(utilizationPercent * 100) / 100,
      poolCount: this.pools.size,
      totalItems,
      totalEvictions,
      totalExpirations,
      averageHitRate: Math.round(averageHitRate * 100) / 100,
      pools: poolMetrics,
      memoryPressureLevel,
    };
  }

  /**
   * Get total memory usage across all pools
   */
  getTotalMemoryUsageMB(): number {
    return Array.from(this.pools.values()).reduce(
      (total,  _pool) => total + pool.getMetrics().currentMemoryMB,
      0
    );
  }

  /**
   * Perform emergency cleanup
   */
  emergencyCleanup(): void {
    logger.warn('Performing emergency memory cleanup');

    const sortedPools = Array.from(this.pools.values()).sort((a,  _b) => {
      // Clean up low priority pools first
      const priorityOrder = { low: 1, medium: 2, high: 3, critical: 4 };
      return (
        priorityOrder[a.getPriority() as keyof typeof priorityOrder] -
        priorityOrder[b.getPriority() as keyof typeof priorityOrder]
      );
    });

    let totalFreedMB = 0;
    const targetFreeMB = this.globalLimits.maxTotalMemoryMB * 0.2; // Free 20%

    for (const pool of sortedPools) {
      if (totalFreedMB >= targetFreeMB) break;

      const beforeMemory = pool.getMetrics().currentMemoryMB;
      const evictedCount = Math.floor(pool.getMetrics().itemCount * 0.3); // Evict 30% of items
      pool.forceEvict(evictedCount);

      const afterMemory = pool.getMetrics().currentMemoryMB;
      const freedMB = beforeMemory - afterMemory;
      totalFreedMB += freedMB;

      logger.info(`Emergency cleanup in pool ${pool.getMetrics().name}`, {
        evictedItems: evictedCount,
        freedMB: Math.round(freedMB * 100) / 100,
      });
    }

    logger.warn('Emergency cleanup completed', {
      totalFreedMB: Math.round(totalFreedMB * 100) / 100,
      targetFreeMB: Math.round(targetFreeMB * 100) / 100,
      currentUsageMB: Math.round(this.getTotalMemoryUsageMB() * 100) / 100,
    });
  }

  /**
   * Cleanup expired items across all pools
   */
  cleanupAllPools(): number {
    let totalCleaned = 0;

    for (const pool of this.pools.values()) {
      const cleaned = pool.cleanup();
      totalCleaned += cleaned;
    }

    if (totalCleaned > 0) {
      logger.debug('Cleanup completed across all pools', { totalCleaned });
    }

    return totalCleaned;
  }

  /**
   * Get memory pool by priority
   */
  getPoolsByPriority(_priority: string): MemoryPool[] {
    return Array.from(this.pools.values()).filter((pool) => pool.getPriority() === priority);
  }

  /**
   * Update global memory limits
   */
  updateGlobalLimits(_limits: Partial<GlobalMemoryLimits>): void {
    this.globalLimits = { ...this.globalLimits, ...limits };
    logger.info('Updated global memory limits', this.globalLimits);
  }

  /**
   * Start memory monitoring
   */
  private startMonitoring(): void {
    this.monitoringTimer = setInterval(() => {
      this.performMonitoringCheck();
    }, this.globalLimits.monitoringIntervalSeconds * 1000);
  }

  /**
   * Perform periodic monitoring check
   */
  private performMonitoringCheck(): void {
    const metrics = this.getMetrics();
    const utilization = metrics.globalUtilizationPercent;

    // Log current state
    if (utilization >= this.globalLimits.emergencyCleanupPercent) {
      logger.error('Memory usage at emergency level', {
        utilization: `${utilization}%`,
        usedMB: metrics.totalMemoryUsedMB,
        limitMB: metrics.totalMemoryLimitMB,
      });
      this.emergencyCleanup();
    } else if (utilization >= this.globalLimits.criticalThresholdPercent) {
      logger.warn('Memory usage at critical level', {
        utilization: `${utilization}%`,
        usedMB: metrics.totalMemoryUsedMB,
      });
      this.cleanupAllPools();
    } else if (utilization >= this.globalLimits.warningThresholdPercent) {
      logger.info('Memory usage at warning level', {
        utilization: `${utilization}%`,
        usedMB: metrics.totalMemoryUsedMB,
      });
    }

    // Emit metrics for monitoring systems
    this.emitMetrics(metrics);
  }

  /**
   * Emit metrics to monitoring systems
   */
  private emitMetrics(_metrics: MemoryManagerMetrics): void {
    // This could be integrated with Prometheus, CloudWatch, etc.
    try {
      // Emit metrics via custom event
      (globalThis as unknown).dispatchEvent?.(
        new CustomEvent('memory-metrics', { detail: metrics })
      );

      // Alternative: Simple console-based metrics for now
      if (process.env.NODE_ENV === 'development') {
        console.debug('Memory Metrics:', {
          utilization: `${String(metrics.globalUtilizationPercent.toFixed(1))}%`,
          pools: metrics.poolCount,
          items: metrics.totalItems,
        });
      }
    } catch (error) {
      logger.debug('Failed to emit memory metrics', error);
    }
  }

  /**
   * Shutdown memory manager
   */
  shutdown(): void {
    if (this.monitoringTimer) {
      clearInterval(this.monitoringTimer);
      this.monitoringTimer = null;
    }

    for (const pool of this.pools.values()) {
      pool.destroy();
    }
    this.pools.clear();

    logger.info('Memory manager shutdown completed');
  }
}

/**
 * Memory Manager Factory
 */
export class MemoryManagerFactory {
  /**
   * Create predefined memory pools
   */
  static createStandardPools(_memoryManager: MemoryManager): void {
    // Search results cache - high priority
    memoryManager.getOrCreatePool({
      name: 'search-results',
      maxMemoryMB: 50,
      maxItems: 1000,
      defaultTTLMinutes: 5,
      cleanupIntervalMinutes: 1,
      priority: 'high',
    });

    // Embeddings cache - medium priority
    memoryManager.getOrCreatePool({
      name: 'embeddings',
      maxMemoryMB: 100,
      maxItems: 500,
      defaultTTLMinutes: 60,
      cleanupIntervalMinutes: 5,
      priority: 'medium',
    });

    // User sessions - high priority
    memoryManager.getOrCreatePool({
      name: 'user-sessions',
      maxMemoryMB: 20,
      maxItems: 10000,
      defaultTTLMinutes: 30,
      cleanupIntervalMinutes: 10,
      priority: 'high',
    });

    // Configuration cache - critical priority
    memoryManager.getOrCreatePool({
      name: 'configuration',
      maxMemoryMB: 10,
      maxItems: 500,
      defaultTTLMinutes: 1440, // 24 hours
      cleanupIntervalMinutes: 60,
      priority: 'critical',
    });

    // AI responses - medium priority
    memoryManager.getOrCreatePool({
      name: 'ai-responses',
      maxMemoryMB: 80,
      maxItems: 2000,
      defaultTTLMinutes: 15,
      cleanupIntervalMinutes: 3,
      priority: 'medium',
    });

    // Temporary computations - low priority
    memoryManager.getOrCreatePool({
      name: 'temporary',
      maxMemoryMB: 30,
      maxItems: 100,
      defaultTTLMinutes: 2,
      cleanupIntervalMinutes: 1,
      priority: 'low',
    });
  }
}

/**
 * Global memory manager accessor
 */
export const memoryManager = MemoryManager.getInstance();
