/**
 * High-Performance Deduplication Service
 *
 * Implements comprehensive deduplication strategies with performance optimization:
 * - Multiple deduplication strategies (skip/prefer_existing/prefer_newer/combine/intelligent)
 * - Performance targets: <50ms per comparison
 * - Advanced similarity algorithms
 * - Configurable thresholds and strategies
 * - Comprehensive error handling and monitoring
 *
 * @author Cortex Team
 * @version 2.0.1
 * @since 2025
 */

import { logger } from '../../utils/logger.js';
import { PerformanceMonitor } from '../core/performance-monitor.js';

/**
 * Deduplication strategy options
 */
export type DeduplicationStrategy =
  | 'skip' // Skip storing duplicates
  | 'prefer_existing' // Keep existing item, discard new
  | 'prefer_newer' // Keep new item, replace existing
  | 'combine' // Merge/combine items intelligently
  | 'intelligent'; // Use ML/heuristics to decide

/**
 * Similarity algorithm options
 */
export type SimilarityAlgorithm =
  | 'exact' // Exact match only
  | 'fuzzy' // Fuzzy string matching
  | 'semantic' // Semantic similarity
  | 'hybrid'; // Combine multiple approaches

/**
 * Item comparison result with performance metrics
 */
export interface ComparisonResult {
  /** Whether items are considered duplicates */
  isDuplicate: boolean;

  /** Similarity score (0-1) */
  similarityScore: number;

  /** Confidence in the duplicate detection (0-1) */
  confidence: number;

  /** Details about the comparison */
  details: {
    /** Algorithm used */
    algorithm: SimilarityAlgorithm;
    /** Matching fields */
    matchingFields: string[];
    /** Conflicting fields */
    conflictingFields: string[];
    /** Reasoning for the decision */
    reasoning: string;
  };

  /** Performance timing */
  timing: {
    /** Comparison time in ms */
    comparisonTime: number;
    /** Memory usage in bytes */
    memoryUsage: number;
  };
}

/**
 * Deduplication result with action taken
 */
export interface DeduplicationResult {
  /** Action taken */
  action: 'skipped' | 'kept_existing' | 'replaced_with_new' | 'combined' | 'created_new';

  /** Final item (result of deduplication) */
  finalItem: unknown;

  /** Original items involved */
  items: {
    /** New item being processed */
    newItem: unknown;
    /** Existing item found (if any) */
    existingItem?: unknown;
  };

  /** Comparison result (if duplicate was found) */
  comparison?: ComparisonResult;

  /** Metadata about the deduplication process */
  metadata: {
    /** Strategy used */
    strategy: DeduplicationStrategy;
    /** Processing time in ms */
    processingTime: number;
    /** Memory usage in bytes */
    memoryUsage: number;
    /** Timestamp */
    timestamp: string;
  };
}

/**
 * Deduplication configuration
 */
export interface DeduplicationConfig {
  /** Primary deduplication strategy */
  strategy: DeduplicationStrategy;

  /** Similarity algorithm to use */
  similarityAlgorithm: SimilarityAlgorithm;

  /** Similarity threshold (0-1) */
  similarityThreshold: number;

  /** Confidence threshold (0-1) */
  confidenceThreshold: number;

  /** Fields to consider for comparison */
  comparisonFields: string[];

  /** Field weights for similarity calculation */
  fieldWeights?: Record<string, number>;

  /** Performance optimization settings */
  performance?: {
    /** Enable caching of comparison results */
    enableCaching: boolean;
    /** Maximum cache size */
    maxCacheSize: number;
    /** Enable parallel processing */
    enableParallel: boolean;
    /** Batch size for parallel processing */
    batchSize: number;
  };

  /** Type-specific configurations */
  typeConfigs?: Record<
    string,
    {
      strategy?: DeduplicationStrategy;
      similarityThreshold?: number;
      comparisonFields?: string[];
      fieldWeights?: Record<string, number>;
    }
  >;
}

/**
 * Default deduplication configuration
 */
export const DEFAULT_DEDUPLICATION_CONFIG: DeduplicationConfig = {
  strategy: 'intelligent',
  similarityAlgorithm: 'hybrid',
  similarityThreshold: 0.8,
  confidenceThreshold: 0.7,
  comparisonFields: ['title', 'name', 'description', 'content', 'id'],
  fieldWeights: {
    title: 0.3,
    name: 0.3,
    id: 0.25,
    description: 0.1,
    content: 0.05,
  },
  performance: {
    enableCaching: true,
    maxCacheSize: 10000,
    enableParallel: true,
    batchSize: 10,
  },
};

/**
 * High-Performance Deduplication Service
 */
export class HighPerformanceDeduplicationService {
  private static instance: HighPerformanceDeduplicationService;
  private performanceMonitor: PerformanceMonitor;
  private comparisonCache: Map<string, ComparisonResult> = new Map();
  private isInitialized = false;

  private constructor() {
    this.performanceMonitor = PerformanceMonitor.getInstance();
  }

  public static getInstance(): HighPerformanceDeduplicationService {
    if (!HighPerformanceDeduplicationService.instance) {
      HighPerformanceDeduplicationService.instance = new HighPerformanceDeduplicationService();
    }
    return HighPerformanceDeduplicationService.instance;
  }

  /**
   * Initialize the deduplication service
   */
  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    try {
      logger.info('Initializing High-Performance Deduplication Service...');

      // Initialize any required resources
      await this.initializeSimilarityModels();

      this.isInitialized = true;
      logger.info('High-Performance Deduplication Service initialized successfully');
    } catch (error) {
      logger.error('Failed to initialize High-Performance Deduplication Service:', error);
      throw error;
    }
  }

  /**
   * Process a new item for deduplication against existing items
   */
  public async processItem(
    newItem: unknown,
    existingItems: unknown[],
    config: Partial<DeduplicationConfig> = {}
  ): Promise<DeduplicationResult> {
    const startTime = Date.now();
    const startMemory = process.memoryUsage().heapUsed;

    try {
      const finalConfig = { ...DEFAULT_DEDUPLICATION_CONFIG, ...config };

      logger.debug(`Processing item deduplication with strategy: ${finalConfig.strategy}`);

      // Validate inputs
      if (!newItem || typeof newItem !== 'object') {
        throw new Error('New item must be a valid object');
      }

      if (!Array.isArray(existingItems)) {
        throw new Error('Existing items must be an array');
      }

      // Get type-specific configuration
      const typeConfig = this.getTypeSpecificConfig(newItem.kind, finalConfig);

      // Find duplicates
      const duplicateResult = await this.findDuplicates(newItem, existingItems, typeConfig);

      // Apply deduplication strategy
      const result = await this.applyDeduplicationStrategy(
        newItem,
        existingItems,
        duplicateResult,
        typeConfig
      );

      // Calculate performance metrics
      const endTime = Date.now();
      const endMemory = process.memoryUsage().heapUsed;

      result.metadata.processingTime = endTime - startTime;
      result.metadata.memoryUsage = endMemory - startMemory;
      result.metadata.timestamp = new Date().toISOString();

      // Check performance targets
      if (result.metadata.processingTime > 50) {
        logger.warn(
          `Deduplication performance target exceeded: ${result.metadata.processingTime}ms > 50ms`
        );
      }

      // Record performance metrics
      this.performanceMonitor.recordMetrics({
        timestamp: new Date(),
        service: 'deduplication',
        operation: finalConfig.strategy,
        duration: result.metadata.processingTime,
        success: true,
        memoryUsage: {
          heapUsed: result.metadata.memoryUsage,
          heapTotal: result.metadata.memoryUsage,
          external: 0,
          arrayBuffers: 0,
          rss: result.metadata.memoryUsage,
        },
      });

      logger.debug(
        `Deduplication completed: ${result.action} in ${result.metadata.processingTime}ms`
      );
      return result;
    } catch (error) {
      logger.error('Item deduplication failed:', error);
      throw error;
    }
  }

  /**
   * Process multiple items in batch with performance optimization
   */
  public async processItems(
    newItems: unknown[],
    existingItems: unknown[],
    config: Partial<DeduplicationConfig> = {}
  ): Promise<DeduplicationResult[]> {
    const finalConfig = { ...DEFAULT_DEDUPLICATION_CONFIG, ...config };

    if (!finalConfig.performance?.enableParallel || newItems.length <= 1) {
      // Process sequentially
      const _results: DeduplicationResult[] = [];
      const currentExisting = [...existingItems];

      for (const newItem of newItems) {
        const result = await this.processItem(newItem, currentExisting, config);
        results.push(result);

        // Update existing items based on result
        if (result.action === 'created_new' || result.action === 'replaced_with_new') {
          currentExisting.push(result.finalItem);
        } else if (result.action === 'combined') {
          const existingIndex = currentExisting.findIndex(
            (item) => item.id === result.items.existingItem?.id
          );
          if (existingIndex >= 0) {
            currentExisting[existingIndex] = result.finalItem;
          }
        }
      }

      return results;
    }

    // Process in parallel batches
    const batchSize = finalConfig.performance.batchSize || 10;
    const _results: DeduplicationResult[] = [];
    const currentExisting = [...existingItems];

    for (let i = 0; i < newItems.length; i += batchSize) {
      const batch = newItems.slice(i, i + batchSize);
      const batchPromises = batch.map(async (newItem) => {
        return await this.processItem(newItem, currentExisting, config);
      });

      const batchResults = await Promise.all(batchPromises);
      results.push(...batchResults);

      // Update existing items for next batch
      for (const result of batchResults) {
        if (result.action === 'created_new' || result.action === 'replaced_with_new') {
          currentExisting.push(result.finalItem);
        } else if (result.action === 'combined') {
          const existingIndex = currentExisting.findIndex(
            (item) => item.id === result.items.existingItem?.id
          );
          if (existingIndex >= 0) {
            currentExisting[existingIndex] = result.finalItem;
          }
        }
      }
    }

    return results;
  }

  /**
   * Compare two items for similarity with performance optimization
   */
  public async compareItems(
    item1: unknown,
    item2: unknown,
    config: Partial<DeduplicationConfig> = {}
  ): Promise<ComparisonResult> {
    const startTime = Date.now();
    const startMemory = process.memoryUsage().heapUsed;

    try {
      const finalConfig = { ...DEFAULT_DEDUPLICATION_CONFIG, ...config };

      // Check cache first
      const cacheKey = this.generateCacheKey(item1, item2);
      if (finalConfig.performance?.enableCaching && this.comparisonCache.has(cacheKey)) {
        const cachedResult = this.comparisonCache.get(cacheKey)!;
        return cachedResult;
      }

      // Perform comparison based on algorithm
      let comparisonResult: ComparisonResult;

      switch (finalConfig.similarityAlgorithm) {
        case 'exact':
          comparisonResult = this.exactComparison(item1, item2, finalConfig);
          break;
        case 'fuzzy':
          comparisonResult = this.fuzzyComparison(item1, item2, finalConfig);
          break;
        case 'semantic':
          comparisonResult = await this.semanticComparison(item1, item2, finalConfig);
          break;
        case 'hybrid':
          comparisonResult = await this.hybridComparison(item1, item2, finalConfig);
          break;
        default:
          throw new Error(`Unsupported similarity algorithm: ${finalConfig.similarityAlgorithm}`);
      }

      // Calculate timing
      const endTime = Date.now();
      const endMemory = process.memoryUsage().heapUsed;
      comparisonResult.timing = {
        comparisonTime: endTime - startTime,
        memoryUsage: endMemory - startMemory,
      };

      // Cache result if enabled
      if (finalConfig.performance?.enableCaching) {
        this.cacheComparisonResult(
          cacheKey,
          comparisonResult,
          finalConfig.performance.maxCacheSize
        );
      }

      return comparisonResult;
    } catch (error) {
      logger.error('Item comparison failed:', error);
      throw error;
    }
  }

  /**
   * Clear comparison cache
   */
  public clearCache(): void {
    this.comparisonCache.clear();
    logger.debug('Deduplication cache cleared');
  }

  /**
   * Get cache statistics
   */
  public getCacheStats(): { size: number; maxSize: number; hitRate?: number } {
    return {
      size: this.comparisonCache.size,
      maxSize: DEFAULT_DEDUPLICATION_CONFIG.performance?.maxCacheSize || 10000,
    };
  }

  // Private methods

  private async initializeSimilarityModels(): Promise<void> {
    // Initialize any ML models or similarity algorithms
    logger.debug('Similarity models initialized');
  }

  private getTypeSpecificConfig(
    _itemKind: string, 
    _baseConfig: DeduplicationConfig
  ): DeduplicationConfig {
    const typeConfig = baseConfig.typeConfigs?.[itemKind];
    if (!typeConfig) {
      return baseConfig;
    }

    return {
      ...baseConfig,
      ...typeConfig,
      fieldWeights: {
        ...baseConfig.fieldWeights,
        ...typeConfig.fieldWeights,
      },
    };
  }

  private async findDuplicates(
    newItem: unknown,
    existingItems: unknown[],
    config: DeduplicationConfig
  ): Promise<ComparisonResult | null> {
    let bestMatch: ComparisonResult | null = null;

    for (const existingItem of existingItems) {
      const comparison = await this.compareItems(newItem, existingItem, config);

      if (
        comparison.isDuplicate &&
        comparison.similarityScore >= config.similarityThreshold &&
        comparison.confidence >= config.confidenceThreshold
      ) {
        if (!bestMatch || comparison.similarityScore > bestMatch.similarityScore) {
          bestMatch = comparison;
        }
      }
    }

    return bestMatch;
  }

  private async applyDeduplicationStrategy(
    newItem: unknown,
    existingItems: unknown[],
    duplicateResult: ComparisonResult | null,
    config: DeduplicationConfig
  ): Promise<DeduplicationResult> {
    const baseResult = {
      items: { newItem },
      metadata: {
        strategy: config.strategy,
        processingTime: 0,
        memoryUsage: 0,
        timestamp: new Date().toISOString(),
      },
    };

    // If no duplicate found, create new item
    if (!duplicateResult) {
      return {
        ...baseResult,
        action: 'created_new',
        finalItem: newItem,
      };
    }

    const existingItem =
      duplicateResult.details.conflictingFields.length > 0
        ? existingItems.find((item) => this.matchesComparisonResult(item, duplicateResult))
        : existingItems[0];

    const itemsWithExisting = {
      newItem,
      existingItem,
    };

    // Apply strategy
    switch (config.strategy) {
      case 'skip':
        return {
          ...baseResult,
          items: itemsWithExisting,
          action: 'skipped',
          finalItem: existingItem,
          comparison: duplicateResult,
        };

      case 'prefer_existing':
        return {
          ...baseResult,
          action: 'kept_existing',
          finalItem: existingItem,
          comparison: duplicateResult,
        };

      case 'prefer_newer':
        return {
          ...baseResult,
          action: 'replaced_with_new',
          finalItem: newItem,
          comparison: duplicateResult,
        };

      case 'combine': {
        const combinedItem = await this.combineItems(newItem, existingItem, duplicateResult);
        return {
          ...baseResult,
          action: 'combined',
          finalItem: combinedItem,
          comparison: duplicateResult,
        };
      }

      case 'intelligent':
        return await this.intelligentResolution(newItem, existingItem, duplicateResult, config);

      default:
        throw new Error(`Unsupported deduplication strategy: ${config.strategy}`);
    }
  }

  private exactComparison(
    _item1: unknown, 
    _item2: unknown, 
    config: DeduplicationConfig
  ): ComparisonResult {
    const matchingFields: string[] = [];
    const conflictingFields: string[] = [];
    let totalScore = 0;
    let totalWeight = 0;

    for (const field of config.comparisonFields) {
      const weight = config.fieldWeights?.[field] || 1;
      const value1 = this.getFieldValue(item1, field);
      const value2 = this.getFieldValue(item2, field);

      if (value1 === value2) {
        matchingFields.push(field);
        totalScore += weight;
      } else if (value1 !== null && value2 !== null) {
        conflictingFields.push(field);
      }
      totalWeight += weight;
    }

    const similarityScore = totalWeight > 0 ? totalScore / totalWeight : 0;
    const isDuplicate = similarityScore === 1;

    return {
      isDuplicate,
      similarityScore,
      confidence: isDuplicate ? 1.0 : similarityScore,
      details: {
        algorithm: 'exact',
        matchingFields,
        conflictingFields,
        reasoning: isDuplicate
          ? 'Exact match on all compared fields'
          : `Similarity: ${similarityScore}`,
      },
      timing: { comparisonTime: 0, memoryUsage: 0 },
    };
  }

  private fuzzyComparison(
    _item1: unknown, 
    _item2: unknown, 
    config: DeduplicationConfig
  ): ComparisonResult {
    const matchingFields: string[] = [];
    const conflictingFields: string[] = [];
    let totalScore = 0;
    let totalWeight = 0;

    for (const field of config.comparisonFields) {
      const weight = config.fieldWeights?.[field] || 1;
      const value1 = this.getFieldValue(item1, field);
      const value2 = this.getFieldValue(item2, field);

      if (value1 !== null && value2 !== null) {
        const similarity = this.calculateStringSimilarity(String(value1), String(value2));
        totalScore += similarity * weight;

        if (similarity > 0.8) {
          matchingFields.push(field);
        } else {
          conflictingFields.push(field);
        }
      } else if (value1 === value2) {
        matchingFields.push(field);
        totalScore += weight;
      }
      totalWeight += weight;
    }

    const similarityScore = totalWeight > 0 ? totalScore / totalWeight : 0;
    const isDuplicate = similarityScore >= config.similarityThreshold;

    return {
      isDuplicate,
      similarityScore,
      confidence: Math.min(similarityScore + 0.1, 1.0),
      details: {
        algorithm: 'fuzzy',
        matchingFields,
        conflictingFields,
        reasoning: `Fuzzy similarity: ${String(similarityScore.toFixed(3))}`,
      },
      timing: { comparisonTime: 0, memoryUsage: 0 },
    };
  }

  private async semanticComparison(
    item1: unknown,
    item2: unknown,
    config: DeduplicationConfig
  ): Promise<ComparisonResult> {
    // Simplified semantic comparison - in production, would use actual semantic models
    const matchingFields: string[] = [];
    const conflictingFields: string[] = [];
    let totalScore = 0;
    let totalWeight = 0;

    for (const field of config.comparisonFields) {
      const weight = config.fieldWeights?.[field] || 1;
      const value1 = this.getFieldValue(item1, field);
      const value2 = this.getFieldValue(item2, field);

      if (value1 !== null && value2 !== null) {
        // Simplified semantic similarity
        const semanticSimilarity = this.calculateSemanticSimilarity(String(value1), String(value2));
        totalScore += semanticSimilarity * weight;

        if (semanticSimilarity > 0.7) {
          matchingFields.push(field);
        } else {
          conflictingFields.push(field);
        }
      } else if (value1 === value2) {
        matchingFields.push(field);
        totalScore += weight;
      }
      totalWeight += weight;
    }

    const similarityScore = totalWeight > 0 ? totalScore / totalWeight : 0;
    const isDuplicate = similarityScore >= config.similarityThreshold;

    return {
      isDuplicate,
      similarityScore,
      confidence: Math.min(similarityScore + 0.15, 1.0),
      details: {
        algorithm: 'semantic',
        matchingFields,
        conflictingFields,
        reasoning: `Semantic similarity: ${String(similarityScore.toFixed(3))}`,
      },
      timing: { comparisonTime: 0, memoryUsage: 0 },
    };
  }

  private async hybridComparison(
    item1: unknown,
    item2: unknown,
    config: DeduplicationConfig
  ): Promise<ComparisonResult> {
    // Combine multiple comparison methods
    const exact = this.exactComparison(item1, item2, config);
    const fuzzy = this.fuzzyComparison(item1, item2, config);
    const semantic = await this.semanticComparison(item1, item2, config);

    // Weighted combination
    const weights = { exact: 0.4, fuzzy: 0.3, semantic: 0.3 };
    const similarityScore =
      exact.similarityScore * weights.exact +
      fuzzy.similarityScore * weights.fuzzy +
      semantic.similarityScore * weights.semantic;

    const isDuplicate = similarityScore >= config.similarityThreshold;
    const confidence = Math.min(similarityScore + 0.2, 1.0);

    return {
      isDuplicate,
      similarityScore,
      confidence,
      details: {
        algorithm: 'hybrid',
        matchingFields: [
          ...new Set([...exact.details.matchingFields, ...fuzzy.details.matchingFields]),
        ],
        conflictingFields: [
          ...new Set([...exact.details.conflictingFields, ...fuzzy.details.conflictingFields]),
        ],
        reasoning: `Hybrid similarity: ${String(similarityScore.toFixed(3))} (exact: ${String(exact.similarityScore.toFixed(3))}, fuzzy: ${String(fuzzy.similarityScore.toFixed(3))}, semantic: ${String(semantic.similarityScore.toFixed(3))})`,
      },
      timing: { comparisonTime: 0, memoryUsage: 0 },
    };
  }

  private async combineItems(
    newItem: unknown,
    existingItem: unknown,
    comparison: ComparisonResult
  ): Promise<unknown> {
    // Intelligent combination of items
    const combined = { ...existingItem };

    // Keep newer timestamps
    if (newItem.timestamp && existingItem.timestamp) {
      combined.timestamp =
        new Date(newItem.timestamp) > new Date(existingItem.timestamp)
          ? newItem.timestamp
          : existingItem.timestamp;
    }

    // Merge data, preferring non-null values
    combined.data = { ...existingItem.data, ...newItem.data };

    // Merge metadata
    combined.metadata = {
      ...existingItem.metadata,
      ...newItem.metadata,
      combined: true,
      originalIds: [existingItem.id, newItem.id],
      combinedAt: new Date().toISOString(),
      combinationReason: comparison.details.reasoning,
    };

    return combined;
  }

  private async intelligentResolution(
    newItem: unknown,
    existingItem: unknown,
    comparison: ComparisonResult,
    config: DeduplicationConfig
  ): Promise<DeduplicationResult> {
    // Intelligent decision based on multiple factors
    const factors = {
      similarity: comparison.similarityScore,
      confidence: comparison.confidence,
      recency: this.compareRecency(newItem, existingItem),
      completeness: this.compareCompleteness(newItem, existingItem),
    };

    let action: DeduplicationResult['action'];
    let finalItem: unknown;

    // Decision logic
    if (factors.similarity > 0.95 && factors.confidence > 0.9) {
      // Very high similarity - keep the more complete/recent one
      if (factors.recency > 0 || factors.completeness > 0) {
        action = 'replaced_with_new';
        finalItem = newItem;
      } else {
        action = 'kept_existing';
        finalItem = existingItem;
      }
    } else if (factors.similarity > 0.8 && factors.confidence > 0.7) {
      // High similarity but some differences - combine
      action = 'combined';
      finalItem = await this.combineItems(newItem, existingItem, comparison);
    } else if (factors.similarity > config.similarityThreshold) {
      // Moderate similarity - keep newer
      if (factors.recency > 0) {
        action = 'replaced_with_new';
        finalItem = newItem;
      } else {
        action = 'kept_existing';
        finalItem = existingItem;
      }
    } else {
      // Below threshold - create new
      action = 'created_new';
      finalItem = newItem;
    }

    return {
      items: { newItem, existingItem },
      action,
      finalItem,
      comparison,
      metadata: {
        strategy: 'intelligent',
        processingTime: 0,
        memoryUsage: 0,
        timestamp: new Date().toISOString(),
        decisionFactors: factors,
      },
    };
  }

  private getFieldValue(_item: unknown,  _field: string): unknown {
    return item.data?.[field] ?? item[field] ?? null;
  }

  private calculateStringSimilarity(_str1: string,  _str2: string): number {
    // Levenshtein distance-based similarity
    const longer = str1.length > str2.length ? str1 : str2;
    const shorter = str1.length > str2.length ? str2 : str1;

    if (longer.length === 0) return 1.0;

    const distance = this.levenshteinDistance(longer, shorter);
    return (longer.length - distance) / longer.length;
  }

  private calculateSemanticSimilarity(_str1: string,  _str2: string): number {
    // Simplified semantic similarity - in production would use actual embeddings
    const words1 = new Set(str1.toLowerCase().split(/\s+/));
    const words2 = new Set(str2.toLowerCase().split(/\s+/));

    const intersection = new Set([...words1].filter((word) => words2.has(word)));
    const union = new Set([...words1, ...words2]);

    return union.size > 0 ? intersection.size / union.size : 0;
  }

  private levenshteinDistance(_str1: string,  _str2: string): number {
    const matrix = Array(str2.length + 1)
      .fill(null)
      .map(() => Array(str1.length + 1).fill(null));

    for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;
    for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;

    for (let j = 1; j <= str2.length; j++) {
      for (let i = 1; i <= str1.length; i++) {
        const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;
        matrix[j][i] = Math.min(
          matrix[j][i - 1] + 1,
          matrix[j - 1][i] + 1,
          matrix[j - 1][i - 1] + indicator
        );
      }
    }

    return matrix[str2.length][str1.length];
  }

  private compareRecency(_item1: unknown,  _item2: unknown): number {
    const time1 = item1.timestamp ? new Date(item1.timestamp).getTime() : 0;
    const time2 = item2.timestamp ? new Date(item2.timestamp).getTime() : 0;
    return time1 > time2 ? 1 : time1 < time2 ? -1 : 0;
  }

  private compareCompleteness(_item1: unknown,  _item2: unknown): number {
    const fields1 = Object.keys(item1.data || {}).length;
    const fields2 = Object.keys(item2.data || {}).length;
    return fields1 > fields2 ? 1 : fields1 < fields2 ? -1 : 0;
  }

  private generateCacheKey(_item1: unknown,  _item2: unknown): string {
    const hash1 = this.hashObject(item1);
    const hash2 = this.hashObject(item2);
    return `${String(hash1)}_${String(hash2)}`;
  }

  private hashObject(_obj: unknown): string {
    // Simple hash function - in production would use crypto
    return JSON.stringify(obj)
      .split('')
      .reduce((a,  _b) => {
        a = (a << 5) - a + b.charCodeAt(0);
        return a & a;
      }, 0)
      .toString(36);
  }

  private cacheComparisonResult(_key: string,  result: ComparisonResult,  _maxSize: number): void {
    if (this.comparisonCache.size >= maxSize) {
      // Remove oldest entry (simple FIFO)
      const firstKey = this.comparisonCache.keys().next().value;
      this.comparisonCache.delete(firstKey);
    }
    this.comparisonCache.set(key, result);
  }

  private matchesComparisonResult(_item: unknown,  _comparison: ComparisonResult): boolean {
    // Simple matching - could be improved
    return comparison.details.matchingFields.some(
      (field) => this.getFieldValue(item, field) !== null
    );
  }
}

// Export singleton instance
export const highPerformanceDeduplicationService =
  HighPerformanceDeduplicationService.getInstance();
