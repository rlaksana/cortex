/**
 * Canary Deployment System
 *
 * Comprehensive canary deployment solution with:
 * - Feature flag management with cohort limiting
 * - Emergency kill-switch capabilities
 * - Progressive traffic splitting
 * - Health monitoring and validation
 * - Automated rollback procedures
 * - Configuration validation
 *
 * @author Cortex Team
 * @version 2.0.0
 * @since 2025
 */

// Export main services
export { FeatureFlagService, featureFlagService } from '../feature-flag/feature-flag-service.js';
export { KillSwitchService, killSwitchService } from './kill-switch-service.js';
export { CanaryOrchestrator, canaryOrchestrator } from './canary-orchestrator.js';
export { TrafficSplitterService, trafficSplitterService } from './traffic-splitter.js';
export { CanaryHealthMonitor, canaryHealthMonitor } from './canary-health-monitor.js';
export { RollbackService, rollbackService } from './rollback-service.js';
export { CanaryConfigValidator, canaryConfigValidator } from './config-validator.js';

// Export types and enums
export type {
  UserContext,
  FeatureFlag,
  FlagEvaluationResult,
  UserCohort,
  TargetingStrategy as FeatureTargetingStrategy,
  FlagStatus as FeatureFlagStatus,
  FeatureFlagConfig,
} from '../feature-flag/feature-flag-service.js';

export type {
  KillSwitchConfig,
  KillSwitchEvent,
  KillSwitchStatus as CanaryKillSwitchStatus,
  KillSwitchTrigger as CanaryKillSwitchTrigger,
  KillSwitchScope,
  AutoRecoveryConfig,
  RecoveryAction,
  NotificationConfig,
} from './kill-switch-service.js';

export type {
  CanaryDeploymentConfig,
  CanaryDeployment,
  DeploymentPhase,
  SuccessCriteria,
  RollbackThresholds,
  PhaseMetrics,
  TrafficRouting,
  TrafficRule,
  CanaryStatus,
  TrafficShiftStrategy,
} from './canary-orchestrator.js';

export type {
  TrafficRule as TrafficRoutingRule,
  ServiceTarget,
  RoutingStrategy,
  RoutingCondition,
  SessionAffinityConfig,
  FailoverConfig,
  RateLimitConfig,
  HealthCheckConfig as TrafficHealthCheckConfig,
  RequestContext,
  RoutingDecision,
  TrafficMetrics,
  LoadBalancerState,
} from './traffic-splitter.js';

export type {
  CanaryHealthConfig,
  HealthMetricsSnapshot,
  ServiceHealthMetrics,
  ComparisonMetrics,
  HealthIssue,
  HealthTrend,
  HealthAlert,
  HealthMetricType,
  HealthThreshold,
  AutoRollbackThreshold,
  ValidationCriteria,
  EscalationRule,
} from './canary-health-monitor.js';

export type {
  RollbackConfig,
  RollbackExecution,
  RollbackPhase,
  RollbackAction,
  RollbackStatus,
  RollbackStrategy,
  RollbackTrigger,
  ValidationResult,
  ExecutedAction,
  CriteriaResult,
  RollbackError,
  RollbackImpact,
} from './rollback-service.js';

export type {
  ValidationRequest,
  ValidationContext,
  ValidationResult as ConfigValidationResult,
  ValidationError,
  ValidationWarning,
  ValidationInfo,
  ResourceConstraints,
  SecurityPolicy,
  ValidationCategory,
  ValidationSeverity,
} from './config-validator.js';

// Note: Enums are already exported as types in the type exports above

/**
 * Canary System Manager
 *
 * Provides a unified interface for managing the entire canary deployment system.
 */
export class CanarySystemManager {
  private static instance: CanarySystemManager | null = null;

  private constructor() {}

  /**
   * Get singleton instance
   */
  public static getInstance(): CanarySystemManager {
    if (!CanarySystemManager.instance) {
      CanarySystemManager.instance = new CanarySystemManager();
    }
    return CanarySystemManager.instance;
  }

  /**
   * Initialize the canary system
   */
  public async initialize(): Promise<void> {
    console.log('Initializing Canary Deployment System...');

    // All services are singleton instances that auto-initialize
    // No additional initialization needed
    console.log('Canary Deployment System initialized successfully');
  }

  /**
   * Get system health and metrics
   */
  public getSystemHealth(): {
    featureFlags: unknown;
    killSwitches: unknown;
    deployments: unknown;
    trafficRouting: unknown;
    healthMonitoring: unknown;
    rollbacks: unknown;
  } {
    return {
      featureFlags: featureFlagService.getMetrics(),
      killSwitches: killSwitchService.getMetrics(),
      deployments: canaryOrchestrator.getMetrics(),
      trafficRouting: trafficSplitterService.getMetrics(),
      healthMonitoring: canaryHealthMonitor.getMetrics(),
      rollbacks: rollbackService.getStatistics(),
    };
  }

  /**
   * Cleanup all services
   */
  public async cleanup(): Promise<void> {
    console.log('Cleaning up Canary Deployment System...');

    // Note: Services don't have cleanup methods in this implementation
    // In a real implementation, you would call cleanup on all services

    console.log('Canary Deployment System cleaned up');
  }

  /**
   * Validate configuration across all services
   */
  public validateConfiguration(
    type: ValidationRequest['type'], 
    config: unknown, 
    context?: ValidationContext
  ): ValidationResult {
    return canaryConfigValidator.validate({
      type,
      config,
      context,
      strictMode: false,
    });
  }

  /**
   * Get comprehensive status report
   */
  public getStatusReport(): {
    timestamp: Date;
    systemHealth: unknown;
    activeDeployments: number;
    activeRollbacks: number;
    emergencyKillActive: boolean;
    recommendations: string[];
  } {
    const systemHealth = this.getSystemHealth();
    const activeDeployments = canaryOrchestrator.getActiveDeployments().length;
    const activeRollbacks = rollbackService.getActiveExecutions().length;
    const emergencyKillActive = killSwitchService.isEmergencyKillActive();

    const recommendations: string[] = [];

    // Generate recommendations based on system state
    if (activeDeployments > 5) {
      recommendations.push('Consider reducing concurrent canary deployments for better control');
    }

    if (activeRollbacks > 0) {
      recommendations.push('Monitor ongoing rollbacks and investigate root causes');
    }

    if (_emergencyKillActive) {
      recommendations.push('Emergency kill switch is active - investigate and resolve issues');
    }

    if (systemHealth.healthMonitoring.averageHealthScore < 80) {
      recommendations.push('System health score is below optimal - review health metrics');
    }

    return {
      timestamp: new Date(),
      systemHealth,
      activeDeployments,
      activeRollbacks,
      emergencyKillActive,
      recommendations,
    };
  }
}

// Export the main system manager
export const canarySystemManager = CanarySystemManager.getInstance();

// Export utility functions
export const CanaryUtils = {
  /**
   * Create a simple canary deployment configuration
   */
  createSimpleCanaryConfig: (
    overrides: Partial<CanaryDeploymentConfig> = {}
  ): CanaryDeploymentConfig => {
    const now = new Date();
    return {
      id: Math.random().toString(36).substring(2) + Date.now().toString(36),
      name: 'Canary Deployment',
      description: 'Simple canary deployment configuration',
      stableVersion: '1.0.0',
      canaryVersion: '2.0.0',
      serviceName: 'example-service',
      initialTrafficPercentage: 5,
      targetTrafficPercentage: 100,
      trafficShiftStrategy: TrafficShiftStrategy.LINEAR,
      phases: [
        {
          id: 'phase-1',
          name: 'Initial Phase',
          trafficPercentage: 5,
          durationMs: 300000, // 5 minutes
          successCriteria: [
            {
              metric: 'availability' as unknown,
              operator: 'greater_than' as unknown,
              threshold: 99,
              durationMs: 180000, // 3 minutes
              weight: 1,
            },
          ],
          rollbackThresholds: {
            errorRate: 5,
            latencyP95: 1000,
            latencyP99: 2000,
            availability: 95,
          },
          status: 'pending' as unknown,
        },
      ],
      healthCheckIntervalMs: 30000,
      healthCheckTimeoutMs: 5000,
      successCriteria: [
        {
          metric: 'availability' as unknown,
          operator: 'greater_than' as unknown,
          threshold: 99,
          durationMs: 300000,
          weight: 1,
        },
      ],
      rollbackThresholds: {
        errorRate: 5,
        latencyP95: 1000,
        latencyP99: 2000,
        availability: 95,
      },
      autoPromote: true,
      autoRollback: true,
      pauseOnFailure: true,
      maxRollbackAttempts: 3,
      maxDeploymentTimeMs: 3600000, // 1 hour
      phaseTransitionDelayMs: 60000, // 1 minute
      notifications: {
        onStart: true,
        onPhaseComplete: true,
        onFailure: true,
        onComplete: true,
        onRollback: true,
      },
      createdAt: now,
      tags: ['canary', 'automated'],
      ...overrides,
    };
  },

  /**
   * Create a simple health monitoring configuration
   */
  createSimpleHealthConfig: (overrides: Partial<CanaryHealthConfig> = {}): CanaryHealthConfig => {
    const now = new Date();
    return {
      deploymentId: 'example-deployment',
      serviceName: 'example-service',
      stableVersion: '1.0.0',
      canaryVersion: '2.0.0',
      checkIntervalMs: 30000,
      evaluationWindowMs: 300000,
      metricsRetentionHours: 24,
      thresholds: [
        {
          metric: HealthMetricType.AVAILABILITY,
          warning: 95,
          critical: 90,
          operator: 'less_than',
          windowSize: 5,
          consecutiveFailures: 2,
        },
        {
          metric: HealthMetricType.ERROR_RATE,
          warning: 5,
          critical: 10,
          operator: 'greater_than',
          windowSize: 5,
          consecutiveFailures: 3,
        },
        {
          metric: HealthMetricType.RESPONSE_TIME,
          warning: 1000,
          critical: 2000,
          operator: 'greater_than',
          windowSize: 5,
          consecutiveFailures: 2,
        },
      ],
      comparisonEnabled: true,
      comparisonTolerance: 10,
      baselineWindow: 2,
      alerting: {
        enabled: true,
        channels: ['email'],
        recipients: ['admin@example.com'],
        cooldownPeriodMs: 300000,
        escalationRules: [
          {
            severity: AlertSeverity.WARNING,
            delayMs: 300000,
            recipients: ['team@example.com'],
          },
          {
            severity: AlertSeverity.CRITICAL,
            delayMs: 60000,
            recipients: ['oncall@example.com'],
          },
        ],
      },
      autoRollback: {
        enabled: true,
        thresholds: [
          {
            metric: HealthMetricType.ERROR_RATE,
            threshold: 15,
            operator: 'greater_than',
            duration: 5,
            consecutiveViolations: 2,
          },
        ],
        delayMs: 30000,
        maxRollbacks: 3,
      },
      createdAt: now,
      tags: ['health', 'monitoring'],
      ...overrides,
    };
  },

  /**
   * Create a simple rollback configuration
   */
  createSimpleRollbackConfig: (overrides: Partial<RollbackConfig> = {}): RollbackConfig => {
    const now = new Date();
    return {
      id: Math.random().toString(36).substring(2) + Date.now().toString(36),
      deploymentId: 'example-deployment',
      name: 'Emergency Rollback',
      description: 'Simple rollback configuration',
      strategy: RollbackStrategy.IMMEDIATE,
      triggers: [RollbackTrigger.AUTOMATIC, RollbackTrigger.MANUAL],
      autoTriggerEnabled: true,
      triggerThresholds: [
        {
          metric: 'error_rate',
          operator: 'greater_than',
          threshold: 10,
          duration: 5,
          consecutiveFailures: 2,
        },
      ],
      validation: {
        enabled: true,
        healthCheckPath: '/health',
        validationTimeoutMs: 30000,
        successCriteria: [
          {
            type: 'health_check',
            weight: 1,
            required: true,
          },
        ],
        retryAttempts: 3,
        retryDelayMs: 10000,
      },
      actions: [
        {
          id: 'stop-traffic',
          name: 'Stop New Traffic',
          type: Action.STOP_NEW_TRAFFIC,
          order: 1,
          timeoutMs: 30000,
          config: {},
        },
        {
          id: 'drain-connections',
          name: 'Drain Connections',
          type: Action.DRAIN_CONNECTIONS,
          order: 2,
          timeoutMs: 60000,
          config: {},
        },
        {
          id: 'update-flags',
          name: 'Update Feature Flags',
          type: Action.UPDATE_FEATURE_FLAGS,
          order: 3,
          timeoutMs: 15000,
          config: { disable: true },
        },
      ],
      notifications: {
        enabled: true,
        onStart: true,
        onProgress: false,
        onComplete: true,
        onFailure: true,
        channels: ['email', 'slack'],
        recipients: ['admin@example.com'],
      },
      safety: {
        requireApproval: false,
        approvers: [],
        maxRollbackTimeMs: 300000,
        allowConsecutiveRollbacks: false,
        cooldownPeriodMs: 300000,
      },
      createdAt: now,
      tags: ['rollback', 'emergency'],
      ...overrides,
    };
  },

  /**
   * Calculate recommended traffic percentages for canary deployment
   */
  calculateTrafficProgression: (
    phases: number,
    strategy: TrafficShiftStrategy = TrafficShiftStrategy.LINEAR
  ): number[] => {
    const percentages: number[] = [];

    switch (_strategy) {
      case TrafficShiftStrategy.LINEAR:
        for (let i = 0; i < phases; i++) {
          percentages.push(Math.round((i / (phases - 1)) * 100));
        }
        break;

      case TrafficShiftStrategy.EXPONENTIAL:
        for (let i = 0; i < phases; i++) {
          const progress = i / (phases - 1);
          percentages.push(Math.round(Math.pow(progress, 2) * 100));
        }
        break;

      default:
        // Default to linear
        return this.calculateTrafficProgression(phases, TrafficShiftStrategy.LINEAR);
    }

    return percentages;
  },

  /**
   * Estimate deployment duration based on configuration
   */
  estimateDeploymentDuration: (config: CanaryDeploymentConfig): number => {
    let totalDuration = 0;

    for (const phase of config.phases) {
      totalDuration += phase.durationMs;
      totalDuration += config.phaseTransitionDelayMs;
    }

    // Add buffer time for validation and monitoring
    totalDuration += config.phases.length * config.healthCheckIntervalMs;

    return totalDuration;
  },

  /**
   * Generate deployment recommendations based on configuration
   */
  generateRecommendations: (config: CanaryDeploymentConfig): string[] => {
    const recommendations: string[] = [];

    if (config.initialTrafficPercentage > 20) {
      recommendations.push(
        'Consider starting with lower initial traffic (5-10%) for safer rollouts'
      );
    }

    if (config.phases.length < 3) {
      recommendations.push('Consider using more phases for gradual traffic increase');
    }

    if (config.healthCheckIntervalMs > 60000) {
      recommendations.push('Consider more frequent health checks for faster issue detection');
    }

    if (!config.autoRollback) {
      recommendations.push('Consider enabling auto-rollback for automatic failure recovery');
    }

    if (config.maxDeploymentTimeMs > 7200000) {
      // 2 hours
      recommendations.push('Consider shorter deployment time to reduce risk exposure');
    }

    return recommendations;
  },
};

// Export default
export default canarySystemManager;
