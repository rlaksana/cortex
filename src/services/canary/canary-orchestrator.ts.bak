/**
 * Canary Deployment Orchestrator
 *
 * Provides comprehensive canary deployment management with:
 * - Gradual traffic shifting
 * - Automated health monitoring
 * - Progressive rollout strategies
 * - Real-time metrics analysis
 * - Automatic rollback capabilities
 * - Deployment lifecycle management
 *
 * @author Cortex Team
 * @version 2.0.0
 * @since 2025
 */

import { EventEmitter } from 'events';
import { featureFlagService, FlagStatus } from '../feature-flag/feature-flag-service.js';
import { metricsService } from '../monitoring/metrics-service.js';
import { killSwitchService, KillSwitchTrigger } from './kill-switch-service.js';
import { logger } from '@/utils/logger.js';

// ============================================================================
// Types and Interfaces
// ============================================================================

/**
 * Canary deployment status
 */
export enum CanaryStatus {
  PENDING = 'pending',
  INITIALIZING = 'initializing',
  ACTIVE = 'active',
  MONITORING = 'monitoring',
  PROMOTING = 'promoting',
  COMPLETED = 'completed',
  FAILED = 'failed',
  ROLLING_BACK = 'rolling_back',
  ROLLED_BACK = 'rolled_back',
  PAUSED = 'paused',
}

/**
 * Traffic shift strategy
 */
export enum TrafficShiftStrategy {
  LINEAR = 'linear',
  EXPONENTIAL = 'exponential',
  MANUAL = 'manual',
  CUSTOM = 'custom',
}

/**
 * Deployment phase
 */
export interface DeploymentPhase {
  id: string;
  name: string;
  trafficPercentage: number;
  durationMs: number;
  successCriteria: SuccessCriteria[];
  rollbackThresholds: RollbackThresholds;
  status: 'pending' | 'active' | 'completed' | 'failed' | 'skipped';
  startTime?: Date;
  endTime?: Date;
  metrics?: PhaseMetrics;
}

/**
 * Success criteria for deployment phases
 */
export interface SuccessCriteria {
  metric: string;
  operator: 'less_than' | 'greater_than' | 'equals';
  threshold: number;
  durationMs?: number;
  weight?: number;
}

/**
 * Rollback thresholds for deployment phases
 */
export interface RollbackThresholds {
  errorRate: number;
  latencyP95: number;
  latencyP99: number;
  availability: number;
  customMetrics?: Record<string, number>;
}

/**
 * Phase metrics collected during deployment
 */
export interface PhaseMetrics {
  requests: number;
  errors: number;
  errorRate: number;
  averageLatency: number;
  p95Latency: number;
  p99Latency: number;
  availability: number;
  timestamp: Date;
  customMetrics?: Record<string, number>;
}

/**
 * Canary deployment configuration
 */
export interface CanaryDeploymentConfig {
  id: string;
  name: string;
  description?: string;

  // Version information
  stableVersion: string;
  canaryVersion: string;
  serviceName: string;

  // Traffic configuration
  initialTrafficPercentage: number;
  targetTrafficPercentage: number;
  trafficShiftStrategy: TrafficShiftStrategy;
  phases: DeploymentPhase[];

  // Health and monitoring
  healthCheckIntervalMs: number;
  healthCheckTimeoutMs: number;
  successCriteria: SuccessCriteria[];
  rollbackThresholds: RollbackThresholds;

  // Automated controls
  autoPromote: boolean;
  autoRollback: boolean;
  pauseOnFailure: boolean;
  maxRollbackAttempts: number;

  // Timing controls
  maxDeploymentTimeMs: number;
  phaseTransitionDelayMs: number;

  // Notification settings
  notifications: {
    onStart: boolean;
    onPhaseComplete: boolean;
    onFailure: boolean;
    onComplete: boolean;
    onRollback: boolean;
  };

  // Metadata
  createdBy?: string;
  createdAt: Date;
  tags?: string[];
}

/**
 * Canary deployment execution state
 */
export interface CanaryDeployment {
  config: CanaryDeploymentConfig;
  status: CanaryStatus;
  currentPhase?: number;
  currentTrafficPercentage: number;
  startTime?: Date;
  endTime?: Date;
  lastPhaseTransition?: Date;
  phases: DeploymentPhase[];
  metrics: {
    totalRequests: number;
    totalErrors: number;
    overallErrorRate: number;
    overallAvailability: number;
  };
  rollbackHistory: RollbackEvent[];
  flags: {
    featureFlagIds: string[];
    killSwitchIds: string[];
  };
  metadata: {
    lastHealthCheck?: Date;
    consecutiveFailures: number;
    promotionAttempts: number;
    rollbackAttempts: number;
  };
}

/**
 * Rollback event information
 */
export interface RollbackEvent {
  timestamp: Date;
  reason: string;
  trigger: 'automatic' | 'manual';
  phase: number;
  trafficPercentage: number;
  _metrics: PhaseMetrics;
  triggeredBy?: string;
}

/**
 * Traffic routing configuration
 */
export interface TrafficRouting {
  stable: {
    endpoint: string;
    weight: number;
    instances: string[];
  };
  canary: {
    endpoint: string;
    weight: number;
    instances: string[];
  };
  rules: TrafficRule[];
}

/**
 * Traffic routing rule
 */
export interface TrafficRule {
  condition: string;
  target: 'stable' | 'canary';
  weight?: number;
}

// ============================================================================
// Canary Orchestrator Implementation
// ============================================================================

/**
 * Main canary deployment orchestrator
 */
export class CanaryOrchestrator extends EventEmitter {
  private deployments: Map<string, CanaryDeployment> = new Map();
  private activeMonitoring: Map<string, NodeJS.Timeout> = new Map();
  private deploymentHistory: CanaryDeployment[] = [];
  private trafficRouting: Map<string, TrafficRouting> = new Map();

  // Static instance for singleton pattern
  private static instance: CanaryOrchestrator | null = null;

  constructor() {
    super();
    logger.info('Canary Deployment Orchestrator initialized');
  }

  /**
   * Get singleton instance
   */
  public static getInstance(): CanaryOrchestrator {
    if (!CanaryOrchestrator.instance) {
      CanaryOrchestrator.instance = new CanaryOrchestrator();
    }
    return CanaryOrchestrator.instance;
  }

  // ============================================================================
  // Deployment Management
  // ============================================================================

  /**
   * Create a new canary deployment
   */
  createDeployment(
    config: Omit<CanaryDeploymentConfig,  'id' | 'createdAt'>
  ): CanaryDeploymentConfig {
    const id = this.generateId();
    const now = new Date();

    const deploymentConfig: CanaryDeploymentConfig = {
      ...config,
      id,
      createdAt: now,
    };

    // Initialize phases
    deploymentConfig.phases = deploymentConfig.phases.map((phase,  _index) => ({
      ...phase,
      id: phase.id || this.generateId(),
      status: 'pending',
    }));

    logger.info('Canary deployment configuration created', {
      deploymentId: id,
      name: config.name,
      stableVersion: config.stableVersion,
      canaryVersion: config.canaryVersion,
      serviceName: config.serviceName,
    });

    this.emit('deploymentConfigCreated', deploymentConfig);

    return deploymentConfig;
  }

  /**
   * Start a canary deployment
   */
  async startDeployment(configId: string, config: CanaryDeploymentConfig): Promise<string> {
    const deploymentId = this.generateId();

    // Initialize deployment state
    const deployment: CanaryDeployment = {
      config,
      status: CanaryStatus.INITIALIZING,
      currentPhase: 0,
      currentTrafficPercentage: config.initialTrafficPercentage,
      phases: [...config.phases],
      metrics: {
        totalRequests: 0,
        totalErrors: 0,
        overallErrorRate: 0,
        overallAvailability: 0,
      },
      rollbackHistory: [],
      flags: {
        featureFlagIds: [],
        killSwitchIds: [],
      },
      metadata: {
        consecutiveFailures: 0,
        promotionAttempts: 0,
        rollbackAttempts: 0,
      },
    };

    this.deployments.set(deploymentId, deployment);

    try {
      // Initialize canary infrastructure
      await this.initializeCanaryInfrastructure(deployment);

      // Create feature flags for traffic control
      await this.setupFeatureFlags(deployment);

      // Setup kill switches
      await this.setupKillSwitches(deployment);

      // Configure traffic routing
      await this.configureTrafficRouting(deployment);

      // Start monitoring
      this.startDeploymentMonitoring(deploymentId, deployment);

      deployment.status = CanaryStatus.ACTIVE;
      deployment.startTime = new Date();

      logger.info('Canary deployment started', {
        deploymentId,
        name: config.name,
        canaryVersion: config.canaryVersion,
        initialTraffic: config.initialTrafficPercentage,
      });

      this.emit('deploymentStarted', deployment);

      // Record metrics
      metricsService.recordCounter('canary_deployments_started', 1, {
        service_name: config.serviceName,
        canary_version: config.canaryVersion,
      });

      // Start first phase
      await this.startPhase(deploymentId, 0);

      return deploymentId;
    } catch (error) {
      deployment.status = CanaryStatus.FAILED;
      deployment.endTime = new Date();

      logger.error('Failed to start canary deployment', {
        deploymentId,
        error: error instanceof Error ? error.message : String(error),
      });

      this.emit('deploymentFailed', deployment, error);

      throw error;
    }
  }

  /**
   * Pause a canary deployment
   */
 pauseDeployment(deploymentId: string, reason?: string): Promise<boolean> {
    const deployment = this.deployments.get(deploymentId);
    if (!deployment) {
      logger.warn('Deployment not found for pause', { deploymentId });
      return false;
    }

    if (
      deployment.status !== CanaryStatus.ACTIVE &&
      deployment.status !== CanaryStatus.MONITORING
    ) {
      logger.warn('Cannot pause deployment in current status', {
        deploymentId,
        status: deployment.status,
      });
      return false;
    }

    deployment.status = CanaryStatus.PAUSED;

    // Stop monitoring
    this.stopDeploymentMonitoring(deploymentId);

    logger.info('Canary deployment paused', {
      deploymentId,
      reason: reason || 'Manual pause',
      currentPhase: deployment.currentPhase,
      trafficPercentage: deployment.currentTrafficPercentage,
    });

    this.emit('deploymentPaused', deployment, reason);

    return true;
  }

  /**
   * Resume a paused canary deployment
   */
 resumeDeployment(deploymentId: string): Promise<boolean> {
    const deployment = this.deployments.get(deploymentId);
    if (!deployment) {
      logger.warn('Deployment not found for resume', { deploymentId });
      return false;
    }

    if (deployment.status !== CanaryStatus.PAUSED) {
      logger.warn('Cannot resume deployment in current status', {
        deploymentId,
        status: deployment.status,
      });
      return false;
    }

    deployment.status = CanaryStatus.ACTIVE;

    // Resume monitoring
    this.startDeploymentMonitoring(deploymentId, deployment);

    logger.info('Canary deployment resumed', {
      deploymentId,
      currentPhase: deployment.currentPhase,
      trafficPercentage: deployment.currentTrafficPercentage,
    });

    this.emit('deploymentResumed', deployment);

    return true;
  }

  /**
   * Promote canary deployment to next phase
   */
  async promoteDeployment(deploymentId: string, force: boolean = false): Promise<boolean> {
    const deployment = this.deployments.get(deploymentId);
    if (!deployment) {
      logger.warn('Deployment not found for promotion', { deploymentId });
      return false;
    }

    if (
      deployment.status !== CanaryStatus.ACTIVE &&
      deployment.status !== CanaryStatus.MONITORING
    ) {
      logger.warn('Cannot promote deployment in current status', {
        deploymentId,
        status: deployment.status,
      });
      return false;
    }

    const currentPhaseIndex = deployment.currentPhase || 0;
    const currentPhase = deployment.phases[currentPhaseIndex];

    if (!currentPhase) {
      logger.warn('No current phase found for promotion', { deploymentId });
      return false;
    }

    // Check if phase meets success criteria (unless forced)
    if (!force && !(await this.checkPhaseSuccessCriteria(deployment, currentPhase))) {
      logger.warn('Phase does not meet success criteria for promotion', {
        deploymentId,
        phaseId: currentPhase.id,
        phaseName: currentPhase.name,
      });
      return false;
    }

    // Mark current phase as completed
    currentPhase.status = 'completed';
    currentPhase.endTime = new Date();

    const nextPhaseIndex = currentPhaseIndex + 1;

    if (nextPhaseIndex >= deployment.phases.length) {
      // All phases completed - complete deployment
      return await this.completeDeployment(deploymentId);
    } else {
      // Start next phase
      return await this.startPhase(deploymentId, nextPhaseIndex);
    }
  }

  /**
   * Rollback canary deployment
   */
  async rollbackDeployment(
    deploymentId: string,
    reason?: string,
    triggeredBy?: string
  ): Promise<boolean> {
    const deployment = this.deployments.get(deploymentId);
    if (!deployment) {
      logger.warn('Deployment not found for rollback', { deploymentId });
      return false;
    }

    if (
      deployment.status === CanaryStatus.ROLLING_BACK ||
      deployment.status === CanaryStatus.ROLLED_BACK
    ) {
      logger.warn('Deployment already rolling back or rolled back', { deploymentId });
      return false;
    }

    deployment.status = CanaryStatus.ROLLING_BACK;
    deployment.metadata.rollbackAttempts++;

    const rollbackEvent: RollbackEvent = {
      timestamp: new Date(),
      reason: reason || 'Manual rollback',
      trigger: 'manual',
      phase: deployment.currentPhase || 0,
      trafficPercentage: deployment.currentTrafficPercentage,
      _metrics: this.getCurrentPhaseMetrics(deployment),
      triggeredBy,
    };

    deployment.rollbackHistory.push(rollbackEvent);

    try {
      logger.warn('Starting canary deployment rollback', {
        deploymentId,
        reason,
        currentPhase: deployment.currentPhase,
        trafficPercentage: deployment.currentTrafficPercentage,
      });

      // Stop monitoring
      this.stopDeploymentMonitoring(deploymentId);

      // Immediately route all traffic to stable
      await this.updateTrafficRouting(deployment, 0);

      // Disable feature flags
      await this.disableFeatureFlags(deployment);

      // Execute rollback procedures
      await this.executeRollbackProcedures(deployment);

      deployment.status = CanaryStatus.ROLLED_BACK;
      deployment.endTime = new Date();

      logger.warn('Canary deployment rollback completed', {
        deploymentId,
        duration: deployment.endTime.getTime() - deployment.startTime!.getTime(),
        totalRollbacks: deployment.rollbackHistory.length,
      });

      this.emit('deploymentRolledBack', deployment, rollbackEvent);

      // Record metrics
      metricsService.recordCounter('canary_deployments_rolled_back', 1, {
        service_name: deployment.config.serviceName,
        canary_version: deployment.config.canaryVersion,
        reason: reason || 'manual',
      });

      return true;
    } catch (error) {
      logger.error('Error during canary deployment rollback', {
        deploymentId,
        error: error instanceof Error ? error.message : String(error),
      });

      deployment.status = CanaryStatus.FAILED;
      this.emit('rollbackFailed', deployment, error);

      return false;
    }
  }

  /**
   * Complete canary deployment
   */
  async completeDeployment(deploymentId: string): Promise<boolean> {
    const deployment = this.deployments.get(deploymentId);
    if (!deployment) {
      logger.warn('Deployment not found for completion', { deploymentId });
      return false;
    }

    try {
      deployment.status = CanaryStatus.PROMOTING;

      logger.info('Completing canary deployment', {
        deploymentId,
        currentTraffic: deployment.currentTrafficPercentage,
        targetTraffic: deployment.config.targetTrafficPercentage,
      });

      // Route all traffic to canary
      await this.updateTrafficRouting(deployment, deployment.config.targetTrafficPercentage);

      // Promote canary to stable
      await this.promoteCanaryToStable(deployment);

      deployment.status = CanaryStatus.COMPLETED;
      deployment.endTime = new Date();

      // Stop monitoring
      this.stopDeploymentMonitoring(deploymentId);

      // Cleanup resources
      await this.cleanupDeploymentResources(deployment);

      logger.info('Canary deployment completed successfully', {
        deploymentId,
        duration: deployment.endTime.getTime() - deployment.startTime!.getTime(),
        totalPhases: deployment.phases.length,
        finalTrafficPercentage: deployment.currentTrafficPercentage,
      });

      this.emit('deploymentCompleted', deployment);

      // Add to history
      this.deploymentHistory.push(deployment);

      // Record metrics
      metricsService.recordCounter('canary_deployments_completed', 1, {
        service_name: deployment.config.serviceName,
        canary_version: deployment.config.canaryVersion,
        duration: deployment.endTime.getTime() - deployment.startTime!.getTime(),
      });

      return true;
    } catch (error) {
      logger.error('Error completing canary deployment', {
        deploymentId,
        error: error instanceof Error ? error.message : String(error),
      });

      deployment.status = CanaryStatus.FAILED;
      this.emit('deploymentFailed', deployment, error);

      return false;
    }
  }

  // ============================================================================
  // Deployment Lifecycle Management
  // ============================================================================

  /**
   * Initialize canary infrastructure
   */
  private async initializeCanaryInfrastructure(deployment: CanaryDeployment): Promise<void> {
    logger.info('Initializing canary infrastructure', {
      deploymentId: deployment.config.id,
      serviceName: deployment.config.serviceName,
      canaryVersion: deployment.config.canaryVersion,
    });

    // In a real implementation, this would:
    // 1. Deploy canary version alongside stable
    // 2. Setup health endpoints
    // 3. Configure monitoring endpoints
    // 4. Initialize metrics collection
    // 5. Setup load balancer configuration

    // For now, we'll simulate the initialization
    await new Promise((resolve) => setTimeout(resolve, 1000));
  }

  /**
   * Setup feature flags for traffic control
   */
  private async setupFeatureFlags(deployment: CanaryDeployment): Promise<void> {
    const flagName = `canary-${deployment.config.serviceName}-${deployment.config.canaryVersion}`;

    const flag = featureFlagService.createFlag({
      name: flagName,
      description: `Canary deployment flag for ${deployment.config.serviceName} version ${deployment.config.canaryVersion}`,
      status: FlagStatus.ENABLED,
      strategy: 'percentage' as unknown,
      rolloutPercentage: deployment.config.initialTrafficPercentage,
      killSwitchEnabled: true,
    });

    deployment.flags.featureFlagIds.push(flag.id);

    logger.info('Feature flags created for canary deployment', {
      deploymentId: deployment.config.id,
      flagId: flag.id,
      flagName: flag.name,
      initialPercentage: deployment.config.initialTrafficPercentage,
    });
  }

  /**
   * Setup kill switches for the deployment
   */
  private async setupKillSwitches(deployment: CanaryDeployment): Promise<void> {
    const killSwitchConfig = {
      name: `canary-kill-switch-${deployment.config.serviceName}`,
      description: `Emergency kill switch for canary deployment of ${deployment.config.serviceName}`,
      scope: 'deployment' as unknown,
      targetComponent: deployment.config.serviceName,
      triggerConditions: [
        {
          type: KillSwitchTrigger.ERROR_RATE_THRESHOLD,
          threshold: deployment.config.rollbackThresholds.errorRate,
          component: deployment.config.serviceName,
        },
        {
          type: KillSwitchTrigger.LATENCY_THRESHOLD,
          threshold: deployment.config.rollbackThresholds.latencyP95,
          component: deployment.config.serviceName,
        },
      ],
      autoRecovery: {
        enabled: false,
        delayMs: 0,
        maxAttempts: 0,
        backoffMultiplier: 1,
        recoveryActions: [],
      },
      notifications: {
        enabled: true,
        channels: ['email'] as unknown[],
        recipients: [],
      },
      gracePeriodMs: 30000,
      priority: 'high' as unknown,
      enabled: true,
    };

    const killSwitch = killSwitchService.createConfig(killSwitchConfig);
    deployment.flags.killSwitchIds.push(killSwitch.id);

    logger.info('Kill switches created for canary deployment', {
      deploymentId: deployment.config.id,
      killSwitchId: killSwitch.id,
      killSwitchName: killSwitch.name,
    });
  }

  /**
   * Configure traffic routing
   */
  private async configureTrafficRouting(deployment: CanaryDeployment): Promise<void> {
    const routing: TrafficRouting = {
      stable: {
        endpoint: `stable-${deployment.config.serviceName}`,
        weight: 100 - deployment.config.initialTrafficPercentage,
        instances: [
          `stable-${deployment.config.serviceName}-1`,
          `stable-${deployment.config.serviceName}-2`,
        ],
      },
      canary: {
        endpoint: `canary-${deployment.config.serviceName}-${deployment.config.canaryVersion}`,
        weight: deployment.config.initialTrafficPercentage,
        instances: [`canary-${deployment.config.serviceName}-${deployment.config.canaryVersion}-1`],
      },
      rules: [
        {
          condition: 'canary_flag_enabled',
          target: 'canary',
          weight: deployment.config.initialTrafficPercentage,
        },
      ],
    };

    this.trafficRouting.set(deployment.config.id, routing);

    logger.info('Traffic routing configured for canary deployment', {
      deploymentId: deployment.config.id,
      stableWeight: routing.stable.weight,
      canaryWeight: routing.canary.weight,
    });
  }

  /**
   * Start a deployment phase
   */
  private async startPhase(deploymentId: string, phaseIndex: number): Promise<boolean> {
    const deployment = this.deployments.get(deploymentId);
    if (!deployment) {
      return false;
    }

    const phase = deployment.phases[phaseIndex];
    if (!phase) {
      logger.warn('Phase not found', { deploymentId, phaseIndex });
      return false;
    }

    phase.status = 'active';
    phase.startTime = new Date();
    deployment.currentPhase = phaseIndex;

    // Calculate traffic percentage for this phase
    const trafficPercentage = this.calculateTrafficPercentage(deployment, phaseIndex);
    deployment.currentTrafficPercentage = trafficPercentage;

    // Update traffic routing
    await this.updateTrafficRouting(deployment, trafficPercentage);

    // Update feature flag
    await this.updateFeatureFlag(deployment, trafficPercentage);

    logger.info('Started canary deployment phase', {
      deploymentId,
      phaseIndex,
      phaseId: phase.id,
      phaseName: phase.name,
      trafficPercentage,
      duration: phase.durationMs,
    });

    this.emit('phaseStarted', deployment, phase);

    // Set phase timeout
    setTimeout(async () => {
      if (phase.status === 'active') {
        await this.handlePhaseTimeout(deploymentId, phaseIndex);
      }
    }, phase.durationMs);

    return true;
  }

  /**
   * Calculate traffic percentage for a phase
   */
  private calculateTrafficPercentage(_deployment: CanaryDeployment,  _phaseIndex: number): number {
    const config = deployment.config;
    const phase = deployment.phases[phaseIndex];

    switch (config.trafficShiftStrategy) {
      case TrafficShiftStrategy.LINEAR:
        return (
          config.initialTrafficPercentage +
          (config.targetTrafficPercentage - config.initialTrafficPercentage) *
            (phaseIndex / (config.phases.length - 1))
        );

      case TrafficShiftStrategy.EXPONENTIAL:
        const progress = phaseIndex / (config.phases.length - 1);
        return (
          config.initialTrafficPercentage +
          (config.targetTrafficPercentage - config.initialTrafficPercentage) * Math.pow(progress, 2)
        );

      case TrafficShiftStrategy.MANUAL:
        return phase.trafficPercentage;

      default:
        return phase.trafficPercentage;
    }
  }

  /**
   * Update traffic routing
   */
  private async updateTrafficRouting(
    deployment: CanaryDeployment,
    canaryPercentage: number
  ): Promise<void> {
    const routing = this.trafficRouting.get(deployment.config.id);
    if (!routing) {
      return;
    }

    routing.canary.weight = canaryPercentage;
    routing.stable.weight = 100 - canaryPercentage;

    // In a real implementation, this would update the load balancer configuration
    logger.debug('Updated traffic routing', {
      deploymentId: deployment.config.id,
      canaryPercentage,
      stablePercentage: routing.stable.weight,
    });
  }

  /**
   * Update feature flag
   */
  private async updateFeatureFlag(deployment: CanaryDeployment, percentage: number): Promise<void> {
    for (const flagId of deployment.flags.featureFlagIds) {
      const flag = featureFlagService.getFlag(flagId);
      if (_flag) {
        featureFlagService.updateFlag(flagId, {
          rolloutPercentage: percentage,
        });
      }
    }
  }

  /**
   * Handle phase timeout
   */
  private async handlePhaseTimeout(deploymentId: string, phaseIndex: number): Promise<void> {
    const deployment = this.deployments.get(deploymentId);
    if (!deployment) {
      return;
    }

    const phase = deployment.phases[phaseIndex];
    if (!phase || phase.status !== 'active') {
      return;
    }

    logger.info('Canary deployment phase timeout', {
      deploymentId,
      phaseIndex,
      phaseId: phase.id,
      phaseName: phase.name,
    });

    // Check if auto-promotion is enabled
    if (deployment.config.autoPromote) {
      await this.promoteDeployment(deploymentId);
    } else {
      // Pause deployment for manual intervention
      await this.pauseDeployment(deploymentId, 'Phase timeout - requires manual decision');
    }
  }

  // ============================================================================
  // Monitoring and Health Checks
  // ============================================================================

  /**
   * Start deployment monitoring
   */
  private startDeploymentMonitoring(
    deploymentId: string,
    deployment: CanaryDeployment
  ): Promise<void> {
    const interval = setInterval(async () => {
      await this.monitorDeployment(deploymentId, deployment);
    }, deployment.config.healthCheckIntervalMs);

    this.activeMonitoring.set(deploymentId, interval);

    logger.debug('Started deployment monitoring', {
      deploymentId,
      intervalMs: deployment.config.healthCheckIntervalMs,
    });

    return Promise.resolve();
  }

  /**
   * Stop deployment monitoring
   */
  private stopDeploymentMonitoring(_deploymentId: string): void {
    const interval = this.activeMonitoring.get(deploymentId);
    if (_interval) {
      clearInterval(interval);
      this.activeMonitoring.delete(deploymentId);
    }
  }

  /**
   * Monitor deployment health and metrics
   */
  private async monitorDeployment(
    deploymentId: string,
    deployment: CanaryDeployment
  ): Promise<void> {
    try {
      deployment.status = CanaryStatus.MONITORING;
      deployment.metadata.lastHealthCheck = new Date();

      // Collect metrics
      const metrics = await this.collectDeploymentMetrics(deployment);
      this.updateDeploymentMetrics(deployment, metrics);

      // Check rollback thresholds
      const shouldRollback = await this.checkRollbackThresholds(deployment, metrics);
      if (_shouldRollback) {
        await this.rollbackDeployment(deploymentId, 'Rollback thresholds exceeded', 'system');
        return;
      }

      // Check phase success criteria
      const currentPhase = deployment.phases[deployment.currentPhase || 0];
      if (currentPhase && currentPhase.status === 'active') {
        const phaseSuccess = await this.checkPhaseSuccessCriteria(deployment, currentPhase);
        if (phaseSuccess && deployment.config.autoPromote) {
          await this.promoteDeployment(deploymentId);
        }
      }

      // Check maximum deployment time
      if (deployment.startTime) {
        const elapsed = Date.now() - deployment.startTime.getTime();
        if (elapsed > deployment.config.maxDeploymentTimeMs) {
          await this.rollbackDeployment(deploymentId, 'Maximum deployment time exceeded', 'system');
        }
      }
    } catch (error) {
      logger.error('Error monitoring deployment', {
        deploymentId,
        error: error instanceof Error ? error.message : String(error),
      });

      deployment.metadata.consecutiveFailures++;

      if (deployment.metadata.consecutiveFailures >= 3) {
        await this.rollbackDeployment(deploymentId, 'Multiple monitoring failures', 'system');
      }
    }
  }

  /**
   * Collect deployment metrics
   */
  private async collectDeploymentMetrics(deployment: CanaryDeployment): Promise<PhaseMetrics> {
    // In a real implementation, this would collect actual metrics from your monitoring system
    // For now, we'll return simulated metrics

    return {
      requests: Math.floor(Math.random() * 1000) + 500,
      errors: Math.floor(Math.random() * 50),
      errorRate: Math.random() * 5,
      averageLatency: Math.random() * 200 + 50,
      p95Latency: Math.random() * 500 + 100,
      p99Latency: Math.random() * 1000 + 200,
      availability: 95 + Math.random() * 5,
      timestamp: new Date(),
    };
  }

  /**
   * Update deployment metrics
   */
  private updateDeploymentMetrics(_deployment: CanaryDeployment,  _metrics: PhaseMetrics): void {
    deployment.metrics.totalRequests += metrics.requests;
    deployment.metrics.totalErrors += metrics.errors;
    deployment.metrics.overallErrorRate =
      (deployment.metrics.totalErrors / deployment.metrics.totalRequests) * 100;
    deployment.metrics.overallAvailability = Math.max(
      deployment.metrics.overallAvailability,
      metrics.availability
    );

    // Update current phase metrics
    const currentPhase = deployment.phases[deployment.currentPhase || 0];
    if (_currentPhase) {
      currentPhase.metrics = metrics;
    }
  }

  /**
   * Check rollback thresholds
   */
  private async checkRollbackThresholds(
    deployment: CanaryDeployment,
    _metrics: PhaseMetrics
  ): Promise<boolean> {
    const thresholds = deployment.config.rollbackThresholds;

    return (
      metrics.errorRate > thresholds.errorRate ||
      metrics.p95Latency > thresholds.latencyP95 ||
      metrics.p99Latency > thresholds.latencyP99 ||
      metrics.availability < thresholds.availability
    );
  }

  /**
   * Check phase success criteria
   */
  private async checkPhaseSuccessCriteria(
    deployment: CanaryDeployment,
    phase: DeploymentPhase
  ): Promise<boolean> {
    if (!phase.metrics) {
      return false;
    }

    for (const criterion of phase.successCriteria) {
      const metricValue = this.getMetricValue(phase.metrics, criterion.metric);
      if (metricValue === null) {
        continue;
      }

      const meetsCriteria = this.compareMetricValue(
        metricValue,
        criterion.operator,
        criterion.threshold
      );
      if (!meetsCriteria) {
        return false;
      }
    }

    return true;
  }

  /**
   * Get metric value from phase metrics
   */
  private getMetricValue(_metrics: PhaseMetrics,  _metricName: string): number | null {
    switch (_metricName) {
      case 'errorRate':
        return metrics.errorRate;
      case 'averageLatency':
        return metrics.averageLatency;
      case 'p95Latency':
        return metrics.p95Latency;
      case 'p99Latency':
        return metrics.p99Latency;
      case 'availability':
        return metrics.availability;
      case 'requests':
        return metrics.requests;
      default:
        return null;
    }
  }

  /**
   * Compare metric value against threshold
   */
  private compareMetricValue(_value: number,  _operator: string,  _threshold: number): boolean {
    switch (_operator) {
      case 'less_than':
        return value < threshold;
      case 'greater_than':
        return value > threshold;
      case 'equals':
        return value === threshold;
      default:
        return false;
    }
  }

  /**
   * Get current phase metrics
   */
  private getCurrentPhaseMetrics(_deployment: CanaryDeployment): PhaseMetrics {
    const currentPhase = deployment.phases[deployment.currentPhase || 0];
    return (
      currentPhase?.metrics || {
        requests: 0,
        errors: 0,
        errorRate: 0,
        averageLatency: 0,
        p95Latency: 0,
        p99Latency: 0,
        availability: 0,
        timestamp: new Date(),
      }
    );
  }

  // ============================================================================
  // Deployment Operations
  // ============================================================================

  /**
   * Promote canary to stable
   */
  private async promoteCanaryToStable(deployment: CanaryDeployment): Promise<void> {
    logger.info('Promoting canary to stable', {
      deploymentId: deployment.config.id,
      canaryVersion: deployment.config.canaryVersion,
    });

    // In a real implementation, this would:
    // 1. Update service registry
    // 2. Replace stable instances with canary
    // 3. Update configuration
    // 4. Notify dependent services
  }

  /**
   * Execute rollback procedures
   */
  private async executeRollbackProcedures(deployment: CanaryDeployment): Promise<void> {
    logger.info('Executing rollback procedures', {
      deploymentId: deployment.config.id,
      canaryVersion: deployment.config.canaryVersion,
    });

    // In a real implementation, this would:
    // 1. Scale down canary instances
    // 2. Restore stable configuration
    // 3. Clear caches
    // 4. Reset circuit breakers
  }

  /**
   * Disable feature flags
   */
  private async disableFeatureFlags(deployment: CanaryDeployment): Promise<void> {
    for (const flagId of deployment.flags.featureFlagIds) {
      featureFlagService.updateFlag(flagId, {
        status: FlagStatus.DISABLED,
      });
    }
  }

  /**
   * Cleanup deployment resources
   */
  private async cleanupDeploymentResources(deployment: CanaryDeployment): Promise<void> {
    logger.info('Cleaning up deployment resources', {
      deploymentId: deployment.config.id,
    });

    // Remove from active deployments
    this.deployments.delete(deployment.config.id);

    // Remove traffic routing configuration
    this.trafficRouting.delete(deployment.config.id);

    // Stop monitoring
    this.stopDeploymentMonitoring(deployment.config.id);

    // Cleanup feature flags and kill switches
    // (Optional - you might want to keep them for audit purposes)
  }

  // ============================================================================
  // Public API Methods
  // ============================================================================

  /**
   * Get deployment by ID
   */
  getDeployment(_deploymentId: string): CanaryDeployment | undefined {
    return this.deployments.get(deploymentId);
  }

  /**
   * Get all active deployments
   */
  getActiveDeployments(): CanaryDeployment[] {
    return Array.from(this.deployments.values()).filter(
      (deployment) =>
        deployment.status !== CanaryStatus.COMPLETED &&
        deployment.status !== CanaryStatus.FAILED &&
        deployment.status !== CanaryStatus.ROLLED_BACK
    );
  }

  /**
   * Get deployment history
   */
  getDeploymentHistory(limit?: number): CanaryDeployment[] {
    const history = [...this.deploymentHistory].reverse();
    return limit ? history.slice(0, limit) : history;
  }

  /**
   * Get traffic routing configuration
   */
  getTrafficRouting(_deploymentId: string): TrafficRouting | undefined {
    return this.trafficRouting.get(deploymentId);
  }

  /**
   * Get service metrics
   */
  getMetrics(): {
    totalDeployments: number;
    activeDeployments: number;
    completedDeployments: number;
    failedDeployments: number;
    rolledBackDeployments: number;
  } {
    const deployments = Array.from(this.deployments.values());

    return {
      totalDeployments: deployments.length + this.deploymentHistory.length,
      activeDeployments: deployments.filter(
        (d) =>
          d.status === CanaryStatus.ACTIVE ||
          d.status === CanaryStatus.MONITORING ||
          d.status === CanaryStatus.PAUSED
      ).length,
      completedDeployments: this.deploymentHistory.filter(
        (d) => d.status === CanaryStatus.COMPLETED
      ).length,
      failedDeployments: this.deploymentHistory.filter((d) => d.status === CanaryStatus.FAILED)
        .length,
      rolledBackDeployments: this.deploymentHistory.filter(
        (d) => d.status === CanaryStatus.ROLLED_BACK
      ).length,
    };
  }

  /**
   * Generate unique ID
   */
  private generateId(): string {
    return Math.random().toString(36).substring(2) + Date.now().toString(36);
  }

  /**
   * Cleanup method
   */
  cleanup(): void {
    // Stop all monitoring
    for (const [deploymentId] of this.activeMonitoring) {
      this.stopDeploymentMonitoring(deploymentId);
    }

    this.deployments.clear();
    this.trafficRouting.clear();
    this.deploymentHistory = [];
    this.removeAllListeners();

    logger.info('Canary Deployment Orchestrator cleaned up');
  }
}

// Export singleton instance
export const canaryOrchestrator = CanaryOrchestrator.getInstance();
