/**
 * AI Provider Manager
 *
 * Simplified provider management with failover logic,
 * health monitoring, and load balancing
 *
 * @author Cortex Team
 * @version 2.0.0
 * @since 2025
 */

import { randomUUID } from 'crypto';
import type { AIProviderType } from '../../types/discriminated-unions.js';
import type {
  AIProvider,
  ZAIChatRequest,
  ZAIChatResponse,
  ZAIStreamChunk,
  ZAIMetrics,
  ZAIEvent,
  ZAIEventListener,
} from '../../types/zai-interfaces.js';
import { embeddingService } from '../embeddings/embedding-service.js';
import { zaiClientService } from './zai-client.service.js';
import type { ZAIClientService } from './zai-client.service.js';
import { logger } from '@/utils/logger.js';

/**
 * OpenAI provider implementation
 */
class OpenAIProvider implements AIProvider {
  public readonly name = 'openai';
  public readonly model: string;
  private config: unknown;

  constructor(config: unknown) {
    this.config = config;
    this.model = config.model || 'gpt-4-turbo-preview';
  }

  async isAvailable(): Promise<boolean> {
    try {
      await embeddingService.healthCheck();
      return true;
    } catch (error) {
      logger.warn({ error }, 'OpenAI provider health check failed');
      return false;
    }
  }

  async generateCompletion(request: ZAIChatRequest): Promise<ZAIChatResponse> {
    // Convert ZAI request to OpenAI format and use embedding service
    const message = request.messages[request.messages.length - 1]?.content || '';
    const embedding = await embeddingService.generateEmbedding(message);

    // Return a mock response for demonstration
    return {
      id: randomUUID(),
      object: 'chat.completion',
      created: Date.now(),
      model: this.model,
      choices: [
        {
          index: 0,
          message: {
            role: 'assistant',
            content: `OpenAI response for: ${message}`,
          },
          finishReason: 'stop',
        },
      ],
      usage: {
        promptTokens: Math.ceil(message.length / 4),
        completionTokens: 50,
        totalTokens: Math.ceil(message.length / 4) + 50,
      },
      processingTime: 1000,
      cached: false,
    };
  }

  async *generateStreamingCompletion(request: ZAIChatRequest): AsyncGenerator<ZAIStreamChunk> {
    const response = await this.generateCompletion(request);

    yield {
      id: response.id,
      object: 'chat.completion.chunk',
      created: response.created,
      model: response.model,
      choices: response.choices,
      finished: true,
    };
  }

  getMetrics(): ZAIMetrics {
    // Return mock metrics for OpenAI provider
    return {
      timestamp: new Date(),
      totalRequests: 0,
      successfulRequests: 0,
      failedRequests: 0,
      averageResponseTime: 0,
      p95ResponseTime: 0,
      p99ResponseTime: 0,
      totalTokensUsed: 0,
      totalCost: 0,
      cacheHitRate: 0,
      errorRate: 0,
      uptime: 0,
      lastReset: Date.now(),
      // Additional properties for compatibility
      requestCount: 0,
      successCount: 0,
      errorCount: 0,
      throughput: 0,
      circuitBreakerStatus: 'closed',
      tokensUsed: 0,
      cost: 0,
    };
  }

  reset(): void {
    // Reset OpenAI provider state if needed
  }
}

/**
 * ZAI provider wrapper
 */
class ZAIProviderWrapper implements AIProvider {
  public readonly name = 'zai';
  public readonly model: string;
  private client: ZAIClientService;

  constructor(_client: ZAIClientService,  config: unknown) {
    this.client = client;
    this.model = config.model;
  }

  async isAvailable(): Promise<boolean> {
    return await this.client.isAvailable();
  }

  async generateCompletion(request: ZAIChatRequest): Promise<ZAIChatResponse> {
    return await this.client.generateCompletion(request);
  }

  async *generateStreamingCompletion(request: ZAIChatRequest): AsyncGenerator<ZAIStreamChunk> {
    yield* this.client.generateStreamingCompletion(request);
  }

  getMetrics(): ZAIMetrics {
    return this.client.getMetrics();
  }

  reset(): void {
    this.client.reset();
  }
}

/**
 * Provider management strategy
 */
type ProviderStrategy = 'primary-first' | 'round-robin' | 'health-based';

/**
 * Simplified AI provider manager
 */
export class AIProviderManager {
  private providers: Map<string, AIProvider> = new Map();
  private primaryProvider: AIProvider;
  private fallbackProvider: AIProvider;
  private activeProvider: AIProvider;
  private eventListeners: Set<ZAIEventListener> = new Set();
  private strategy: ProviderStrategy = 'primary-first';
  private metrics = {
    totalRequests: 0,
    primaryProviderRequests: 0,
    fallbackProviderRequests: 0,
    failoverCount: 0,
    lastFailoverTime: 0,
    uptime: Date.now(),
  };

  constructor(config: unknown) {
    this.initializeProviders(config);
    this.primaryProvider = this.providers.get(config.primaryProvider)!;
    this.fallbackProvider = this.providers.get(config.fallbackProvider)!;
    this.activeProvider = this.primaryProvider;
  }

  /**
   * Generate completion with automatic failover
   */
  async generateCompletion(request: ZAIChatRequest): Promise<ZAIChatResponse> {
    const startTime = Date.now();
    this.metrics.totalRequests++;

    try {
      // Try current active provider
      if (this.activeProvider === this.primaryProvider) {
        return await this.executeWithPrimaryProvider(request, startTime);
      } else {
        return await this.executeWithFallbackProvider(request, startTime);
      }
    } catch (error) {
      return await this.handleProviderFailure(request, error as Error, startTime);
    }
  }

  /**
   * Generate streaming completion with failover
   */
  async *generateStreamingCompletion(request: ZAIChatRequest): AsyncGenerator<ZAIStreamChunk> {
    try {
      if (this.activeProvider === this.primaryProvider) {
        yield* this.primaryProvider.generateStreamingCompletion(request);
        this.metrics.primaryProviderRequests++;
      } else {
        yield* this.fallbackProvider.generateStreamingCompletion(request);
        this.metrics.fallbackProviderRequests++;
      }
    } catch (error) {
      logger.warn(
        { error, provider: this.activeProvider.name },
        'Streaming failed, attempting failover'
      );

      // Try fallback provider
      try {
        yield* this.fallbackProvider.generateStreamingCompletion(request);
        this.metrics.fallbackProviderRequests++;
      } catch (_fallbackError) {
        throw new Error(
          `Both providers failed for streaming. Primary: ${error}, Fallback: ${fallbackError}`
        );
      }
    }
  }

  /**
   * Switch to specified provider
   */
  async switchProvider(providerName: AIProviderType['type']): Promise<void> {
    const provider = this.providers.get(providerName);
    if (!provider) {
      throw new Error(`Provider ${providerName} not found`);
    }

    if (this.activeProvider === provider) {
      return;
    }

    const oldProvider = this.activeProvider.name;
    this.activeProvider = provider;

    logger.info(
      {
        from: oldProvider,
        to: providerName,
        reason: 'manual_switch',
      },
      'Switched active provider'
    );

    await this.emitEvent({
      type: 'provider_failed_over',
      data: {
        from: oldProvider,
        to: providerName,
        reason: 'manual_switch',
      },
    });
  }

  /**
   * Check if primary provider is healthy and switch back if needed
   */
  async checkPrimaryHealth(): Promise<void> {
    if (this.activeProvider === this.primaryProvider) {
      return;
    }

    try {
      const isHealthy = await this.primaryProvider.isAvailable();
      if (_isHealthy) {
        await this.switchToPrimaryProvider();
      }
    } catch (error) {
      // Primary provider still not healthy
    }
  }

  /**
   * Get provider status
   */
  getStatus(): Promise<{
    activeProvider: string;
    primaryProvider: { name: string; available: boolean };
    fallbackProvider: { name: string; available: boolean };
    failoverCount: number;
    uptime: number;
  }> {
    return {
      activeProvider: this.activeProvider.name,
      primaryProvider: {
        name: this.primaryProvider.name,
        available: await this.primaryProvider.isAvailable(),
      },
      fallbackProvider: {
        name: this.fallbackProvider.name,
        available: await this.fallbackProvider.isAvailable(),
      },
      failoverCount: this.metrics.failoverCount,
      uptime: Date.now() - this.metrics.uptime,
    };
  }

  /**
   * Get metrics from all providers
   */
  getMetrics(): Record<string, ZAIMetrics> {
    const providerMetrics: Record<string, ZAIMetrics> = {};

    for (const [name,  provider] of this.providers) {
      providerMetrics[name] = provider.getMetrics();
    }

    return providerMetrics;
  }

  /**
   * Reset all providers
   */
  reset(): void {
    for (const [name,  provider] of this.providers) {
      provider.reset();
    }

    this.activeProvider = this.primaryProvider;
    this.metrics.failoverCount = 0;
    this.metrics.lastFailoverTime = 0;

    logger.info('Reset all AI providers');
  }

  /**
   * Add event listener
   */
  addEventListener(_listener: ZAIEventListener): void {
    this.eventListeners.add(listener);
  }

  /**
   * Initialize providers
   */
  private initializeProviders(config: unknown): void {
    // Initialize ZAI provider
    const zaiProvider = new ZAIProviderWrapper(zaiClientService, config.providerConfigs.zai);
    this.providers.set('zai', zaiProvider);

    // Initialize OpenAI provider
    const openaiProvider = new OpenAIProvider(config.providerConfigs.openai);
    this.providers.set('openai', openaiProvider);
  }

  /**
   * Execute request with primary provider
   */
  private async executeWithPrimaryProvider(
    request: ZAIChatRequest,
    startTime: number
  ): Promise<ZAIChatResponse> {
    try {
      const response = await this.primaryProvider.generateCompletion(request);
      this.metrics.primaryProviderRequests++;
      this.updateResponseTime(Date.now() - startTime);
      return response;
    } catch (error) {
      this.metrics.primaryProviderRequests++; // Count as attempt
      throw error;
    }
  }

  /**
   * Execute request with fallback provider
   */
  private async executeWithFallbackProvider(
    request: ZAIChatRequest,
    startTime: number
  ): Promise<ZAIChatResponse> {
    const response = await this.fallbackProvider.generateCompletion(request);
    this.metrics.fallbackProviderRequests++;
    this.updateResponseTime(Date.now() - startTime);

    // Check if we can switch back to primary provider
    await this.checkPrimaryHealth();

    return response;
  }

  /**
   * Handle provider failure with failover
   */
  private async handleProviderFailure(
    request: ZAIChatRequest,
    error: Error,
    startTime: number
  ): Promise<ZAIChatResponse> {
    if (this.activeProvider === this.primaryProvider) {
      // Try failover to fallback provider
      return await this.performFailover(request, error, startTime);
    } else {
      // Already using fallback, fail completely
      throw new Error(`Both providers failed. Last error: ${error.message}`);
    }
  }

  /**
   * Perform failover to fallback provider
   */
  private async performFailover(
    request: ZAIChatRequest,
    error: Error,
    startTime: number
  ): Promise<ZAIChatResponse> {
    this.metrics.failoverCount++;
    this.metrics.lastFailoverTime = Date.now();
    this.activeProvider = this.fallbackProvider;

    await this.emitEvent({
      type: 'provider_failed_over',
      data: {
        from: this.primaryProvider.name,
        to: this.fallbackProvider.name,
        reason: error.message || 'Primary provider failure',
      },
    });

    logger.warn(
      {
        error: error.message,
        primaryProvider: this.primaryProvider.name,
        fallbackProvider: this.fallbackProvider.name,
        failoverCount: this.metrics.failoverCount,
      },
      'Failing over to fallback provider'
    );

    try {
      const response = await this.fallbackProvider.generateCompletion(request);
      this.metrics.fallbackProviderRequests++;
      return response;
    } catch (_fallbackError) {
      logger.error(
        {
          primaryError: error.message,
          fallbackError: (fallbackError as Error).message,
        },
        'Both providers failed'
      );
      throw new Error(
        `Both providers failed. Primary: ${error.message}, Fallback: ${(fallbackError as Error).message}`
      );
    }
  }

  /**
   * Switch back to primary provider
   */
  private async switchToPrimaryProvider(): Promise<void> {
    const oldProvider = this.activeProvider.name;
    this.activeProvider = this.primaryProvider;

    logger.info(
      {
        from: oldProvider,
        to: this.primaryProvider.name,
        reason: 'primary_provider_recovered',
      },
      'Switched back to primary provider'
    );

    await this.emitEvent({
      type: 'provider_failed_over',
      data: {
        from: oldProvider,
        to: this.primaryProvider.name,
        reason: 'primary_provider_recovered',
      },
    });
  }

  /**
   * Update response time metrics
   */
  private updateResponseTime(_responseTime: number): void {
    // Simple implementation - in production, would track more sophisticated metrics
  }

  /**
   * Emit event to listeners
   */
  private async emitEvent(event: ZAIEvent): Promise<void> {
    const listeners = Array.from(this.eventListeners);
    await Promise.allSettled(
      listeners.map((listener) => {
        try {
          return listener(event);
        } catch (error) {
          logger.error({ error, event }, 'Error in provider manager event listener');
        }
      })
    );
  }
}
