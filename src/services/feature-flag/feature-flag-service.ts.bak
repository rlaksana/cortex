/**
 * Feature Flag Service with Cohort Limiting
 *
 * Provides comprehensive feature flag management with:
 * - Cohort-based user targeting
 * - Percentage-based rollouts
 * - Dynamic flag evaluation
 * - A/B testing support
 * - Emergency disable capabilities
 *
 * @author Cortex Team
 * @version 2.0.0
 * @since 2025
 */

import { EventEmitter } from 'events';
import { metricsService } from '../monitoring/metrics-service.js';
import { logger } from '@/utils/logger.js';

// ============================================================================
// Types and Interfaces
// ============================================================================

/**
 * Feature flag targeting strategies
 */
export enum TargetingStrategy {
  ALL_USERS = 'all_users',
  PERCENTAGE = 'percentage',
  COHORT = 'cohort',
  USER_LIST = 'user_list',
  ATTRIBUTE_BASED = 'attribute_based',
  A_B_TEST = 'ab_test',
}

/**
 * Feature flag status
 */
export enum FlagStatus {
  ENABLED = 'enabled',
  DISABLED = 'disabled',
  KILLED = 'killed',
  ARCHIVED = 'archived',
}

/**
 * User cohort definition
 */
export interface UserCohort {
  id: string;
  name: string;
  description?: string;
  criteria: {
    // Attribute-based targeting
    attributes?: Record<string, unknown>;
    // User ID ranges
    userIdRange?: {
      start: number;
      end: number;
    };
    // Percentage of total users
    percentage?: number;
    // Specific user IDs
    userIds?: string[];
    // Custom criteria function
    customCriteria?: (user: UserContext) => boolean;
  };
  createdAt: Date;
  updatedAt: Date;
}

/**
 * User context for flag evaluation
 */
export interface UserContext {
  userId: string;
  sessionId?: string;
  attributes?: Record<string, unknown>;
  timestamp: Date;
  ipAddress?: string;
  userAgent?: string;
  cohortIds?: string[];
}

/**
 * Feature flag configuration
 */
export interface FeatureFlag {
  id: string;
  name: string;
  description?: string;
  status: FlagStatus;
  strategy: TargetingStrategy;
  rolloutPercentage?: number;
  targetCohorts?: string[];
  targetUsers?: string[];
  attributes?: Record<string, unknown>;
  conditions?: FlagCondition[];

  // Emergency controls
  killSwitchEnabled: boolean;
  emergencyDisabled: boolean;
  emergencyDisableReason?: string;
  emergencyDisabledAt?: Date;

  // A/B testing configuration
  abTestConfig?: {
    variantA: FlagVariant;
    variantB: FlagVariant;
    trafficSplit: number; // 0-100 percentage for variant A
  };

  // Lifecycle management
  createdAt: Date;
  updatedAt: Date;
  createdBy?: string;
  expiresAt?: Date;

  // Metadata
  tags?: string[];
  category?: string;
  owner?: string;
}

/**
 * Flag condition for complex targeting
 */
export interface FlagCondition {
  type: 'attribute' | 'cohort' | 'percentage' | 'custom';
  operator:
    | 'equals'
    | 'not_equals'
    | 'contains'
    | 'not_contains'
    | 'greater_than'
    | 'less_than'
    | 'in'
    | 'not_in';
  field: string;
  value: unknown;
  weight?: number;
}

/**
 * A/B test variant definition
 */
export interface FlagVariant {
  id: string;
  name: string;
  config: Record<string, unknown>;
  weight?: number;
}

/**
 * Flag evaluation result
 */
export interface FlagEvaluationResult {
  flagId: string;
  enabled: boolean;
  variant?: string;
  config?: Record<string, unknown>;
  reason: string;
  matchedConditions: string[];
  evaluationTime: number;
  timestamp: Date;
}

/**
 * Feature flag configuration
 */
export interface FeatureFlagConfig {
  // Cache settings
  cacheEnabled: boolean;
  cacheTTL: number;
  maxCacheSize: number;

  // Evaluation settings
  evaluationTimeoutMs: number;
  enableMetrics: boolean;
  enableAuditLog: boolean;

  // Emergency controls
  emergencyKillAll: boolean;
  emergencyKillReason?: string;
  emergencyKillAt?: Date;

  // Rate limiting
  rateLimitEnabled: boolean;
  maxEvaluationsPerSecond: number;
}

// ============================================================================
// Feature Flag Service Implementation
// ============================================================================

/**
 * Main feature flag service
 */
export class FeatureFlagService extends EventEmitter {
  private config: FeatureFlagConfig;
  private flags: Map<string, FeatureFlag> = new Map();
  private cohorts: Map<string, UserCohort> = new Map();
  private evaluationCache: Map<string, FlagEvaluationResult> = new Map();
  private metricsCache: Map<string, unknown> = new Map();

  // Rate limiting
  private evaluationCounters: Map<string, number[]> = new Map();
  private lastCleanupTime = Date.now();

  // Static instance for singleton pattern
  private static instance: FeatureFlagService | null = null;

  constructor(config?: Partial<FeatureFlagConfig>) {
    super();

    this.config = {
      cacheEnabled: true,
      cacheTTL: 300000, // 5 minutes
      maxCacheSize: 10000,
      evaluationTimeoutMs: 100,
      enableMetrics: true,
      enableAuditLog: true,
      emergencyKillAll: false,
      rateLimitEnabled: true,
      maxEvaluationsPerSecond: 1000,
      ...config,
    };

    // Cleanup cache periodically
    setInterval(() => { this.cleanupCache(); }, 60000); // Every minute

    logger.info('Feature Flag Service initialized', {
      cacheEnabled: this.config.cacheEnabled,
      rateLimitEnabled: this.config.rateLimitEnabled,
    });
  }

  /**
   * Get singleton instance
   */
  public static getInstance(config?: Partial<FeatureFlagConfig>): FeatureFlagService {
    if (!FeatureFlagService.instance) {
      FeatureFlagService.instance = new FeatureFlagService(config);
    }
    return FeatureFlagService.instance;
  }

  // ============================================================================
  // Flag Management
  // ============================================================================

  /**
   * Create a new feature flag
   */
  createFlag(flag: Omit<FeatureFlag,  'id' | 'createdAt' | 'updatedAt'>): FeatureFlag {
    const id = this.generateId();
    const now = new Date();

    const newFlag: FeatureFlag = {
      ...flag,
      id,
      createdAt: now,
      updatedAt: now,
    };

    this.flags.set(id, newFlag);

    if (this.config.enableAuditLog) {
      logger.info('Feature flag created', { flagId: id, name: flag.name });
    }

    this.emit('flagCreated', newFlag);

    if (this.config.enableMetrics) {
      metricsService.recordCounter('feature_flags_created', 1, { flag_name: flag.name });
    }

    return newFlag;
  }

  /**
   * Update an existing feature flag
   */
  updateFlag(_id: string,  updates: Partial<FeatureFlag>): FeatureFlag | null {
    const flag = this.flags.get(id);
    if (!flag) {
      logger.warn('Feature flag not found for update', { flagId: id });
      return null;
    }

    const updatedFlag: FeatureFlag = {
      ...flag,
      ...updates,
      id, // Preserve ID
      updatedAt: new Date(),
    };

    this.flags.set(id, updatedFlag);

    // Clear cache for this flag
    this.clearCacheForFlag(id);

    if (this.config.enableAuditLog) {
      logger.info('Feature flag updated', { flagId: id, changes: Object.keys(updates) });
    }

    this.emit('flagUpdated', updatedFlag);

    return updatedFlag;
  }

  /**
   * Delete a feature flag
   */
  deleteFlag(_id: string): boolean {
    const flag = this.flags.get(id);
    if (!flag) {
      return false;
    }

    this.flags.delete(id);
    this.clearCacheForFlag(id);

    if (this.config.enableAuditLog) {
      logger.info('Feature flag deleted', { flagId: id, name: flag.name });
    }

    this.emit('flagDeleted', { id, name: flag.name });

    if (this.config.enableMetrics) {
      metricsService.recordCounter('feature_flags_deleted', 1, { flag_name: flag.name });
    }

    return true;
  }

  /**
   * Get a feature flag by ID
   */
  getFlag(_id: string): FeatureFlag | undefined {
    return this.flags.get(id);
  }

  /**
   * Get all feature flags
   */
  getAllFlags(): FeatureFlag[] {
    return Array.from(this.flags.values());
  }

  /**
   * Get flags by status
   */
  getFlagsByStatus(_status: FlagStatus): FeatureFlag[] {
    return this.getAllFlags().filter((flag) => flag.status === status);
  }

  // ============================================================================
  // Emergency Controls
  // ============================================================================

  /**
   * Emergency kill all flags
   */
  emergencyKillAll(reason?: string): void {
    this.config.emergencyKillAll = true;
    this.config.emergencyKillReason = reason || 'Emergency kill activated';
    this.config.emergencyKillAt = new Date();

    logger.error('Emergency kill all activated', { reason });

    this.emit('emergencyKillAll', { reason, timestamp: this.config.emergencyKillAt });

    if (this.config.enableMetrics) {
      metricsService.recordCounter('feature_flags_emergency_kill_all', 1, {
        reason: reason || 'unknown',
      });
    }
  }

  /**
   * Restore from emergency kill
   */
  restoreFromEmergencyKill(): void {
    this.config.emergencyKillAll = false;
    this.config.emergencyKillReason = undefined;
    this.config.emergencyKillAt = undefined;

    logger.info('Emergency kill all deactivated');

    this.emit('emergencyKillAllRestored', { timestamp: new Date() });
  }

  /**
   * Emergency disable a specific flag
   */
  emergencyDisableFlag(_id: string,  reason?: string): boolean {
    const flag = this.flags.get(id);
    if (!flag) {
      return false;
    }

    flag.emergencyDisabled = true;
    flag.emergencyDisabledAt = new Date();
    flag.emergencyDisableReason = reason || 'Emergency disable';
    flag.status = FlagStatus.KILLED;

    this.clearCacheForFlag(id);

    logger.error('Feature flag emergency disabled', { flagId: id, name: flag.name, reason });

    this.emit('flagEmergencyDisabled', flag);

    if (this.config.enableMetrics) {
      metricsService.recordCounter('feature_flags_emergency_disabled', 1, {
        flag_name: flag.name,
        reason: reason || 'unknown',
      });
    }

    return true;
  }

  /**
   * Check if emergency kill is active
   */
  isEmergencyKillActive(): boolean {
    return this.config.emergencyKillAll || false;
  }

  // ============================================================================
  // Flag Evaluation
  // ============================================================================

  /**
   * Evaluate a feature flag for a user
   */
  async evaluateFlag(flagId: string, userContext: UserContext): Promise<FlagEvaluationResult> {
    const startTime = Date.now();

    // Check rate limiting
    if (this.config.rateLimitEnabled && !this.checkRateLimit(userContext.userId)) {
      const result = this.createEvaluationResult(
        flagId,
        false,
        undefined,
        'Rate limited',
        [],
        Date.now() - startTime
      );
      return result;
    }

    // Check cache first
    const cacheKey = this.generateCacheKey(flagId, userContext);
    if (this.config.cacheEnabled) {
      const cached = this.getFromCache(cacheKey);
      if (_cached) {
        return cached;
      }
    }

    const flag = this.flags.get(flagId);
    if (!flag) {
      const result = this.createEvaluationResult(
        flagId,
        false,
        undefined,
        'Flag not found',
        [],
        Date.now() - startTime
      );
      return result;
    }

    // Check emergency kill all
    if (this.config.emergencyKillAll) {
      const result = this.createEvaluationResult(
        flagId,
        false,
        undefined,
        'Emergency kill all active',
        [],
        Date.now() - startTime
      );
      return result;
    }

    // Check flag emergency disable
    if (flag.emergencyDisabled) {
      const result = this.createEvaluationResult(
        flagId,
        false,
        undefined,
        `Emergency disabled: ${flag.emergencyDisableReason}`,
        [],
        Date.now() - startTime
      );
      return result;
    }

    // Check if flag is enabled
    if (flag.status !== FlagStatus.ENABLED) {
      const result = this.createEvaluationResult(
        flagId,
        false,
        undefined,
        `Flag status: ${flag.status}`,
        [],
        Date.now() - startTime
      );
      return result;
    }

    // Check expiration
    if (flag.expiresAt && flag.expiresAt < new Date()) {
      const result = this.createEvaluationResult(
        flagId,
        false,
        undefined,
        'Flag expired',
        [],
        Date.now() - startTime
      );
      return result;
    }

    // Evaluate based on strategy
    const evaluationResult = await this.evaluateByStrategy(flag, userContext, startTime);

    // Cache result
    if (this.config.cacheEnabled) {
      this.setCache(cacheKey, evaluationResult);
    }

    // Record metrics
    if (this.config.enableMetrics) {
      metricsService.recordCounter('feature_flags_evaluated', 1, {
        flag_name: flag.name,
        enabled: evaluationResult.enabled.toString(),
        strategy: flag.strategy,
      });
    }

    // Emit event
    this.emit('flagEvaluated', { flag, userContext, result: evaluationResult });

    return evaluationResult;
  }

  /**
   * Evaluate multiple flags for a user
   */
  async evaluateMultipleFlags(
    flagIds: string[],
    userContext: UserContext
  ): Promise<Map<string, FlagEvaluationResult>> {
    const results = new Map<string, FlagEvaluationResult>();

    // Evaluate flags in parallel for better performance
    const evaluations = flagIds.map(async (flagId) => {
      const result = await this.evaluateFlag(flagId, userContext);
      return { flagId, result };
    });

    const evaluationResults = await Promise.all(evaluations);

    evaluationResults.forEach(({ flagId,  result }) => {
      results.set(flagId, result);
    });

    return results;
  }

  /**
   * Check if a feature is enabled for a user (convenience method)
   */
  async isEnabled(
    flagId: string,
    userId: string,
    attributes?: Record<string, unknown>
  ): Promise<boolean> {
    const userContext: UserContext = {
      userId,
      timestamp: new Date(),
      attributes,
    };

    const result = await this.evaluateFlag(flagId, userContext);
    return result.enabled;
  }

  // ============================================================================
  // Cohort Management
  // ============================================================================

  /**
   * Create a new user cohort
   */
  createCohort(_cohort: Omit<UserCohort,  'id' | 'createdAt' | 'updatedAt'>): UserCohort {
    const id = this.generateId();
    const now = new Date();

    const newCohort: UserCohort = {
      ...cohort,
      id,
      createdAt: now,
      updatedAt: now,
    };

    this.cohorts.set(id, newCohort);

    logger.info('User cohort created', { cohortId: id, name: cohort.name });

    this.emit('cohortCreated', newCohort);

    return newCohort;
  }

  /**
   * Get a cohort by ID
   */
  getCohort(_id: string): UserCohort | undefined {
    return this.cohorts.get(id);
  }

  /**
   * Get all cohorts
   */
  getAllCohorts(): UserCohort[] {
    return Array.from(this.cohorts.values());
  }

  /**
   * Check if user belongs to a cohort
   */
  isUserInCohort(
    _userId: string, 
    _cohortId: string, 
    userAttributes?: Record<string,  unknown>
  ): boolean {
    const cohort = this.cohorts.get(cohortId);
    if (!cohort) {
      return false;
    }

    const userContext: UserContext = {
      userId,
      timestamp: new Date(),
      attributes: userAttributes,
    };

    return this.evaluateCohortCriteria(cohort, userContext);
  }

  // ============================================================================
  // Private Methods
  // ============================================================================

  /**
   * Evaluate flag based on strategy
   */
  private async evaluateByStrategy(
    flag: FeatureFlag,
    userContext: UserContext,
    startTime: number
  ): Promise<FlagEvaluationResult> {
    const matchedConditions: string[] = [];

    switch (flag.strategy) {
      case TargetingStrategy.ALL_USERS:
        return this.createEvaluationResult(
          flag.id,
          true,
          undefined,
          'All users enabled',
          matchedConditions,
          Date.now() - startTime
        );

      case TargetingStrategy.PERCENTAGE:
        if (flag.rolloutPercentage === undefined) {
          return this.createEvaluationResult(
            flag.id,
            false,
            undefined,
            'Percentage not configured',
            matchedConditions,
            Date.now() - startTime
          );
        }
        const hash = this.hashUserForPercentage(userContext.userId, flag.id);
        const enabled = hash < flag.rolloutPercentage;
        matchedConditions.push(`percentage: ${flag.rolloutPercentage}%`);
        return this.createEvaluationResult(
          flag.id,
          enabled,
          undefined,
          `Percentage rollout: ${flag.rolloutPercentage}%`,
          matchedConditions,
          Date.now() - startTime
        );

      case TargetingStrategy.COHORT:
        if (!flag.targetCohorts || flag.targetCohorts.length === 0) {
          return this.createEvaluationResult(
            flag.id,
            false,
            undefined,
            'No target cohorts configured',
            matchedConditions,
            Date.now() - startTime
          );
        }

        for (const cohortId of flag.targetCohorts) {
          if (this.isUserInCohort(userContext.userId, cohortId, userContext.attributes)) {
            matchedConditions.push(`cohort: ${cohortId}`);
            return this.createEvaluationResult(
              flag.id,
              true,
              undefined,
              `User in cohort: ${cohortId}`,
              matchedConditions,
              Date.now() - startTime
            );
          }
        }
        return this.createEvaluationResult(
          flag.id,
          false,
          undefined,
          'User not in target cohorts',
          matchedConditions,
          Date.now() - startTime
        );

      case TargetingStrategy.USER_LIST:
        if (!flag.targetUsers || flag.targetUsers.length === 0) {
          return this.createEvaluationResult(
            flag.id,
            false,
            undefined,
            'No target users configured',
            matchedConditions,
            Date.now() - startTime
          );
        }

        const inUserList = flag.targetUsers.includes(userContext.userId);
        if (_inUserList) {
          matchedConditions.push('user_list_match');
        }
        return this.createEvaluationResult(
          flag.id,
          inUserList,
          undefined,
          inUserList ? 'User in target list' : 'User not in target list',
          matchedConditions,
          Date.now() - startTime
        );

      case TargetingStrategy.ATTRIBUTE_BASED:
        if (!flag.conditions || flag.conditions.length === 0) {
          return this.createEvaluationResult(
            flag.id,
            false,
            undefined,
            'No attribute conditions configured',
            matchedConditions,
            Date.now() - startTime
          );
        }

        const allConditionsMet = this.evaluateAttributeConditions(flag.conditions, userContext);
        if (_allConditionsMet) {
          matchedConditions.push('attribute_conditions_met');
        }
        return this.createEvaluationResult(
          flag.id,
          allConditionsMet,
          undefined,
          allConditionsMet ? 'All attribute conditions met' : 'Attribute conditions not met',
          matchedConditions,
          Date.now() - startTime
        );

      case TargetingStrategy.A_B_TEST:
        if (!flag.abTestConfig) {
          return this.createEvaluationResult(
            flag.id,
            false,
            undefined,
            'A/B test configuration missing',
            matchedConditions,
            Date.now() - startTime
          );
        }

        const abHash = this.hashUserForPercentage(userContext.userId, flag.id);
        const variant = abHash < flag.abTestConfig.trafficSplit ? 'A' : 'B';
        const variantConfig =
          variant === 'A' ? flag.abTestConfig.variantA : flag.abTestConfig.variantB;

        matchedConditions.push(`ab_test_variant_${variant}`);
        return this.createEvaluationResult(
          flag.id,
          true,
          variant,
          variantConfig.config,
          `A/B test variant ${variant}`,
          matchedConditions,
          Date.now() - startTime
        );

      default:
        return this.createEvaluationResult(
          flag.id,
          false,
          undefined,
          `Unknown strategy: ${flag.strategy}`,
          matchedConditions,
          Date.now() - startTime
        );
    }
  }

  /**
   * Evaluate attribute conditions
   */
  private evaluateAttributeConditions(
    _conditions: FlagCondition[], 
    _userContext: UserContext
  ): boolean {
    for (const condition of conditions) {
      if (!this.evaluateSingleCondition(condition, userContext)) {
        return false;
      }
    }
    return true;
  }

  /**
   * Evaluate a single condition
   */
  private evaluateSingleCondition(_condition: FlagCondition,  _userContext: UserContext): boolean {
    const fieldValue = this.getFieldValue(userContext, condition.field);

    switch (condition.operator) {
      case 'equals':
        return fieldValue === condition.value;
      case 'not_equals':
        return fieldValue !== condition.value;
      case 'contains':
        return typeof fieldValue === 'string' && fieldValue.includes(condition.value);
      case 'not_contains':
        return typeof fieldValue === 'string' && !fieldValue.includes(condition.value);
      case 'greater_than':
        return typeof fieldValue === 'number' && fieldValue > condition.value;
      case 'less_than':
        return typeof fieldValue === 'number' && fieldValue < condition.value;
      case 'in':
        return Array.isArray(condition.value) && condition.value.includes(fieldValue);
      case 'not_in':
        return Array.isArray(condition.value) && !condition.value.includes(fieldValue);
      default:
        return false;
    }
  }

  /**
   * Get field value from user context
   */
  private getFieldValue(_userContext: UserContext,  _field: string): unknown {
    if (field.startsWith('user.')) {
      const userField = field.substring(5);
      return userContext[userField as keyof UserContext];
    }

    if (field.startsWith('attr.') && userContext.attributes) {
      const attrField = field.substring(5);
      return userContext.attributes[attrField];
    }

    return userContext[field as keyof UserContext];
  }

  /**
   * Evaluate cohort criteria
   */
  private evaluateCohortCriteria(_cohort: UserCohort,  _userContext: UserContext): boolean {
    const criteria = cohort.criteria;

    // Attribute-based targeting
    if (criteria.attributes && userContext.attributes) {
      for (const [key, value] of Object.entries(criteria.attributes)) {
        if (userContext.attributes[key] !== value) {
          return false;
        }
      }
    }

    // User ID range
    if (criteria.userIdRange) {
      const userIdNum = parseInt(userContext.userId, 10);
      if (
        isNaN(userIdNum) ||
        userIdNum < criteria.userIdRange.start ||
        userIdNum > criteria.userIdRange.end
      ) {
        return false;
      }
    }

    // Percentage-based
    if (criteria.percentage !== undefined) {
      const hash = this.hashUserForPercentage(userContext.userId, cohort.id);
      if (hash >= criteria.percentage) {
        return false;
      }
    }

    // Specific user IDs
    if (criteria.userIds && criteria.userIds.length > 0) {
      if (!criteria.userIds.includes(userContext.userId)) {
        return false;
      }
    }

    // Custom criteria function
    if (criteria.customCriteria) {
      try {
        return criteria.customCriteria(userContext);
      } catch (error) {
        logger.error('Error evaluating custom cohort criteria', {
          cohortId: cohort.id,
          userId: userContext.userId,
          error,
        });
        return false;
      }
    }

    return true;
  }

  /**
   * Hash user ID for percentage-based targeting
   */
  private hashUserForPercentage(_userId: string,  _seed: string): number {
    // Simple hash function - in production, use a proper hashing algorithm
    const combined = `${userId}-${seed}`;
    let hash = 0;
    for (let i = 0; i < combined.length; i++) {
      const char = combined.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return Math.abs(hash) % 100;
  }

  /**
   * Check rate limiting
   */
  private checkRateLimit(_userId: string): boolean {
    const now = Date.now();
    const windowMs = 1000; // 1 second window
    const maxRequests = this.config.maxEvaluationsPerSecond;

    if (!this.evaluationCounters.has(userId)) {
      this.evaluationCounters.set(userId, []);
    }

    const timestamps = this.evaluationCounters.get(userId)!;

    // Remove old timestamps
    const validTimestamps = timestamps.filter((timestamp) => now - timestamp < windowMs);

    if (validTimestamps.length >= maxRequests) {
      return false;
    }

    validTimestamps.push(now);
    this.evaluationCounters.set(userId, validTimestamps);

    return true;
  }

  /**
   * Create evaluation result
   */
  private createEvaluationResult(
    _flagId: string, 
    _enabled: boolean, 
    _variant: string | undefined, 
    _reason: string, 
    _matchedConditions: string[], 
    _evaluationTime: number
  ): FlagEvaluationResult {
    return {
      flagId,
      enabled,
      variant,
      reason,
      matchedConditions,
      evaluationTime,
      timestamp: new Date(),
    };
  }

  /**
   * Generate cache key
   */
  private generateCacheKey(_flagId: string,  _userContext: UserContext): string {
    return `${flagId}:${userContext.userId}:${userContext.sessionId || 'no-session'}`;
  }

  /**
   * Get from cache
   */
  private getFromCache(_key: string): FlagEvaluationResult | null {
    const cached = this.evaluationCache.get(key);
    if (!cached) {
      return null;
    }

    // Check TTL
    const age = Date.now() - cached.timestamp.getTime();
    if (age > this.config.cacheTTL) {
      this.evaluationCache.delete(key);
      return null;
    }

    return cached;
  }

  /**
   * Set cache
   */
  private setCache(_key: string,  result: FlagEvaluationResult): void {
    // Check cache size limit
    if (this.evaluationCache.size >= this.config.maxCacheSize) {
      // Remove oldest entry
      const firstKey = this.evaluationCache.keys().next().value;
      if (_firstKey) {
        this.evaluationCache.delete(firstKey);
      }
    }

    this.evaluationCache.set(key, result);
  }

  /**
   * Clear cache for a specific flag
   */
  private clearCacheForFlag(_flagId: string): void {
    const keysToDelete: string[] = [];

    for (const key of this.evaluationCache.keys()) {
      if (key.startsWith(`${flagId}:`)) {
        keysToDelete.push(key);
      }
    }

    keysToDelete.forEach((key) => this.evaluationCache.delete(key));
  }

  /**
   * Cleanup cache and rate limiting data
   */
  private cleanupCache(): void {
    const now = Date.now();

    // Cleanup evaluation cache
    for (const [key, result] of this.evaluationCache.entries()) {
      const age = now - result.timestamp.getTime();
      if (age > this.config.cacheTTL) {
        this.evaluationCache.delete(key);
      }
    }

    // Cleanup rate limiting counters
    const windowMs = 1000; // 1 second window
    for (const [userId, timestamps] of this.evaluationCounters.entries()) {
      const validTimestamps = timestamps.filter((timestamp) => now - timestamp < windowMs);
      if (validTimestamps.length === 0) {
        this.evaluationCounters.delete(userId);
      } else {
        this.evaluationCounters.set(userId, validTimestamps);
      }
    }

    this.lastCleanupTime = now;
  }

  /**
   * Generate unique ID
   */
  private generateId(): string {
    return Math.random().toString(36).substring(2) + Date.now().toString(36);
  }

  // ============================================================================
  // Metrics and Monitoring
  // ============================================================================

  /**
   * Get service metrics
   */
  getMetrics(): {
    totalFlags: number;
    enabledFlags: number;
    totalCohorts: number;
    cacheSize: number;
    emergencyKillActive: boolean;
    evaluationRate: number;
  } {
    return {
      totalFlags: this.flags.size,
      enabledFlags: this.getAllFlags().filter((flag) => flag.status === FlagStatus.ENABLED).length,
      totalCohorts: this.cohorts.size,
      cacheSize: this.evaluationCache.size,
      emergencyKillActive: this.isEmergencyKillActive(),
      evaluationRate: this.calculateEvaluationRate(),
    };
  }

  /**
   * Calculate current evaluation rate
   */
  private calculateEvaluationRate(): number {
    const now = Date.now();
    const windowMs = 60000; // 1 minute window
    let totalEvaluations = 0;

    for (const timestamps of this.evaluationCounters.values()) {
      const recentEvaluations = timestamps.filter((timestamp) => now - timestamp < windowMs);
      totalEvaluations += recentEvaluations.length;
    }

    return totalEvaluations;
  }

  /**
   * Cleanup method
   */
  cleanup(): void {
    this.evaluationCache.clear();
    this.evaluationCounters.clear();
    this.flags.clear();
    this.cohorts.clear();
    this.removeAllListeners();

    logger.info('Feature Flag Service cleaned up');
  }
}

// Export singleton instance
export const featureFlagService = FeatureFlagService.getInstance();
