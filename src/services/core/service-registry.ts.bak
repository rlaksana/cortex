/**
 * Service Registry - P0-CRITICAL Implementation
 *
 * Central registry for service discovery and management.
 * Maintains service definitions and handles service lifecycle.
 *
 * @author Cortex Team
 * @version 2.0.1
 * @since 2025
 */

import { logger } from '../../utils/logger.js';
import type { ServiceDefinition } from './service-layer-router.js';

/**
 * Service health status
 */
export interface ServiceHealth {
  status: 'healthy' | 'degraded' | 'unhealthy';
  lastCheck: Date;
  checks: {
    name: string;
    status: 'pass' | 'fail' | 'warn';
    message?: string;
  }[];
}

/**
 * Service registry entry
 */
export interface ServiceRegistryEntry {
  definition: ServiceDefinition;
  health: ServiceHealth;
  registeredAt: Date;
  lastAccessed: Date;
  accessCount: number;
  metrics: {
    totalCalls: number;
    successfulCalls: number;
    failedCalls: number;
    averageResponseTime: number;
  };
}

/**
 * Service Registry - Central service management
 */
export class ServiceRegistry {
  private static instance: ServiceRegistry;
  private services: Map<string, ServiceRegistryEntry> = new Map();
  private healthCheckInterval?: NodeJS.Timeout;
  private isInitialized = false;

  private constructor() {}

  public static getInstance(): ServiceRegistry {
    if (!ServiceRegistry.instance) {
      ServiceRegistry.instance = new ServiceRegistry();
    }
    return ServiceRegistry.instance;
  }

  /**
   * Initialize service registry
   */
  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    try {
      logger.info('Initializing Service Registry...');

      // Setup periodic health checks
      this.setupHealthChecks();

      this.isInitialized = true;
      logger.info('Service Registry initialized successfully');
    } catch (error) {
      logger.error('Failed to initialize Service Registry:', error);
      throw error;
    }
  }

  /**
   * Register a service
   */
  public async registerService(serviceDefinition: ServiceDefinition): Promise<void> {
    const key = `${serviceDefinition.name}:${serviceDefinition.version}`;

    if (this.services.has(key)) {
      logger.warn(`Service already registered: ${key}, updating...`);
    }

    const entry: ServiceRegistryEntry = {
      definition: serviceDefinition,
      health: {
        status: 'healthy',
        lastCheck: new Date(),
        checks: [
          {
            name: 'registration',
            status: 'pass',
            message: 'Service successfully registered',
          },
        ],
      },
      registeredAt: new Date(),
      lastAccessed: new Date(),
      accessCount: 0,
      metrics: {
        totalCalls: 0,
        successfulCalls: 0,
        failedCalls: 0,
        averageResponseTime: 0,
      },
    };

    this.services.set(key, entry);
    logger.info(`Service registered: ${key}`);
  }

  /**
   * Get service by name and version
   */
  public getService(serviceName: string,  version?: string): ServiceDefinition | null {
    // Search for exact match first
    if (_version) {
      const key = `${serviceName}:${version}`;
      const entry = this.services.get(key);
      if (_entry) {
        entry.lastAccessed = new Date();
        entry.accessCount++;
        return entry.definition;
      }
    }

    // Search for latest version
    const entries = Array.from(this.services.values())
      .filter((entry) => entry.definition.name === serviceName)
      .sort((a,  _b) => b.registeredAt.getTime() - a.registeredAt.getTime());

    if (entries.length > 0) {
      const entry = entries[0];
      entry.lastAccessed = new Date();
      entry.accessCount++;
      return entry.definition;
    }

    return null;
  }

  /**
   * List all registered services
   */
  public listServices(): ServiceDefinition[] {
    return Array.from(this.services.values()).map((entry) => entry.definition);
  }

  /**
   * Get service health information
   */
  public getServiceHealth(serviceName: string,  version?: string): ServiceHealth | null {
    const key = version ? `${serviceName}:${version}` : serviceName;

    // Find matching service entry
    for (const [entryKey, entry] of this.services.entries()) {
      if (entryKey === key || entry.definition.name === serviceName) {
        return entry.health;
      }
    }

    return null;
  }

  /**
   * Update service metrics
   */
  public updateServiceMetrics(
    serviceName: string, 
    _version: string, 
    _success: boolean, 
    _responseTime: number
  ): void {
    const key = `${serviceName}:${version}`;
    const entry = this.services.get(key);

    if (_entry) {
      entry.metrics.totalCalls++;
      if (_success) {
        entry.metrics.successfulCalls++;
      } else {
        entry.metrics.failedCalls++;
      }

      // Update average response time
      const totalCalls = entry.metrics.totalCalls;
      entry.metrics.averageResponseTime =
        (entry.metrics.averageResponseTime * (totalCalls - 1) + responseTime) / totalCalls;
    }
  }

  /**
   * Unregister a service
   */
  public async unregisterService(serviceName: string, version?: string): Promise<boolean> {
    const key = version ? `${serviceName}:${version}` : serviceName;

    for (const [entryKey, entry] of this.services.entries()) {
      if (entryKey === key || (entry.definition.name === serviceName && !version)) {
        this.services.delete(entryKey);
        logger.info(`Service unregistered: ${entryKey}`);
        return true;
      }
    }

    return false;
  }

  /**
   * Get registry statistics
   */
  public getStatistics(): {
    totalServices: number;
    healthyServices: number;
    degradedServices: number;
    unhealthyServices: number;
    totalCalls: number;
    averageResponseTime: number;
  } {
    const entries = Array.from(this.services.values());

    const totalServices = entries.length;
    const healthyServices = entries.filter((e) => e.health.status === 'healthy').length;
    const degradedServices = entries.filter((e) => e.health.status === 'degraded').length;
    const unhealthyServices = entries.filter((e) => e.health.status === 'unhealthy').length;

    const totalCalls = entries.reduce((sum,  _e) => sum + e.metrics.totalCalls, 0);
    const averageResponseTime =
      entries.length > 0
        ? entries.reduce((sum,  _e) => sum + e.metrics.averageResponseTime, 0) / entries.length
        : 0;

    return {
      totalServices,
      healthyServices,
      degradedServices,
      unhealthyServices,
      totalCalls,
      averageResponseTime,
    };
  }

  /**
   * Cleanup inactive services
   */
  public async cleanupInactiveServices(maxInactiveHours: number = 24): Promise<number> {
    const cutoffTime = new Date(Date.now() - maxInactiveHours * 60 * 60 * 1000);
    let cleanedCount = 0;

    for (const [key, entry] of this.services.entries()) {
      if (entry.lastAccessed < cutoffTime && entry.definition.accessLevel !== 'restricted') {
        this.services.delete(key);
        cleanedCount++;
        logger.info(`Cleaned up inactive service: ${key}`);
      }
    }

    if (cleanedCount > 0) {
      logger.info(`Cleaned up ${cleanedCount} inactive services`);
    }

    return cleanedCount;
  }

  /**
   * Shutdown service registry
   */
  public async shutdown(): Promise<void> {
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
      this.healthCheckInterval = undefined;
    }

    this.services.clear();
    this.isInitialized = false;
    logger.info('Service Registry shutdown completed');
  }

  // Private methods

  private setupHealthChecks(): void {
    // Run health checks every 5 minutes
    this.healthCheckInterval = setInterval(
      () => {
        this.performHealthChecks();
      },
      5 * 60 * 1000
    );
  }

  private async performHealthChecks(): Promise<void> {
    const entries = Array.from(this.services.values());

    for (const entry of entries) {
      try {
        // Perform basic health check
        const healthCheck = await this.performServiceHealthCheck(entry);
        entry.health = healthCheck;
      } catch (error) {
        logger.warn(`Health check failed for service ${entry.definition.name}:`, error);
        entry.health.status = 'unhealthy';
        entry.health.lastCheck = new Date();
      }
    }
  }

  private async performServiceHealthCheck(entry: ServiceRegistryEntry): Promise<ServiceHealth> {
    const checks: ServiceHealth['checks'] = [];

    // Check if service has been accessed recently
    const timeSinceLastAccess = Date.now() - entry.lastAccessed.getTime();
    const isRecentlyAccessed = timeSinceLastAccess < 30 * 60 * 1000; // 30 minutes

    checks.push({
      name: 'accessibility',
      status: isRecentlyAccessed ? 'pass' : 'warn',
      message: isRecentlyAccessed
        ? 'Service recently accessed'
        : `Service not accessed for ${String(Math.floor(timeSinceLastAccess / 60000))} minutes`,
    });

    // Check error rate
    const errorRate =
      entry.metrics.totalCalls > 0 ? entry.metrics.failedCalls / entry.metrics.totalCalls : 0;

    checks.push({
      name: 'error_rate',
      status: errorRate > 0.1 ? 'fail' : errorRate > 0.05 ? 'warn' : 'pass',
      message: `Error rate: ${String((errorRate * 100).toFixed(2))}%`,
    });

    // Check response time
    checks.push({
      name: 'response_time',
      status:
        entry.metrics.averageResponseTime > 5000
          ? 'fail'
          : entry.metrics.averageResponseTime > 2000
            ? 'warn'
            : 'pass',
      message: `Average response time: ${String(entry.metrics.averageResponseTime.toFixed(0))}ms`,
    });

    // Determine overall health status
    const hasFailures = checks.some((check) => check.status === 'fail');
    const hasWarnings = checks.some((check) => check.status === 'warn');

    return {
      status: hasFailures ? 'unhealthy' : hasWarnings ? 'degraded' : 'healthy',
      lastCheck: new Date(),
      checks,
    };
  }
}

// Export singleton instance
export const serviceRegistry = ServiceRegistry.getInstance();
