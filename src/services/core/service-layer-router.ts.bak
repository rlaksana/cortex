/**
 * Service Layer Router - P0-CRITICAL Implementation
 *
 * Enforces service-layer routing for all database operations.
 * Prevents direct database access and ensures proper separation of concerns.
 *
 * Features:
 * - Centralized service routing
 * - Database access enforcement
 * - Service discovery and registration
 * - Request/response middleware
 * - Access control and audit logging
 *
 * @author Cortex Team
 * @version 2.0.1
 * @since 2025
 */

import { logger } from '../../utils/logger.js';
import { AccessController } from './access-controller.js';
import { AuditLogger } from './audit-logger.js';
import { PerformanceMonitor } from './performance-monitor.js';
import { ServiceRegistry } from './service-registry.js';

/**
 * Service request context
 */
export interface ServiceRequestContext {
  id: string;
  service: string;
  operation: string;
  parameters: Record<string, unknown>;
  user?: {
    id: string;
    roles: string[];
    permissions: string[];
  };
  metadata?: Record<string, unknown>;
  timestamp: Date;
}

/**
 * Service response
 */
export interface ServiceResponse {
  success: boolean;
  data?: unknown;
  error?: {
    code: string;
    message: string;
    details?: unknown;
  };
  metadata?: {
    executionTime: number;
    service: string;
    operation: string;
    requestId: string;
  };
}

/**
 * Service definition
 */
export interface ServiceDefinition {
  name: string;
  version: string;
  operations: ServiceOperation[];
  dependencies?: string[];
  accessLevel: 'public' | 'internal' | 'restricted';
}

/**
 * Service operation definition
 */
export interface ServiceOperation {
  name: string;
  handler: (context: ServiceRequestContext) => Promise<ServiceResponse>;
  requiredPermissions?: string[];
  rateLimit?: {
    requests: number;
    window: number; // seconds
  };
  timeout?: number; // milliseconds
  cacheable?: boolean;
  cacheTTL?: number; // seconds
}

/**
 * Service Layer Router - Enforces service-layer routing
 */
export class ServiceLayerRouter {
  private static instance: ServiceLayerRouter;
  private serviceRegistry: ServiceRegistry;
  private accessController: AccessController;
  private auditLogger: AuditLogger;
  private performanceMonitor: PerformanceMonitor;
  private isInitialized = false;

  private constructor() {
    this.serviceRegistry = ServiceRegistry.getInstance();
    this.accessController = AccessController.getInstance();
    this.auditLogger = AuditLogger.getInstance();
    this.performanceMonitor = PerformanceMonitor.getInstance();
  }

  public static getInstance(): ServiceLayerRouter {
    if (!ServiceLayerRouter.instance) {
      ServiceLayerRouter.instance = new ServiceLayerRouter();
    }
    return ServiceLayerRouter.instance;
  }

  /**
   * Initialize the service layer router
   */
  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    try {
      logger.info('Initializing Service Layer Router...');

      // Initialize core services
      await this.initializeCoreServices();

      // Register service definitions
      await this.registerServiceDefinitions();

      // Setup service monitoring
      this.setupServiceMonitoring();

      this.isInitialized = true;
      logger.info('Service Layer Router initialized successfully');
    } catch (error) {
      logger.error('Failed to initialize Service Layer Router:', error);
      throw error;
    }
  }

  /**
   * Route request through service layer
   */
  public async route(context: ServiceRequestContext): Promise<ServiceResponse> {
    if (!this.isInitialized) {
      throw new Error('Service Layer Router not initialized');
    }

    const startTime = Date.now();

    try {
      // Validate service and operation
      const service = this.serviceRegistry.getService(context.service);
      if (!service) {
        throw new Error(`Service not found: ${context.service}`);
      }

      const operation = service.operations.find((op) => op.name === context.operation);
      if (!operation) {
        throw new Error(`Operation not found: ${context.operation} in service: ${context.service}`);
      }

      // Check access permissions
      if (!(await this.accessController.checkAccess(context, operation))) {
        throw new Error(`Access denied for operation: ${context.operation}`);
      }

      // Check rate limits
      if (!(await this.accessController.checkRateLimit(context, operation))) {
        throw new Error(`Rate limit exceeded for operation: ${context.operation}`);
      }

      // Execute operation with timeout
      const result = await this.executeOperation(context, operation);

      // Log audit trail
      await this.auditLogger.logServiceCall(context, result);

      // Record performance metrics
      const executionTime = Date.now() - startTime;
      this.performanceMonitor.recordServiceCall(
        context.service,
        context.operation,
        executionTime,
        true
      );

      return {
        ...result,
        metadata: {
          executionTime,
          service: context.service,
          operation: context.operation,
          requestId: context.id,
        },
      };
    } catch (error) {
      const executionTime = Date.now() - startTime;

      // Log error and audit trail
      logger.error('Service routing failed:', error);
      await this.auditLogger.logServiceCall(context, {
        success: false,
        error: {
          code: 'SERVICE_ROUTING_ERROR',
          message: error instanceof Error ? error.message : 'Unknown error',
        },
      });

      // Record performance metrics
      this.performanceMonitor.recordServiceCall(
        context.service,
        context.operation,
        executionTime,
        false
      );

      return {
        success: false,
        error: {
          code: 'SERVICE_ROUTING_ERROR',
          message: error instanceof Error ? error.message : 'Unknown error',
        },
        metadata: {
          executionTime,
          service: context.service,
          operation: context.operation,
          requestId: context.id,
        },
      };
    }
  }

  /**
   * Register a new service
   */
  public async registerService(serviceDefinition: ServiceDefinition): Promise<void> {
    try {
      // Validate service definition
      this.validateServiceDefinition(serviceDefinition);

      // Register with service registry
      await this.serviceRegistry.registerService(serviceDefinition);

      logger.info(`Service registered: ${serviceDefinition.name} v${serviceDefinition.version}`);
    } catch (error) {
      logger.error(`Failed to register service: ${serviceDefinition.name}`, error);
      throw error;
    }
  }

  /**
   * Get service definition
   */
  public getService(serviceName: string): ServiceDefinition | null {
    return this.serviceRegistry.getService(serviceName);
  }

  /**
   * List all registered services
   */
  public listServices(): ServiceDefinition[] {
    return this.serviceRegistry.listServices();
  }

  /**
   * Check if direct database access is being attempted
   */
  public enforceServiceLayerAccess(_caller: string,  _operation: string): boolean {
    // List of allowed direct database access patterns (for system initialization only)
    const allowedDirectAccess = [
      'repository-factory',
      'qdrant-provider',
      'service-initializer',
      'migration-service',
    ];

    const isAllowed = allowedDirectAccess.some((allowed) => caller.includes(allowed));

    if (!isAllowed) {
      logger.warn(`Direct database access denied for caller: ${caller}, operation: ${operation}`);
      this.auditLogger.logSecurityEvent({
        type: 'UNAUTHORIZED_DB_ACCESS',
        caller,
        operation,
        timestamp: new Date(),
        severity: 'high',
      });
    }

    return isAllowed;
  }

  /**
   * Get router health status
   */
  public getHealthStatus(): Promise<{
    status: 'healthy' | 'degraded' | 'unhealthy';
    services: {
      total: number;
      healthy: number;
      degraded: number;
      unhealthy: number;
    };
    performance: {
      averageResponseTime: number;
      requestsPerSecond: number;
      errorRate: number;
    };
  }> {
    const services = this.serviceRegistry.listServices();
    const performanceMetrics = this.performanceMonitor.getAverageMetrics();

    return {
      status: this.calculateHealthStatus(services, performanceMetrics),
      services: {
        total: services.length,
        healthy: services.filter((s) => s.accessLevel !== 'restricted').length,
        degraded: 0, // TODO: Implement service health checks
        unhealthy: 0,
      },
      performance: {
        averageResponseTime: performanceMetrics.averageResponseTime || 0,
        requestsPerSecond: performanceMetrics.requestsPerSecond || 0,
        errorRate: performanceMetrics.errorRate || 0,
      },
    };
  }

  // Private methods

  private async initializeCoreServices(): Promise<void> {
    // Initialize core infrastructure services
    await this.serviceRegistry.initialize();
    await this.accessController.initialize();
    await this.auditLogger.initialize();
  }

  private async registerServiceDefinitions(): Promise<void> {
    // Register built-in service definitions
    const coreServices = this.getCoreServiceDefinitions();

    for (const service of coreServices) {
      await this.registerService(service);
    }
  }

  private setupServiceMonitoring(): void {
    // Setup performance monitoring and alerting
    this.performanceMonitor.addThreshold({
      metric: 'response_time',
      operator: '>',
      value: 5000,
      severity: 'medium',
      description: 'Service response time exceeded threshold',
    });
  }

  private async executeOperation(
    context: ServiceRequestContext,
    operation: ServiceOperation
  ): Promise<ServiceResponse> {
    // Apply timeout if specified
    if (operation.timeout) {
      return await this.withTimeout(operation.handler(context), operation.timeout);
    }

    return await operation.handler(context);
  }

  private withTimeout<T>(promise: Promise<T>, timeoutMs: number): Promise<T> {
    return Promise.race([
      promise, 
      new Promise<T>((_,  _reject) => {
        setTimeout(() => { reject(new Error(`Operation timeout after ${timeoutMs}ms`)); }, timeoutMs);
      }),
    ]);
  }

  private validateServiceDefinition(_service: ServiceDefinition): void {
    if (!service.name || !service.version) {
      throw new Error('Service name and version are required');
    }

    if (!service.operations || service.operations.length === 0) {
      throw new Error('Service must have at least one operation');
    }

    for (const operation of service.operations) {
      if (!operation.name || !operation.handler) {
        throw new Error('Operation must have name and handler');
      }
    }
  }

  private getCoreServiceDefinitions(): ServiceDefinition[] {
    return [
      {
        name: 'memory-store',
        version: '1.0.0',
        accessLevel: 'public',
        operations: [
          {
            name: 'store',
            handler: async (_context) => {
              try {
                // Delegate to memory store service
                const { MemoryStoreService } = await import('../memory/memory-store-service.js');
                const service = MemoryStoreService.getInstance();
                await service.initialize();
                return await service.store(context);
              } catch (error) {
                logger.error('Memory store service error:', error);
                return {
                  success: false,
                  error: {
                    code: 'SERVICE_ERROR',
                    message: error instanceof Error ? error.message : 'Unknown error',
                  },
                };
              }
            },
            requiredPermissions: ['memory:write'],
            timeout: 30000,
            cacheable: false,
          },
          {
            name: 'find',
            handler: async (_context) => {
              try {
                // Delegate to memory find service
                const { MemoryFindService } = await import('../memory/memory-find-service.js');
                const service = MemoryFindService.getInstance();
                await service.initialize();
                return await service.find(context);
              } catch (error) {
                logger.error('Memory find service error:', error);
                return {
                  success: false,
                  error: {
                    code: 'SERVICE_ERROR',
                    message: error instanceof Error ? error.message : 'Unknown error',
                  },
                };
              }
            },
            requiredPermissions: ['memory:read'],
            timeout: 10000,
            cacheable: true,
            cacheTTL: 300,
          },
        ],
      },
      {
        name: 'auth',
        version: '1.0.0',
        accessLevel: 'public',
        operations: [
          {
            name: 'authenticate',
            handler: async (_context) => {
              // Simple authentication stub for now
              return {
                success: true,
                data: {
                  authenticated: true,
                  userId: context.user?.id || 'anonymous',
                  timestamp: new Date().toISOString(),
                },
              };
            },
            timeout: 5000,
            cacheable: false,
          },
          {
            name: 'authorize',
            handler: async (_context) => {
              // Simple authorization stub for now
              return {
                success: true,
                data: {
                  authorized: true,
                  permissions: context.user?.permissions || ['read'],
                  timestamp: new Date().toISOString(),
                },
              };
            },
            requiredPermissions: ['auth:check'],
            timeout: 3000,
            cacheable: true,
            cacheTTL: 600,
          },
        ],
      },
    ];
  }

  private calculateHealthStatus(
    _services: ServiceDefinition[], 
    performanceMetrics: { errorRate?: number; averageResponseTime?: number }
  ): 'healthy' | 'degraded' | 'unhealthy' {
    const errorRate = performanceMetrics.errorRate || 0;
    const avgResponseTime = performanceMetrics.averageResponseTime || 0;

    if (errorRate > 0.1 || avgResponseTime > 5000) {
      return 'unhealthy';
    }

    if (errorRate > 0.05 || avgResponseTime > 2000) {
      return 'degraded';
    }

    return 'healthy';
  }
}

// Export singleton instance
export const serviceLayerRouter = ServiceLayerRouter.getInstance();

// Export convenience functions
export const routeThroughServiceLayer = (context: ServiceRequestContext) =>
  serviceLayerRouter.route(context);

export const registerService = (service: ServiceDefinition) =>
  serviceLayerRouter.registerService(service);

export const enforceServiceLayerAccess = (caller: string, operation: string) =>
  serviceLayerRouter.enforceServiceLayerAccess(caller, operation);

/**
 * Create service request context
 */
export function createServiceContext(
  _service: string, 
  _operation: string, 
  _parameters: Record<string,  unknown>, 
  user?: ServiceRequestContext['user'], 
  metadata?: Record<string,  unknown>
): ServiceRequestContext {
  return {
    id: `svc_${Date.now()}_${String(Math.random().toString(36).substr(2, 9))}`,
    service,
    operation,
    parameters,
    user,
    metadata,
    timestamp: new Date(),
  };
}
