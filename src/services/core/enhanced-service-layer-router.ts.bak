/**
 * Enhanced Service Layer Router with Constructor Injection
 *
 * This refactored version eliminates the singleton pattern and implements
 * proper dependency injection using the enhanced DI container. This reduces
 * tight coupling and improves testability.
 *
 * Key Improvements:
 * - Constructor injection instead of singleton pattern
 * - Interface-based dependencies for better abstraction
 * - Enhanced error handling and retry logic
 * - Improved performance monitoring
 * - Better separation of concerns
 *
 * @author MCP Cortex Team
 * @version 2.1.0
 * @since 2025
 */

import { Injectable, Inject, Optional, COMMON_TOKENS } from '../../di/enhanced-decorators.js';
import { ServiceLifetime } from '../../di/enhanced-di-container.js';
import { logger } from '../../utils/logger.js';

// ===== INTERFACES FOR DEPENDENCIES =====

export interface IServiceRegistry {
  initialize(): Promise<void>;
  registerService(serviceDefinition: ServiceDefinition): Promise<void>;
  getService(serviceName: string): ServiceDefinition | null;
  listServices(): ServiceDefinition[];
}

export interface IAccessController {
  initialize(): Promise<void>;
  checkAccess(context: ServiceRequestContext, operation: ServiceOperation): Promise<boolean>;
  checkRateLimit(context: ServiceRequestContext, operation: ServiceOperation): Promise<boolean>;
}

export interface IAuditLogger {
  initialize(): Promise<void>;
  logServiceCall(context: ServiceRequestContext, response: ServiceResponse): Promise<void>;
  logSecurityEvent(event: SecurityEvent): Promise<void>;
}

export interface IPerformanceMonitor {
  recordServiceCall(
    _service: string, 
    _operation: string, 
    _executionTime: number, 
    _success: boolean
  ): void;
  getAverageMetrics(): {
    averageResponseTime?: number;
    requestsPerSecond?: number;
    errorRate?: number;
  };
  addThreshold(threshold: {
    metric: string;
    operator: string;
    value: number;
    severity: string;
    description: string;
  }): void;
}

export interface ICircuitBreaker {
  execute<T>(
    operation: () => Promise<T>,
    operationName: string,
    options?: { timeout?: number; retries?: number }
  ): Promise<T>;
}

// ===== ENHANCED TYPES =====

export interface ServiceRequestContext {
  id: string;
  service: string;
  operation: string;
  parameters: Record<string, unknown>;
  user?: {
    id: string;
    roles: string[];
    permissions: string[];
  };
  metadata?: Record<string, unknown>;
  timestamp: Date;
  retryCount?: number;
  timeout?: number;
}

export interface ServiceResponse {
  success: boolean;
  data?: unknown;
  error?: {
    code: string;
    message: string;
    details?: unknown;
    retryable?: boolean;
  };
  metadata?: {
    executionTime: number;
    service: string;
    operation: string;
    requestId: string;
    retryCount?: number;
    cacheHit?: boolean;
  };
}

export interface ServiceDefinition {
  name: string;
  version: string;
  operations: ServiceOperation[];
  dependencies?: string[];
  accessLevel: 'public' | 'internal' | 'restricted';
  healthCheck?: () => Promise<boolean>;
  circuitBreaker?: {
    failureThreshold: number;
    recoveryTimeout: number;
  };
}

export interface ServiceOperation {
  name: string;
  handler: (context: ServiceRequestContext) => Promise<ServiceResponse>;
  requiredPermissions?: string[];
  rateLimit?: {
    requests: number;
    window: number;
  };
  timeout?: number;
  cacheable?: boolean;
  cacheTTL?: number;
  retries?: {
    maxAttempts: number;
    backoffMs: number;
  };
}

export interface SecurityEvent {
  type: string;
  caller: string;
  operation: string;
  timestamp: Date;
  severity: 'low' | 'medium' | 'high' | 'critical';
  details?: unknown;
}

export interface RouterConfiguration {
  enableCircuitBreaker: boolean;
  enableRetry: boolean;
  enableCaching: boolean;
  defaultTimeout: number;
  maxRetries: number;
  circuitBreakerThreshold: number;
  cacheEnabled: boolean;
  security: {
    enableAuditLogging: boolean;
    enableAccessControl: boolean;
    unauthorizedDbAccessAction: 'log' | 'block' | 'both';
  };
}

// ===== ENHANCED SERVICE LAYER ROUTER =====

@Injectable({
  lifetime: ServiceLifetime.SINGLETON,
  tags: ['core', 'routing', 'service-layer'],
})
export class EnhancedServiceLayerRouter {
  private isInitialized = false;
  private config: RouterConfiguration;
  private serviceMetrics = new Map<string, ServiceMetrics>();

  constructor(
    @Inject(COMMON_TOKENS.SERVICE_REGISTRY)
    private readonly serviceRegistry: IServiceRegistry,

    @Inject(COMMON_TOKENS.ACCESS_CONTROLLER)
    private readonly accessController: IAccessController,

    @Inject(COMMON_TOKENS.AUDIT_SERVICE)
    private readonly auditLogger: IAuditLogger,

    @Inject(COMMON_TOKENS.PERFORMANCE_MONITOR)
    private readonly performanceMonitor: IPerformanceMonitor,

    @Optional()
    @Inject('CIRCUIT_BREAKER')
    private readonly circuitBreaker?: ICircuitBreaker,

    @Optional()
    @Inject('ROUTER_CONFIG')
    config?: Partial<RouterConfiguration>
  ) {
    this.config = this.mergeConfiguration(config);
  }

  /**
   * Initialize the enhanced service layer router
   */
  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    try {
      logger.info('Initializing Enhanced Service Layer Router...');

      // Initialize all injected dependencies
      await this.initializeDependencies();

      // Register built-in service definitions
      await this.registerBuiltInServices();

      // Setup monitoring and health checks
      this.setupMonitoring();

      this.isInitialized = true;
      logger.info('Enhanced Service Layer Router initialized successfully');
    } catch (error) {
      logger.error('Failed to initialize Enhanced Service Layer Router:', error);
      throw error;
    }
  }

  /**
   * Route request through service layer with enhanced capabilities
   */
  public async route(context: ServiceRequestContext): Promise<ServiceResponse> {
    if (!this.isInitialized) {
      throw new Error('Enhanced Service Layer Router not initialized');
    }

    const startTime = Date.now();
    const retryCount = context.retryCount || 0;

    try {
      // Validate service and operation
      const service = await this.validateService(context.service);
      const operation = await this.validateOperation(service, context.operation);

      // Create enhanced context with defaults
      const enhancedContext = this.createEnhancedContext(context, operation);

      // Execute with circuit breaker if enabled
      const result =
        this.config.enableCircuitBreaker && this.circuitBreaker
          ? await this.circuitBreaker.execute(
              () => this.executeServiceCall(enhancedContext, service, operation),
              `${service.name}.${operation.name}`,
              { timeout: operation.timeout || this.config.defaultTimeout }
            )
          : await this.executeServiceCall(enhancedContext, service, operation);

      // Update metrics
      await this.updateMetrics(
        context.service,
        context.operation,
        Date.now() - startTime,
        true,
        retryCount
      );

      return {
        ...result,
        metadata: {
          executionTime: Date.now() - startTime,
          service: context.service,
          operation: context.operation,
          requestId: context.id,
          retryCount,
        },
      };
    } catch (error) {
      const executionTime = Date.now() - startTime;

      // Enhanced error handling with retry logic
      if (this.shouldRetry(error, retryCount)) {
        logger.warn(
          `Retrying service call ${context.service}.${context.operation} (attempt ${String(retryCount + 1)})`
        );

        return this.route({
          ...context,
          retryCount: retryCount + 1,
        });
      }

      await this.handleRoutingError(context, error as Error, executionTime, retryCount);

      return this.createErrorResponse(context, error as Error, executionTime, retryCount);
    }
  }

  /**
   * Register a new service with enhanced validation
   */
  public async registerService(serviceDefinition: ServiceDefinition): Promise<void> {
    try {
      this.validateServiceDefinition(serviceDefinition);

      // Initialize service circuit breaker if configured
      if (serviceDefinition.circuitBreaker && this.circuitBreaker) {
        logger.info(`Setting up circuit breaker for service: ${serviceDefinition.name}`);
      }

      await this.serviceRegistry.registerService(serviceDefinition);

      // Initialize service metrics
      this.serviceMetrics.set(serviceDefinition.name, {
        totalCalls: 0,
        successfulCalls: 0,
        failedCalls: 0,
        averageResponseTime: 0,
        lastCalled: null,
      });

      logger.info(`Service registered: ${serviceDefinition.name} v${serviceDefinition.version}`);
    } catch (error) {
      logger.error(`Failed to register service: ${serviceDefinition.name}`, error);
      throw error;
    }
  }

  /**
   * Get service definition
   */
  public getService(serviceName: string): ServiceDefinition | null {
    return this.serviceRegistry.getService(serviceName);
  }

  /**
   * List all registered services with health status
   */
  public listServices(): Promise<
    (ServiceDefinition & { health: 'healthy' | 'unhealthy' | 'unknown' | 'degraded' })[]
  > {
    const services = this.serviceRegistry.listServices();

    return Promise.all(
      services.map(async (service) => ({
        ...service,
        health: service.healthCheck ? await this.checkServiceHealth(service) : 'unknown',
      }))
    );
  }

  /**
   * Enhanced service layer access enforcement
   */
  public enforceServiceLayerAccess(
    _caller: string, 
    _operation: string, 
    context?: { userId?: string; sessionId?: string }
  ): { allowed: boolean; reason?: string; alternativeService?: string } {
    const allowedCallers = [
      'repository-factory',
      'qdrant-provider',
      'service-initializer',
      'migration-service',
      'enhanced-service-layer-router',
    ];

    const isAllowed = allowedCallers.some((allowed) => caller.includes(allowed));

    if (!isAllowed) {
      const reason = `Direct database access denied for caller: ${caller}, operation: ${operation}`;

      if (this.config.security.unauthorizedDbAccessAction !== 'block') {
        logger.warn(reason);
      }

      if (this.config.security.enableAuditLogging) {
        this.auditLogger.logSecurityEvent({
          type: 'UNAUTHORIZED_DB_ACCESS',
          caller,
          operation,
          timestamp: new Date(),
          severity: 'high',
          details: { context },
        });
      }

      if (this.config.security.unauthorizedDbAccessAction === 'block') {
        return { allowed: false, reason };
      }
    }

    // Suggest alternative service
    const alternativeService = this.suggestAlternativeService(operation);

    return {
      allowed: isAllowed || this.config.security.unauthorizedDbAccessAction !== 'block',
      reason: isAllowed ? undefined : `Use ${alternativeService} service instead`,
      alternativeService,
    };
  }

  /**
   * Get comprehensive health status
   */
  public getHealthStatus(): Promise<{
    status: 'healthy' | 'degraded' | 'unhealthy';
    services: {
      total: number;
      healthy: number;
      degraded: number;
      unhealthy: number;
    };
    performance: {
      averageResponseTime: number;
      requestsPerSecond: number;
      errorRate: number;
      circuitBreakerStatus: 'closed' | 'open' | 'half-open';
    };
    dependencies: {
      serviceRegistry: boolean;
      accessController: boolean;
      auditLogger: boolean;
      performanceMonitor: boolean;
      circuitBreaker?: boolean;
    };
  }> {
    const services = await this.listServices();
    const performanceMetrics = this.performanceMonitor.getAverageMetrics();

    return {
      status: this.calculateHealthStatus(services, performanceMetrics),
      services: {
        total: services.length,
        healthy: services.filter((s) => s.health === 'healthy').length,
        degraded: services.filter((s) => s.health === 'degraded').length,
        unhealthy: services.filter((s) => s.health === 'unhealthy').length,
      },
      performance: {
        averageResponseTime: performanceMetrics.averageResponseTime || 0,
        requestsPerSecond: performanceMetrics.requestsPerSecond || 0,
        errorRate: performanceMetrics.errorRate || 0,
        circuitBreakerStatus: 'closed', // TODO: Get from circuit breaker
      },
      dependencies: {
        serviceRegistry: true, // TODO: Add health checks to dependencies
        accessController: true,
        auditLogger: true,
        performanceMonitor: true,
        circuitBreaker: !!this.circuitBreaker,
      },
    };
  }

  // ===== PRIVATE METHODS =====

  private mergeConfiguration(config?: Partial<RouterConfiguration>): RouterConfiguration {
    return {
      enableCircuitBreaker: true,
      enableRetry: true,
      enableCaching: true,
      defaultTimeout: 30000,
      maxRetries: 3,
      circuitBreakerThreshold: 5,
      cacheEnabled: true,
      security: {
        enableAuditLogging: true,
        enableAccessControl: true,
        unauthorizedDbAccessAction: 'both',
      },
      ...config,
    };
  }

  private async initializeDependencies(): Promise<void> {
    await Promise.all([
      this.serviceRegistry.initialize(),
      this.accessController.initialize(),
      this.auditLogger.initialize(),
    ]);
  }

  private async registerBuiltInServices(): Promise<void> {
    const coreServices = this.getBuiltInServiceDefinitions();

    for (const service of coreServices) {
      await this.registerService(service);
    }
  }

  private setupMonitoring(): void {
    this.performanceMonitor.addThreshold({
      metric: 'response_time',
      operator: '>',
      value: this.config.defaultTimeout * 0.8, // 80% of default timeout
      severity: 'medium',
      description: 'Service response time exceeded threshold',
    });
  }

  private async validateService(serviceName: string): Promise<ServiceDefinition> {
    const service = this.serviceRegistry.getService(serviceName);
    if (!service) {
      throw new Error(`Service not found: ${serviceName}`);
    }
    return service;
  }

  private async validateOperation(
    service: ServiceDefinition,
    operationName: string
  ): Promise<ServiceOperation> {
    const operation = service.operations.find((op) => op.name === operationName);
    if (!operation) {
      throw new Error(`Operation not found: ${operationName} in service: ${service.name}`);
    }
    return operation;
  }

  private createEnhancedContext(
    context: ServiceRequestContext, 
    _operation: ServiceOperation
  ): ServiceRequestContext {
    return {
      ...context,
      timeout: operation.timeout || this.config.defaultTimeout,
    };
  }

  private async executeServiceCall(
    context: ServiceRequestContext,
    service: ServiceDefinition,
    operation: ServiceOperation
  ): Promise<ServiceResponse> {
    // Check access permissions if enabled
    if (this.config.security.enableAccessControl) {
      const hasAccess = await this.accessController.checkAccess(context, operation);
      if (!hasAccess) {
        throw new Error(`Access denied for operation: ${operation.name}`);
      }
    }

    // Check rate limits
    if (!(await this.accessController.checkRateLimit(context, operation))) {
      throw new Error(`Rate limit exceeded for operation: ${operation.name}`);
    }

    // Execute the operation
    const result = await operation.handler(context);

    // Log audit trail if enabled
    if (this.config.security.enableAuditLogging) {
      await this.auditLogger.logServiceCall(context, result);
    }

    return result;
  }

  private shouldRetry(error: unknown,  _retryCount: number): boolean {
    if (!this.config.enableRetry || retryCount >= this.config.maxRetries) {
      return false;
    }

    const retryableErrors = [
      'TIMEOUT',
      'CONNECTION_ERROR',
      'SERVICE_UNAVAILABLE',
      'CIRCUIT_BREAKER_OPEN',
    ];

    return (
      retryableErrors.includes(error.code) ||
      (error instanceof Error &&
        (error.message.includes('timeout') ||
          error.message.includes('connection') ||
          error.message.includes('unavailable')))
    );
  }

  private async handleRoutingError(
    context: ServiceRequestContext,
    error: Error,
    executionTime: number,
    retryCount: number
  ): Promise<void> {
    logger.error('Service routing failed:', error);

    if (this.config.security.enableAuditLogging) {
      await this.auditLogger.logServiceCall(context, {
        success: false,
        error: {
          code: error.name,
          message: error.message,
          retryable: this.shouldRetry(error, retryCount),
        },
      });
    }

    await this.updateMetrics(context.service, context.operation, executionTime, false, retryCount);
  }

  private createErrorResponse(
    context: ServiceRequestContext, 
    error: Error, 
    _executionTime: number, 
    _retryCount: number
  ): ServiceResponse {
    return {
      success: false,
      error: {
        code: error.name,
        message: error.message,
        retryable: this.shouldRetry(error, retryCount),
      },
      metadata: {
        executionTime,
        service: context.service,
        operation: context.operation,
        requestId: context.id,
        retryCount,
      },
    };
  }

  private suggestAlternativeService(_operation: string): string {
    const operationMap: Record<string, string> = {
      qdrant: 'memory-store',
      vector: 'memory-find',
      repository: 'memory-store',
      database: 'memory-store',
      embedding: 'memory-find',
    };

    for (const [key, service] of Object.entries(operationMap)) {
      if (operation.toLowerCase().includes(key)) {
        return service;
      }
    }

    return 'memory-store';
  }

  private async checkServiceHealth(
    service: ServiceDefinition
  ): Promise<'healthy' | 'unhealthy' | 'unknown'> {
    if (!service.healthCheck) {
      return 'unknown';
    }

    try {
      const isHealthy = await service.healthCheck();
      return isHealthy ? 'healthy' : 'unhealthy';
    } catch (error) {
      logger.warn(`Health check failed for service ${service.name}:`, error);
      return 'unhealthy';
    }
  }

  private calculateHealthStatus(
    services: (ServiceDefinition & { health: 'healthy' | 'unhealthy' | 'unknown' | 'degraded' })[],
    performanceMetrics: unknown
  ): 'healthy' | 'degraded' | 'unhealthy' {
    const errorRate = performanceMetrics.errorRate || 0;
    const avgResponseTime = performanceMetrics.averageResponseTime || 0;
    const unhealthyServices = services.filter((s) => s.health === 'unhealthy').length;

    if (errorRate > 0.1 || avgResponseTime > this.config.defaultTimeout || unhealthyServices > 0) {
      return 'unhealthy';
    }

    if (errorRate > 0.05 || avgResponseTime > this.config.defaultTimeout * 0.5) {
      return 'degraded';
    }

    return 'healthy';
  }

  private async updateMetrics(
    service: string,
    operation: string,
    executionTime: number,
    success: boolean,
    retryCount: number
  ): Promise<void> {
    // Update performance monitor
    this.performanceMonitor.recordServiceCall(service, operation, executionTime, success);

    // Update service-specific metrics
    const existing = this.serviceMetrics.get(service) || {
      totalCalls: 0,
      successfulCalls: 0,
      failedCalls: 0,
      averageResponseTime: 0,
      lastCalled: null,
    };

    const updated = {
      totalCalls: existing.totalCalls + 1,
      successfulCalls: existing.successfulCalls + (success ? 1 : 0),
      failedCalls: existing.failedCalls + (success ? 0 : 1),
      averageResponseTime:
        (existing.averageResponseTime * existing.totalCalls + executionTime) /
        (existing.totalCalls + 1),
      lastCalled: new Date(),
    };

    this.serviceMetrics.set(service, updated);
  }

  private validateServiceDefinition(_service: ServiceDefinition): void {
    if (!service.name || !service.version) {
      throw new Error('Service name and version are required');
    }

    if (!service.operations || service.operations.length === 0) {
      throw new Error('Service must have at least one operation');
    }

    for (const operation of service.operations) {
      if (!operation.name || !operation.handler) {
        throw new Error('Operation must have name and handler');
      }
    }
  }

  private getBuiltInServiceDefinitions(): ServiceDefinition[] {
    return [
      {
        name: 'memory-store',
        version: '2.0.0',
        accessLevel: 'public',
        operations: [
          {
            name: 'store',
            handler: async (_context) => {
              try {
                // Basic memory store implementation for now
                logger.info('Memory store operation called', { operation: context.operation });
                return {
                  success: true,
                  data: { message: 'Memory store operation completed' },
                };
              } catch (error) {
                logger.error('Memory store service error:', error);
                return {
                  success: false,
                  error: {
                    code: 'SERVICE_ERROR',
                    message: error instanceof Error ? error.message : 'Unknown error',
                  },
                };
              }
            },
            requiredPermissions: ['memory:write'],
            timeout: 30000,
            cacheable: false,
            retries: {
              maxAttempts: 2,
              backoffMs: 1000,
            },
          },
        ],
        healthCheck: async () => {
          // Basic health check - could be expanded
          return true;
        },
      },
    ];
  }
}

// ===== SUPPORTING TYPES =====

interface ServiceMetrics {
  totalCalls: number;
  successfulCalls: number;
  failedCalls: number;
  averageResponseTime: number;
  lastCalled: Date | null;
}

// ===== EXPORTS =====

export default EnhancedServiceLayerRouter;
