/**
 * Cortex Memory MCP - Schema Validation Utilities
 *
 * Comprehensive schema validation using both Zod and JSON Schema validators.
 * Provides runtime validation, detailed error reporting, and migration support.
 *
 * @version 2.0.0 - Enhanced with P5-2 schema updates
 */

import type { ZodSchema, ZodError } from 'zod';
import { ALL_JSON_SCHEMAS } from './json-schemas.js';
import {
  EnhancedMemoryStoreInputSchema,
  EnhancedMemoryFindInputSchema,
  SystemStatusInputSchema,
  PerformanceMonitoringInputSchema,
  MemoryStoreInputSchema,
  MemoryFindInputSchema,
  ValidationError,
} from './mcp-inputs.js';

// ============================================================================
// Schema Types
// ============================================================================

export type SchemaName = keyof typeof ALL_JSON_SCHEMAS;

export interface ValidationResult {
  valid: boolean;
  errors: ValidationError[];
  warnings: string[];
  migrated: boolean;
  migration_notes?: string[];
}

export interface ValidationOptions {
  strictMode?: boolean;
  enableMigration?: boolean;
  includeWarnings?: boolean;
  maxErrors?: number;
}

// ============================================================================
// Configuration Interfaces
// ============================================================================

export interface SchemaValidationConfig {
  strictMode?: boolean;
  enableMigration?: boolean;
  includeWarnings?: boolean;
  maxErrors?: number;
  enablePerformanceChecks?: boolean;
  timeout?: number;
}

export interface MemoryStoreBusinessRuleData {
  items: unknown[];
  deduplication?: {
    enabled: boolean;
    cross_scope_deduplication?: boolean;
    check_within_scope_only?: boolean;
  };
}

export interface MemoryFindBusinessRuleData {
  limit?: number;
  offset?: number;
  filters?: {
    created_after?: string;
    created_before?: string;
  };
  graph_expansion?: {
    enabled: boolean;
    max_depth?: number;
    max_nodes?: number;
  };
}

export interface SystemStatusBusinessRuleData {
  operation: string;
  document_id?: string;
  cleanup_token?: string;
}

export interface PerformanceMonitoringBusinessRuleData {
  time_window?: {
    start_time?: string;
    end_time?: string;
    last_hours?: number;
    last_days?: number;
  };
}

// Type guards for business rule data
export function isMemoryStoreBusinessRuleData(data: unknown): data is MemoryStoreBusinessRuleData {
  return (
    typeof data === 'object' &&
    data !== null &&
    'items' in data &&
    Array.isArray((data as unknown).items)
  );
}

export function isMemoryFindBusinessRuleData(data: unknown): data is MemoryFindBusinessRuleData {
  return typeof data === 'object' && data !== null;
}

export function isSystemStatusBusinessRuleData(
  data: unknown
): data is SystemStatusBusinessRuleData {
  return typeof data === 'object' && data !== null && 'operation' in data;
}

export function isPerformanceMonitoringBusinessRuleData(
  data: unknown
): data is PerformanceMonitoringBusinessRuleData {
  return typeof data === 'object' && data !== null;
}

// ============================================================================
// Migration Support
// ============================================================================

/**
 * Legacy to enhanced schema migration utilities
 */
class SchemaMigrator {
  /**
   * Migrate legacy memory_store input to enhanced format
   */
  static migrateMemoryStore(input: unknown): unknown {
    const migrated = { ...input };
    const notes: string[] = [];

    // Add default processing options if not present
    if (!migrated.processing) {
      migrated.processing = {
        enable_validation: true,
        enable_async_processing: false,
        batch_processing: true,
        return_summaries: false,
        include_metrics: true,
      };
      notes.push('Added default processing options');
    }

    // Add default deduplication if not present
    if (!migrated.deduplication) {
      migrated.deduplication = {
        enabled: true,
        merge_strategy: 'intelligent',
        similarity_threshold: 0.85,
        check_within_scope_only: true,
        max_history_hours: 168,
        dedupe_window_days: 30,
        allow_newer_versions: true,
        enable_audit_logging: true,
        enable_intelligent_merging: true,
        preserve_merge_history: false,
        cross_scope_deduplication: false,
        prioritize_same_scope: true,
        time_based_deduplication: true,
        max_age_for_dedupe_days: 90,
        respect_update_timestamps: true,
        max_items_to_check: 100,
        batch_size: 50,
        enable_parallel_processing: false,
      };
      notes.push('Added default deduplication configuration');
    }

    // Convert legacy scope format if needed
    if (migrated.items) {
      migrated.items = migrated.items.map((item: unknown) => {
        const migratedItem = { ...item };

        // Ensure scope has all supported fields
        if (migratedItem.scope && !migratedItem.scope.service) {
          migratedItem.scope = {
            ...migratedItem.scope,
            service: undefined,
            sprint: undefined,
            tenant: undefined,
            environment: undefined,
          };
          notes.push('Enhanced scope fields for item compatibility');
        }

        // Add default TTL config for text-based items
        if (migratedItem.content && !migratedItem.ttl_config) {
          migratedItem.ttl_config = {
            policy: 'default',
            auto_extend: false,
          };
        }

        // Add default truncation config for text-based items
        if (migratedItem.content && !migratedItem.truncation_config) {
          migratedItem.truncation_config = {
            enabled: true,
            max_chars: 10000,
            mode: 'intelligent',
            preserve_structure: true,
            add_indicators: true,
          };
        }

        return migratedItem;
      });
    }

    return { migrated, notes };
  }

  /**
   * Migrate legacy memory_find input to enhanced format
   */
  static migrateMemoryFind(input: unknown): unknown {
    const migrated = { ...input };
    const notes: string[] = [];

    // Convert 'mode' to 'search_strategy'
    if (migrated.mode && !migrated.search_strategy) {
      migrated.search_strategy = migrated.mode;
      delete migrated.mode;
      notes.push('Converted "mode" to "search_strategy"');
    }

    // Convert 'top_k' to 'limit'
    if (migrated.top_k && !migrated.limit) {
      migrated.limit = migrated.top_k;
      delete migrated.top_k;
      notes.push('Converted "top_k" to "limit"');
    }

    // Add default search optimization if not present
    if (!migrated.optimization) {
      migrated.optimization = {
        enable_caching: true,
        cache_ttl_seconds: 300,
        parallel_search: true,
        timeout_ms: 10000,
      };
      notes.push('Added default search optimization');
    }

    // Add default result formatting if not present
    if (!migrated.formatting) {
      migrated.formatting = {
        include_content: true,
        include_metadata: true,
        include_relations: false,
        include_confidence_scores: true,
        include_similarity_explanation: false,
        highlight_matches: false,
        max_content_length: 1000,
      };
      notes.push('Added default result formatting');
    }

    // Enhance scope if present
    if (migrated.scope) {
      migrated.scope = {
        ...migrated.scope,
        service: migrated.scope.service || undefined,
        sprint: migrated.scope.sprint || undefined,
        tenant: migrated.scope.tenant || undefined,
        environment: migrated.scope.environment || undefined,
      };
      notes.push('Enhanced scope fields');
    }

    return { migrated, notes };
  }

  /**
   * Migrate legacy system_status input to enhanced format
   */
  static migrateSystemStatus(input: unknown): unknown {
    const migrated = { ...input };
    const notes: string[] = [];

    // Add default response formatting if not present
    if (!migrated.response_formatting) {
      migrated.response_formatting = {
        summary: false,
        verbose: false,
        include_raw_data: false,
        include_timestamps: true,
      };
      notes.push('Added default response formatting');
    }

    // Enhance scope if present
    if (migrated.scope) {
      migrated.scope = {
        ...migrated.scope,
        service: migrated.scope.service || undefined,
        sprint: migrated.scope.sprint || undefined,
        tenant: migrated.scope.tenant || undefined,
        environment: migrated.scope.environment || undefined,
      };
      notes.push('Enhanced scope fields');
    }

    return { migrated, notes };
  }
}

// ============================================================================
// Schema Validation Engine
// ============================================================================

export class SchemaValidator {
  private static instance: SchemaValidator;
  private jsonSchemaValidator: unknown = null;

  private constructor() {
    // Initialize JSON Schema validator if available
    this.initializeJsonSchemaValidator();
  }

  static getInstance(): SchemaValidator {
    if (!SchemaValidator.instance) {
      SchemaValidator.instance = new SchemaValidator();
    }
    return SchemaValidator.instance;
  }

  private initializeJsonSchemaValidator(): void {
    try {
      // Try to import and initialize AJV or similar JSON Schema validator
      // This is optional - if not available, we'll fall back to Zod only
      // const Ajv = require('ajv');
      // this.jsonSchemaValidator = new Ajv({ allErrors: true });
    } catch (error) {
      // JSON Schema validator not available, will use Zod only
      console.warn('JSON Schema validator not available, using Zod only');
    }
  }

  /**
   * Validate input against enhanced schema with migration support
   */
  validateEnhanced(
    _schemaName: SchemaName, 
    input: unknown, 
    options: ValidationOptions = {}
  ): ValidationResult {
    const {
      strictMode = false,
      enableMigration = true,
      includeWarnings = true,
      maxErrors = 50,
    } = options;

    const result: ValidationResult = {
      valid: true,
      errors: [],
      warnings: [],
      migrated: false,
    };

    try {
      let validatedInput = input;

      // Step 1: Attempt migration if enabled
      if (_enableMigration) {
        const migrationResult = this.migrateLegacyInput(schemaName, input);
        if (migrationResult.migrated) {
          validatedInput = migrationResult.input;
          result.migrated = true;
          result.migration_notes = migrationResult.notes;
          if (_includeWarnings) {
            result.warnings.push(...migrationResult.notes.map((note) => `Migration: ${note}`));
          }
        }
      }

      // Step 2: Validate with enhanced Zod schema
      const zodSchema = this.getZodSchema(schemaName);
      const zodResult = zodSchema.safeParse(validatedInput);

      if (!zodResult.success) {
        result.valid = false;
        result.errors.push(...this.convertZodErrors(zodResult.error, maxErrors));
        return result;
      }

      // Step 3: Additional JSON Schema validation if available
      if (this.jsonSchemaValidator && !strictMode) {
        const jsonSchemaErrors = this.validateJsonSchema(schemaName, validatedInput);
        if (jsonSchemaErrors.length > 0) {
          if (_strictMode) {
            result.valid = false;
            result.errors.push(...jsonSchemaErrors.map((err) => new ValidationError(err)));
          } else {
            result.warnings.push(...jsonSchemaErrors.map((err) => `JSON Schema: ${err}`));
          }
        }
      }

      // Step 4: Business rule validation
      const businessRuleErrors = this.validateBusinessRules(schemaName, zodResult.data);
      if (businessRuleErrors.length > 0) {
        result.valid = false;
        result.errors.push(...businessRuleErrors);
      }

      // Step 5: Generate warnings for potential issues
      if (_includeWarnings) {
        const warnings = this.generateWarnings(schemaName, zodResult.data);
        result.warnings.push(...warnings);
      }

      return result;
    } catch (error) {
      result.valid = false;
      result.errors.push(
        new ValidationError(
          `Validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`
        )
      );
      return result;
    }
  }

  /**
   * Validate input against legacy schema for backward compatibility
   */
  validateLegacy(_schemaName: 'memory_store' | 'memory_find',  input: unknown): ValidationResult {
    const result: ValidationResult = {
      valid: true,
      errors: [],
      warnings: [],
      migrated: false,
    };

    try {
      const zodSchema =
        schemaName === 'memory_store' ? MemoryStoreInputSchema : MemoryFindInputSchema;
      const zodResult = zodSchema.safeParse(input);

      if (!zodResult.success) {
        result.valid = false;
        result.errors.push(...this.convertZodErrors(zodResult.error));
      }

      return result;
    } catch (error) {
      result.valid = false;
      result.errors.push(
        new ValidationError(
          `Legacy validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`
        )
      );
      return result;
    }
  }

  /**
   * Get the appropriate Zod schema for validation
   */
  private getZodSchema(_schemaName: SchemaName): ZodSchema {
    switch (_schemaName) {
      case 'memory_store':
        return EnhancedMemoryStoreInputSchema;
      case 'memory_find':
        return EnhancedMemoryFindInputSchema;
      case 'system_status':
        return SystemStatusInputSchema;
      case 'performance_monitoring':
        return PerformanceMonitoringInputSchema;
      default:
        throw new Error(`Unknown schema: ${schemaName}`);
    }
  }

  /**
   * Convert Zod errors to ValidationError objects
   */
  private convertZodErrors(_zodError: ZodError,  maxErrors = 50): ValidationError[] {
    return zodError.errors.slice(0, maxErrors).map((error) => {
      const field = error.path.join('.');
      const message = error.message || 'Validation failed';
      return new ValidationError(`Validation failed: ${message}`, field, error.code);
    });
  }

  /**
   * Validate using JSON Schema if available
   */
  private validateJsonSchema(_schemaName: SchemaName,  input: unknown): string[] {
    if (!this.jsonSchemaValidator) {
      return [];
    }

    try {
      const jsonSchema = ALL_JSON_SCHEMAS[schemaName];
      const validate = this.jsonSchemaValidator.compile(jsonSchema);
      const valid = validate(input);

      if (!valid && validate.errors) {
        return validate.errors.map(
          (err: unknown) => `${err.instancePath || 'root'}: ${err.message}`
        );
      }

      return [];
    } catch (error) {
      return [
        `JSON Schema validation error: ${error instanceof Error ? error.message : 'Unknown error'}`,
      ];
    }
  }

  /**
   * Validate business rules specific to each schema
   */
  private validateBusinessRules(_schemaName: SchemaName,  data: unknown): ValidationError[] {
    const errors: ValidationError[] = [];

    switch (_schemaName) {
      case 'memory_store':
        errors.push(...this.validateMemoryStoreBusinessRules(data));
        break;
      case 'memory_find':
        errors.push(...this.validateMemoryFindBusinessRules(data));
        break;
      case 'system_status':
        errors.push(...this.validateSystemStatusBusinessRules(data));
        break;
      case 'performance_monitoring':
        errors.push(...this.validatePerformanceMonitoringBusinessRules(data));
        break;
      default:
        // No business rules for unknown schema types
        break;
    }

    return errors;
  }

  /**
   * Business rule validation for memory_store
   */
  private validateMemoryStoreBusinessRules(data: unknown): ValidationError[] {
    const errors: ValidationError[] = [];

    if (!isMemoryStoreBusinessRuleData(data)) {
      return errors;
    }

    // Validate item count is reasonable
    if (data.items && data.items.length > 100) {
      errors.push(
        new ValidationError(
          'Cannot store more than 100 items in a single request',
          'items',
          'TOO_MANY_ITEMS'
        )
      );
    }

    // Validate deduplication settings consistency
    if (data.deduplication && data.deduplication.enabled) {
      if (
        data.deduplication.cross_scope_deduplication &&
        data.deduplication.check_within_scope_only
      ) {
        errors.push(
          new ValidationError(
            'Cannot enable both cross_scope_deduplication and check_within_scope_only',
            'deduplication',
            'CONFLICTING_SETTINGS'
          )
        );
      }
    }

    // Validate TTL settings
    if (data.items) {
      data.items.forEach((item: unknown,  _index: number) => {
        if (typeof item === 'object' && item !== null && 'ttl_config' in item) {
          const ttlConfig = (item as unknown).ttl_config;
          if (ttlConfig && ttlConfig.expires_at) {
            const expiryDate = new Date(ttlConfig.expires_at);
            if (expiryDate <= new Date()) {
              errors.push(
                new ValidationError(
                  `Item ${index} has already expired`,
                  `items[${index}].ttl_config.expires_at`,
                  'ALREADY_EXPIRED'
                )
              );
            }
          }
        }
      });
    }

    return errors;
  }

  /**
   * Business rule validation for memory_find
   */
  private validateMemoryFindBusinessRules(data: unknown): ValidationError[] {
    const errors: ValidationError[] = [];

    if (!isMemoryFindBusinessRuleData(data)) {
      return errors;
    }

    // Validate pagination
    if (data.limit && data.offset && data.limit + data.offset > 1000) {
      errors.push(
        new ValidationError(
          'Cannot request more than 1000 total results (limit + offset)',
          'pagination',
          'TOO_MANY_RESULTS'
        )
      );
    }

    // Validate time window
    if (data.filters) {
      const { created_after, created_before } = data.filters;
      if (created_after && created_before) {
        const after = new Date(created_after);
        const before = new Date(created_before);
        if (after >= before) {
          errors.push(
            new ValidationError(
              'created_after must be before created_before',
              'filters.time_window',
              'INVALID_TIME_WINDOW'
            )
          );
        }
      }
    }

    // Validate graph expansion
    if (data.graph_expansion && data.graph_expansion.enabled) {
      const { max_depth, max_nodes } = data.graph_expansion;
      if (max_depth && max_nodes && max_depth * max_nodes > 10000) {
        errors.push(
          new ValidationError(
            'Graph expansion parameters may cause performance issues (max_depth * max_nodes > 10000)',
            'graph_expansion',
            'PERFORMANCE_RISK'
          )
        );
      }
    }

    return errors;
  }

  /**
   * Business rule validation for system_status
   */
  private validateSystemStatusBusinessRules(data: unknown): ValidationError[] {
    const errors: ValidationError[] = [];

    if (!isSystemStatusBusinessRuleData(data)) {
      return errors;
    }

    // Validate operation-specific requirements
    switch (data.operation) {
      case 'get_document':
      case 'reassemble_document':
      case 'get_document_with_chunks':
        if (!data.document_id) {
          errors.push(
            new ValidationError(
              `Operation ${data.operation} requires document_id`,
              'document_id',
              'MISSING_REQUIRED_PARAMETER'
            )
          );
        }
        break;
      case 'confirm_cleanup':
        if (!data.cleanup_token) {
          errors.push(
            new ValidationError(
              'Operation confirm_cleanup requires cleanup_token',
              'cleanup_token',
              'MISSING_REQUIRED_PARAMETER'
            )
          );
        }
        break;
      default:
        // No operation-specific requirements for unknown operations
        break;
    }

    return errors;
  }

  /**
   * Business rule validation for performance_monitoring
   */
  private validatePerformanceMonitoringBusinessRules(data: unknown): ValidationError[] {
    const errors: ValidationError[] = [];

    if (!isPerformanceMonitoringBusinessRuleData(data)) {
      return errors;
    }

    // Validate time window
    if (data.time_window) {
      const { start_time, end_time, last_hours, last_days } = data.time_window;

      if (start_time && end_time) {
        const start = new Date(start_time);
        const end = new Date(end_time);
        if (start >= end) {
          errors.push(
            new ValidationError(
              'start_time must be before end_time',
              'time_window',
              'INVALID_TIME_WINDOW'
            )
          );
        }
      }

      if (last_hours && last_days) {
        errors.push(
          new ValidationError(
            'Cannot specify both last_hours and last_days',
            'time_window',
            'CONFLICTING_PARAMETERS'
          )
        );
      }
    }

    return errors;
  }

  /**
   * Generate warnings for potential issues
   */
  private generateWarnings(_schemaName: SchemaName,  data: unknown): string[] {
    const warnings: string[] = [];

    switch (_schemaName) {
      case 'memory_store':
        if (isMemoryStoreBusinessRuleData(data)) {
          if (data.items && data.items.length > 50) {
            warnings.push(
              'Large batch size detected (>50 items). Consider processing in smaller batches for better performance.'
            );
          }
          if (data.deduplication && (data.deduplication as unknown).max_items_to_check > 1000) {
            warnings.push('High max_items_to_check value may impact deduplication performance.');
          }
        }
        break;
      case 'memory_find':
        if (isMemoryFindBusinessRuleData(data)) {
          if (
            data.graph_expansion &&
            data.graph_expansion.enabled &&
            data.graph_expansion.max_depth &&
            data.graph_expansion.max_depth > 3
          ) {
            warnings.push('Deep graph expansion (max_depth > 3) may cause performance issues.');
          }
          if (data.limit && data.limit > 50) {
            warnings.push(
              'Large result set requested (>50 items). Consider using pagination for better performance.'
            );
          }
        }
        break;
      default:
        // No warnings for unknown schema types
        break;
    }

    return warnings;
  }

  /**
   * Migrate legacy input format to enhanced format
   */
  private migrateLegacyInput(
    _schemaName: SchemaName, 
    input: unknown
  ): { migrated: boolean; input: unknown; notes: string[] } {
    try {
      switch (_schemaName) {
        case 'memory_store': {
          const storeResult = SchemaMigrator.migrateMemoryStore(input);
          return { migrated: true, input: storeResult.migrated, notes: storeResult.notes };
        }
        case 'memory_find': {
          const findResult = SchemaMigrator.migrateMemoryFind(input);
          return { migrated: true, input: findResult.migrated, notes: findResult.notes };
        }
        case 'system_status': {
          const statusResult = SchemaMigrator.migrateSystemStatus(input);
          return { migrated: true, input: statusResult.migrated, notes: statusResult.notes };
        }
        default:
          return { migrated: false, input, notes: [] };
      }
    } catch (error) {
      return {
        migrated: false,
        input,
        notes: [`Migration failed: ${error instanceof Error ? error.message : 'Unknown error'}`],
      };
    }
  }
}

// ============================================================================
// Convenience Functions
// ============================================================================

/**
 * Validate memory_store input with enhanced features
 */
export function validateMemoryStore(input: unknown,  options?: ValidationOptions): ValidationResult {
  return SchemaValidator.getInstance().validateEnhanced('memory_store', input, options);
}

/**
 * Validate memory_find input with enhanced features
 */
export function validateMemoryFind(input: unknown,  options?: ValidationOptions): ValidationResult {
  return SchemaValidator.getInstance().validateEnhanced('memory_find', input, options);
}

/**
 * Validate system_status input with enhanced features
 */
export function validateSystemStatus(
  input: unknown, 
  options?: ValidationOptions
): ValidationResult {
  return SchemaValidator.getInstance().validateEnhanced('system_status', input, options);
}

/**
 * Validate performance_monitoring input with enhanced features
 */
export function validatePerformanceMonitoring(
  input: unknown, 
  options?: ValidationOptions
): ValidationResult {
  return SchemaValidator.getInstance().validateEnhanced('performance_monitoring', input, options);
}

/**
 * Legacy validation for backward compatibility
 */
export function validateLegacyMemoryStore(input: unknown): ValidationResult {
  return SchemaValidator.getInstance().validateLegacy('memory_store', input);
}

export function validateLegacyMemoryFind(input: unknown): ValidationResult {
  return SchemaValidator.getInstance().validateLegacy('memory_find', input);
}
