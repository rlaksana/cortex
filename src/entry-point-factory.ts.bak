#!/usr/bin/env node

/**
 * Cortex Memory MCP Server - Entry Point Factory
 *
 * This module provides a standardized factory for creating MCP server instances
 * with consistent initialization patterns, error handling, and graceful shutdown.
 *
 * Features:
 * - Eliminates circular dependencies between entry points
 * - Provides consistent initialization patterns
 * - Implements proper error handling and graceful shutdown
 * - Supports both silent and verbose modes
 * - Ensures proper resource cleanup
 *
 * @author Cortex Team
 * @version 2.0.1
 * @since 2025
 */

import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import type { ZodRawShape } from 'zod';
import { z } from 'zod';
import { autoEnvironment } from './config/auto-environment.js';
import { databaseAccessInterceptor } from './services/core/database-access-interceptor.js';
import { serviceLayerRouter, createServiceContext } from './services/core/service-layer-router.js';

// Enhanced logger with configurable output
export interface LoggerConfig {
  level: 'error' | 'warn' | 'info' | 'debug';
  silent: boolean;
  prefix?: string;
}

export class EntryPointLogger {
  private config: LoggerConfig;
  private originalConsoleError: typeof console.error;
  private originalConsoleLog: typeof console.log;
  private capturedLogs: string[] = [];

  constructor(config: LoggerConfig) {
    this.config = config;
    this.originalConsoleError = console.error;
    this.originalConsoleLog = console.log;

    if (config.silent) {
      this.enableSilentMode();
    }
  }

  private enableSilentMode(): void {
    console.error = (...args: unknown[]) => {
      this.capturedLogs.push(`[ERROR] ${args.join(' ')}`);
    };

    console.log = (...args: unknown[]) => {
      this.capturedLogs.push(`[INFO] ${args.join(' ')}`);
    };
  }

  public restoreConsole(): void {
    console.error = this.originalConsoleError;
    console.log = this.originalConsoleLog;
  }

  public shouldLog(_level: string): boolean {
    const levels: Record<string, number> = { error: 0, warn: 1, info: 2, debug: 3 };
    return levels[level] <= levels[this.config.level];
  }

  public error(message: string,  ...args: unknown[]): void {
    if (this.shouldLog('error')) {
      const prefix = this.config.prefix ? `[${this.config.prefix}] ` : '';
      console.error(`${prefix}[ERROR] ${message}`, ...args);
    }
  }

  public warn(message: string,  ...args: unknown[]): void {
    if (this.shouldLog('warn')) {
      const prefix = this.config.prefix ? `[${this.config.prefix}] ` : '';
      console.error(`${prefix}[WARN] ${message}`, ...args);
    }
  }

  public info(message: string,  ...args: unknown[]): void {
    if (this.shouldLog('info') && !this.config.silent) {
      const prefix = this.config.prefix ? `[${this.config.prefix}] ` : '';
      console.error(`${prefix}[INFO] ${message}`, ...args);
    }
  }

  public debug(message: string,  ...args: unknown[]): void {
    if (this.shouldLog('debug') && !this.config.silent) {
      const prefix = this.config.prefix ? `[${this.config.prefix}] ` : '';
      console.error(`${prefix}[DEBUG] ${message}`, ...args);
    }
  }

  public getCapturedLogs(): string[] {
    return [...this.capturedLogs];
  }

  public clearCapturedLogs(): void {
    this.capturedLogs = [];
  }
}

// Simple UUID generator
function generateUUID(): string {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,  (c) => {
    const r = (Math.random() * 16) | 0;
    const v = c === 'x' ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

// Type definitions
export interface StoredItem {
  id: string;
  kind: string;
  data: unknown;
  scope?: {
    project?: string;
    branch?: string;
    org?: string;
  };
  timestamp: string;
  stored: boolean;
}

export interface MemoryStoreItem {
  kind: string;
  data: unknown;
  scope?: {
    project?: string;
    branch?: string;
    org?: string;
  };
}

export interface MemoryFindArgs {
  query: string;
  scope?: {
    project?: string;
    branch?: string;
    org?: string;
  };
  types?: string[];
  limit?: number;
}

// Qdrant client interface for optional import
interface QdrantClient {
  getCollection(_name: string): Promise<{ points_count: number }>;
  createCollection(
    name: string,
    config: { vectors: { size: number; distance: string } }
  ): Promise<void>;
  upsert(
    name: string,
    points: { id: string; vector: number[]; payload: StoredItem }[]
  ): Promise<void>;
  search(
    _name: string, 
    config: {
      vector: number[];
      limit: number;
      filter?: Record<string,  unknown>;
      with_payload: boolean;
    }
  ): Promise<Array<{ payload?: StoredItem }>>;
}

export interface ServerConfig {
  name: string;
  version: string;
  logger: LoggerConfig;
  collectionName?: string;
  qdrantUrl?: string;
  qdrantApiKey?: string;
}

export interface HealthStatus {
  success: boolean;
  timestamp: string;
  server: {
    name: string;
    version: string;
    uptime: number;
    memory: NodeJS.MemoryUsage;
  };
  database: {
    type: string;
    url: string;
    collection: string;
    collectionExists: boolean;
    totalItems: number;
    storage: string;
  };
  features: {
    storage: {
      qdrant: boolean;
      memory: boolean;
    };
  };
  operation?: string;
  cleanup?: unknown;
}

export class McpServerFactory {
  private logger: EntryPointLogger;
  private config: ServerConfig;
  private server: McpServer;
  private qdrantClient: QdrantClient | null = null;
  private memoryStore: Map<string, StoredItem> = new Map();
  private isShuttingDown = false;

  constructor(config: ServerConfig) {
    this.config = config;
    this.logger = new EntryPointLogger(config.logger);
    this.server = new McpServer({
      name: config.name,
      version: config.version,
    });
  }

  public async initialize(): Promise<void> {
    try {
      this.logger.info('Initializing MCP Server...');

      // P0-CRITICAL: Initialize service layer routing first
      await this.initializeServiceLayer();

      // Initialize advanced features
      await this.initializeAdvancedFeatures();

      // Register tools
      await this.registerTools();

      // Setup graceful shutdown handlers
      this.setupGracefulShutdown();

      this.logger.info('MCP Server initialized successfully');
    } catch (error) {
      this.logger.error('Failed to initialize MCP Server:', error);
      throw error;
    }
  }

  private async initializeServiceLayer(): Promise<void> {
    try {
      this.logger.info('Initializing service layer routing...');

      // Initialize service layer router
      await serviceLayerRouter.initialize();

      // Initialize database access interceptor
      await databaseAccessInterceptor.initialize();

      // Register this entry point as allowed caller for database operations
      databaseAccessInterceptor.registerAllowedCaller('entry-point-factory');

      this.logger.info('Service layer routing initialized successfully');
    } catch (error) {
      this.logger.error('Failed to initialize service layer:', error);
      throw error;
    }
  }

  private async initializeAdvancedFeatures(): Promise<void> {
    try {
      // P0-CRITICAL: Use centralized Qdrant provider instead of hardcoded values
      const { getQdrantConnectionOptions } = await import('./config/qdrant-provider.js');
      const qdrantOptions = getQdrantConnectionOptions();

      // Try to import Qdrant client for vector storage
      const qdrantModule = await import('@qdrant/js-client-rest');
      this.qdrantClient = new qdrantModule.QdrantClient(qdrantOptions);
      this.logger.info('Qdrant client initialized', { url: qdrantOptions.url });
    } catch (error) {
      this.logger.warn('Qdrant client not available, using in-memory storage:', error);
    }
  }

  private async registerTools(): Promise<void> {
    const collectionName =
      this.config.collectionName || process.env.QDRANT_COLLECTION_NAME || 'cortex-memory';

    // Basic schemas for MCP registration
    const memoryStoreSchema: ZodRawShape = {
      items: z.string().optional().describe('Array of knowledge items to store (JSON string)'),
    };

    const memoryFindSchema: ZodRawShape = {
      query: z.string().optional().describe('Search query'),
      scope: z.string().optional().describe('Search scope (JSON string)'),
      types: z.string().optional().describe('Knowledge types to filter (JSON array string)'),
      limit: z.number().optional().describe('Maximum results'),
    };

    const systemStatusSchema: ZodRawShape = {
      operation: z.string().optional().describe('System operation to perform'),
    };

    // Register memory_store tool
    this.server.registerTool(
      'memory_store', 
      {
        title: 'Memory Store', 
        _description:
          'Store knowledge items in Cortex memory with advanced deduplication,  _TTL,  _truncation,  and insights.', 
        _inputSchema: memoryStoreSchema, 
      }, 
      async (args: { items?: string },  _extra: unknown) => {
        try {
          this.logger.info('Memory store tool called', { itemCount: args.items?.length || 0 });

          // Parse JSON string items
          let parsedItems: MemoryStoreItem[] = [];
          if (args.items) {
            try {
              parsedItems = JSON.parse(args.items);
            } catch (_parseError) {
              throw new McpError(
                ErrorCode.InvalidParams,
                `Invalid JSON in items parameter: ${parseError instanceof Error ? parseError.message : 'Unknown error'}`
              );
            }
          }

          // P0-CRITICAL: Route through service layer
          const context = createServiceContext('memory-store', 'store', {
            items: parsedItems,
          });

          const result = await serviceLayerRouter.route(context);

          return {
            content: [
              {
                type: 'text',
                text: JSON.stringify(
                  {
                    success: result.success,
                    data: result.data,
                    error: result.error,
                    metadata: {
                      ...result.metadata,
                      timestamp: new Date().toISOString(),
                      routing: 'service-layer',
                    },
                  },
                  null,
                  2
                ),
              },
            ],
          };
        } catch (error) {
          this.logger.error('Memory store tool failed:', error);
          throw new McpError(
            ErrorCode.InternalError,
            `Memory store failed: ${error instanceof Error ? error.message : 'Unknown error'}`
          );
        }
      }
    );

    // Register memory_find tool
    this.server.registerTool(
      'memory_find', 
      {
        title: 'Memory Find', 
        _description: 'Search Cortex memory with advanced strategies and graph expansion.', 
        _inputSchema: memoryFindSchema, 
      }, 
      async (
        args: { query?: string; scope?: string; types?: string; limit?: number }, 
        _extra: unknown
      ) => {
        try {
          this.logger.info('Memory find tool called', {
            query: args.query?.substring(0, 100) + '...',
          });

          // Parse JSON strings
          let parsedScope: MemoryFindArgs['scope'] = undefined;
          if (args.scope) {
            try {
              parsedScope = JSON.parse(args.scope);
            } catch (_parseError) {
              // Continue with undefined scope if parse fails
              this.logger.warn('Invalid JSON in scope parameter', { error: parseError });
            }
          }

          let parsedTypes: string[] = [];
          if (args.types) {
            try {
              parsedTypes = JSON.parse(args.types);
            } catch (_parseError) {
              // Continue with empty types if parse fails
              this.logger.warn('Invalid JSON in types parameter', { error: parseError });
            }
          }

          // P0-CRITICAL: Route through service layer
          const context = createServiceContext('memory-store', 'find', {
            query: args.query || '',
            scope: parsedScope,
            types: parsedTypes,
            limit: args.limit || 10,
          });

          const result = await serviceLayerRouter.route(context);

          return {
            content: [
              {
                type: 'text',
                text: JSON.stringify(
                  {
                    success: result.success,
                    data: result.data,
                    error: result.error,
                    metadata: {
                      ...result.metadata,
                      timestamp: new Date().toISOString(),
                      routing: 'service-layer',
                    },
                  },
                  null,
                  2
                ),
              },
            ],
          };
        } catch (error) {
          this.logger.error('Memory find tool failed:', error);
          throw new McpError(
            ErrorCode.InternalError,
            `Memory find failed: ${error instanceof Error ? error.message : 'Unknown error'}`
          );
        }
      }
    );

    // Register system_status tool
    this.server.registerTool(
      'system_status', 
      {
        title: 'System Status', 
        _description: 'System monitoring,  _cleanup,  and maintenance operations.', 
        _inputSchema: systemStatusSchema, 
      }, 
      async (args: { operation?: string },  _extra: unknown) => {
        try {
          this.logger.info('System status tool called', { operation: args.operation });
          const status = await this.getSystemStatus(args.operation);
          return {
            content: [
              {
                type: 'text',
                text: JSON.stringify(status, null, 2),
              },
            ],
          };
        } catch (error) {
          this.logger.error('System status tool failed:', error);
          throw new McpError(
            ErrorCode.InternalError,
            `System status failed: ${error instanceof Error ? error.message : 'Unknown error'}`
          );
        }
      }
    );
  }

  private storeItems(
    _items: MemoryStoreItem[]
  ): Promise<{ stored: number; errors: string[] }> {
    const errors: string[] = [];
    const collectionName =
      this.config.collectionName || process.env.QDRANT_COLLECTION_NAME || 'cortex-memory';

    for (const item of items) {
      try {
        const id = generateUUID();
        const timestamp = new Date().toISOString();
        const storedItem: StoredItem = {
          id,
          kind: item.kind,
          data: item.data,
          scope: item.scope,
          timestamp,
          stored: true,
        };

        // Store in memory
        this.memoryStore.set(id, storedItem);

        // Try to store in Qdrant if available
        if (this.qdrantClient) {
          try {
            // Ensure collection exists
            try {
              await this.qdrantClient.getCollection(collectionName);
            } catch {
              await this.qdrantClient.createCollection(collectionName, {
                vectors: {
                  size: 384,
                  distance: 'Cosine',
                },
              });
            }

            await this.qdrantClient.upsert(collectionName, [
              {
                id,
                vector: Array(384).fill(0), // Placeholder embedding
                payload: storedItem,
              },
            ]);
          } catch (_qdrantError) {
            this.logger.warn('Qdrant storage failed, using in-memory only:', qdrantError);
          }
        }
      } catch (error) {
        errors.push(
          `Failed to store item: ${error instanceof Error ? error.message : 'Unknown error'}`
        );
      }
    }

    return { stored: items.length, errors };
  }

  private findItems(
    _args: MemoryFindArgs
  ): Promise<{ _results: StoredItem[]; total_count: number }> {
    const query = args.query || '';
    const scope = args.scope || { project: undefined, branch: undefined, org: undefined };
    const types = args.types || [];
    const limit = args.limit || 10;
    const collectionName =
      this.config.collectionName || process.env.QDRANT_COLLECTION_NAME || 'cortex-memory';

    let results = Array.from(this.memoryStore.values());

    // Apply filters
    if (types.length > 0) {
      results = results.filter((item) => types.includes(item.kind));
    }

    if (scope.project || scope.branch || scope.org) {
      results = results.filter((item) => {
        if (!item.scope) return false;
        if (scope.project && item.scope.project !== scope.project) return false;
        if (scope.branch && item.scope.branch !== scope.branch) return false;
        if (scope.org && item.scope.org !== scope.org) return false;
        return true;
      });
    }

    // Simple text search
    if (_query) {
      const queryLower = query.toLowerCase();
      results = results.filter((item) =>
        JSON.stringify(item.data).toLowerCase().includes(queryLower)
      );
    }

    // Try Qdrant search if available
    if (this.qdrantClient && query) {
      try {
        const filter = { must: [] as unknown[] }; // Use any array to avoid type issues

        if (types.length > 0) {
          filter.must.push({
            key: 'kind',
            match: { any: types },
          });
        }

        if (scope.project || scope.branch || scope.org) {
          const scopeFilter = { must: [] as unknown[] }; // Use any array to avoid type issues
          if (scope.project) {
            scopeFilter.must.push({
              key: 'scope.project',
              match: { value: scope.project },
            });
          }
          if (scope.branch) {
            scopeFilter.must.push({
              key: 'scope.branch',
              match: { value: scope.branch },
            });
          }
          if (scope.org) {
            scopeFilter.must.push({
              key: 'scope.org',
              match: { value: scope.org },
            });
          }
          filter.must.push(scopeFilter);
        }

        const searchResult = await this.qdrantClient.search(collectionName, {
          vector: Array(384).fill(0.1),
          limit,
          filter: filter.must.length > 0 ? filter : undefined,
          with_payload: true,
        });

        const qdrantResults = searchResult.map(
          (point: { payload?: StoredItem }) => point.payload as StoredItem
        );
        const combinedResults = [...qdrantResults];
        for (const item of results) {
          if (!combinedResults.find((r) => r.id === item.id)) {
            combinedResults.push(item);
          }
        }
        results = combinedResults.slice(0, limit);
      } catch (_qdrantError) {
        this.logger.warn('Qdrant search failed, using memory-only results:', qdrantError);
      }
    }

    return {
      _results: results.slice(0, limit),
      total_count: results.length,
    };
  }

  private getSystemStatus(
    operation?: string
  ): Promise<HealthStatus & { operation?: string; cleanup?: Record<string, unknown> }> {
    const collectionName =
      this.config.collectionName || process.env.QDRANT_COLLECTION_NAME || 'cortex-memory';
    let collectionExists = false;
    let totalItems = this.memoryStore.size;

    if (this.qdrantClient) {
      try {
        const collectionInfo = await this.qdrantClient.getCollection(collectionName);
        totalItems = collectionInfo.points_count;
        collectionExists = true;
      } catch {
        // Collection doesn't exist or connection failed
      }
    }

    const status: HealthStatus = {
      success: true,
      timestamp: new Date().toISOString(),
      server: {
        name: this.config.name,
        version: this.config.version,
        uptime: process.uptime(),
        memory: process.memoryUsage(),
      },
      database: {
        type: this.qdrantClient ? 'qdrant' : 'in-memory',
        url: (() => {
          try {
            // P0-CRITICAL: Use centralized Qdrant provider
            const { getQdrantUrl } = require('./config/qdrant-provider.js');
            return getQdrantUrl();
          } catch {
            return 'http://localhost:6333'; // Fallback for logging purposes only
          }
        })(),
        collection: collectionName,
        collectionExists,
        totalItems,
        storage: this.qdrantClient ? 'vector database (persistent)' : 'in-memory (ephemeral)',
      },
      features: {
        storage: {
          qdrant: !!this.qdrantClient,
          memory: true,
        },
      },
      operation,
    };

    // Perform system operation if specified
    if (operation === 'cleanup') {
      const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
      let cleaned = 0;

      for (const [id, item] of this.memoryStore.entries()) {
        if (new Date(item.timestamp) < thirtyDaysAgo) {
          this.memoryStore.delete(id);
          cleaned++;
        }
      }

      return { ...status, cleanup: { itemsRemoved: cleaned } };
    }

    return status;
  }

  private setupGracefulShutdown(): void {
    const shutdown = (signal: string): void => {
      if (this.isShuttingDown) return;
      this.isShuttingDown = true;

      this.logger.info(`Received ${signal}, shutting down gracefully...`);

      // Cleanup resources
      this.memoryStore.clear();

      // Restore console if in silent mode
      if (this.config.logger.silent) {
        this.logger.restoreConsole();
      }

      process.exit(0);
    };

    process.on('SIGINT',  () => { shutdown('SIGINT'); });
    process.on('SIGTERM',  () => { shutdown('SIGTERM'); });
    process.on('uncaughtException',  (error) => {
      this.logger.error('Uncaught exception:', error);
      shutdown('uncaughtException');
    });
    process.on('unhandledRejection',  (reason,  _promise) => {
      this.logger.error('Unhandled rejection at:', promise, 'reason:', reason);
      shutdown('unhandledRejection');
    });
  }

  public async startTransport(): Promise<void> {
    try {
      const transport = new StdioServerTransport();
      await this.server.connect(transport);
      this.logger.info('MCP Server transport started successfully');
    } catch (error) {
      this.logger.error('Failed to start transport:', error);
      throw error;
    }
  }

  public getServer(): McpServer {
    return this.server;
  }

  public getLogger(): EntryPointLogger {
    return this.logger;
  }

  public async shutdown(): Promise<void> {
    if (this.isShuttingDown) return;

    this.isShuttingDown = true;
    this.logger.info('Shutting down MCP Server...');

    // Cleanup resources
    this.memoryStore.clear();

    // Restore console if in silent mode
    if (this.config.logger.silent) {
      this.logger.restoreConsole();
    }
  }
}

// Factory function for creating server instances with automatic environment configuration
export function createMcpServer(config: Partial<ServerConfig> = {}): McpServerFactory {
  // Initialize automatic environment configuration
  const envStatus = autoEnvironment.getConfigurationStatus();

  // Check if environment is properly configured
  if (!envStatus.isConfigured) {
    const setupInstructions = autoEnvironment.getSetupInstructions();
    throw new Error(
      `Cortex MCP Server configuration incomplete:\n` +
        `- ${envStatus.errors.join('\n- ')}\n\n` +
        `Setup instructions:\n` +
        setupInstructions.join('\n')
    );
  }

  const defaultConfig: ServerConfig = {
    name: 'cortex-memory-mcp',
    version: '2.0.1',
    logger: {
      level: (process.env.LOG_LEVEL as 'error' | 'warn' | 'info' | 'debug') || 'info',
      silent: false,
      prefix: 'CORTEX',
    },
    collectionName: (() => {
      try {
        // P0-CRITICAL: Use centralized Qdrant provider for collection name
        const { qdrantProvider } = require('./config/qdrant-provider.js');
        return qdrantProvider.getCollectionConfig().name;
      } catch {
        return 'cortex-memory'; // Fallback for logging purposes only
      }
    })(),
    qdrantUrl: (() => {
      try {
        // P0-CRITICAL: Use centralized Qdrant provider
        const { getQdrantUrl } = require('./config/qdrant-provider.js');
        return getQdrantUrl();
      } catch {
        return 'http://localhost:6333'; // Fallback for logging purposes only
      }
    })(),
    qdrantApiKey: process.env.QDRANT_API_KEY,
  };

  const mergedConfig = { ...defaultConfig, ...config };

  // Add environment status to config for debugging
  const serverFactory = new McpServerFactory(mergedConfig);

  // Log auto-configuration status in development mode
  if (process.env.NODE_ENV === 'development' || process.env.DEBUG_MODE === 'true') {
    const safeConfig = autoEnvironment.getSafeEnvironmentConfig();
    console.error(
      `[AUTO-CONFIG] Environment status: ${envStatus.isConfigured ? '✅ Configured' : '❌ Incomplete'}`
    );
    console.error(
      `[AUTO-CONFIG] Auto-configured: ${envStatus.autoConfigured ? '✅ Yes' : '❌ No'}`
    );
    console.error(`[AUTO-CONFIG] OpenAI API Key: ${safeConfig.OPENAI_API_KEY || '❌ Missing'}`);
    console.error(`[AUTO-CONFIG] Qdrant URL: ${safeConfig.QDRANT_URL}`);
    console.error(`[AUTO-CONFIG] Source: ${envStatus.openaiApiKeySource}`);
  }

  return serverFactory;
}

// Export for convenience
export { generateUUID };
